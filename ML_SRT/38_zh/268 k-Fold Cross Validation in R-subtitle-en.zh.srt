1
00:00:00,360 --> 00:00:06,360
您好，欢迎您为这项艺术而努力，并且主要欢迎您参加本课程调酒课程的最后一部分

2
00:00:06,360 --> 00:00:08,290
选择和提升。

3
00:00:08,340 --> 00:00:10,170
因此，在这一部分中，我们将做两件事。

4
00:00:10,200 --> 00:00:16,010
首先评估我们的道德表现，其次改善我们的模型表现。

5
00:00:16,020 --> 00:00:20,430
然后将有一个关于机器学习中最强大的算法之一的奖励部分

6
00:00:20,760 --> 00:00:24,610
它变得越来越流行，这被称为极限提升。

7
00:00:24,780 --> 00:00:29,690
但是首先，我们希望能够改善我们拥有的所有机器学习模型的模型性能

8
00:00:29,700 --> 00:00:35,520
可以使用称为模型选择的技术来完成本课程的学习并提高模型性能

9
00:00:35,790 --> 00:00:41,490
包括选择机器学习模型的最佳参数，因为您知道

10
00:00:41,730 --> 00:00:46,310
每次我们建立机器学习模型时，我们都有两种类型的参数。

11
00:00:46,320 --> 00:00:51,210
模型学习的参数的第一种类型是已更改的参数，

12
00:00:51,210 --> 00:00:57,210
通过运行模型找到最优值，然后运行第二种类型的参数

13
00:00:57,210 --> 00:00:58,760
我们选择了自己。

14
00:00:58,770 --> 00:01:04,710
例如我们模型中的内核中的内核参数，这些参数称为hyper

15
00:01:04,710 --> 00:01:05,790
参数。

16
00:01:05,790 --> 00:01:10,920
因此，仍有改进模型的空间，因为我们仍然可以为这些模型选择一些最佳值

17
00:01:10,920 --> 00:01:11,810
参数。

18
00:01:11,970 --> 00:01:17,220
但是由于这些参数是模型学习到的另一个参数，所以我们需要找出另一个

19
00:01:17,220 --> 00:01:22,280
为超级参数选择这些参数的最佳值的方法。

20
00:01:22,500 --> 00:01:27,180
这是我们在第10部分中将要做的强大功能之一，它将通过非常有效的方式

21
00:01:27,180 --> 00:01:29,170
这种技术称为网格搜索。

22
00:01:29,430 --> 00:01:35,580
但是在开始网格搜索之前，我们需要优化评估模型的方式，因为到目前为止

23
00:01:35,580 --> 00:01:39,550
我们所做的是将我们的数据集分为训练集和测试集。

24
00:01:39,660 --> 00:01:44,970
您知道我们在训练集上训练了模型，并在测试集上测试了模型的性能。

25
00:01:45,000 --> 00:01:48,200
这是评估模型性能的正确方法。

26
00:01:48,270 --> 00:01:53,430
但这不是最好的方法，因为我们实际上有方差问题，方差问题可以是

27
00:01:53,430 --> 00:01:57,110
解释的事实是，当我们获得测试集的准确性时。

28
00:01:57,330 --> 00:02:01,810
好吧，如果我们再次运行模型并再次测试，则它是另一个测试集的性能。

29
00:02:02,010 --> 00:02:04,460
好吧，我们可以获得非常不同的精度。

30
00:02:04,770 --> 00:02:11,700
因此，仅根据一个测试集的一种准确性来判断我们的模型性能实际上并没有多大关系。

31
00:02:11,700 --> 00:02:15,620
这不是评估模型性能的最相关方法。

32
00:02:15,720 --> 00:02:21,330
因此，有一种称为K4交叉验证的技术对此进行了很大的改进，因为这会

33
00:02:21,330 --> 00:02:28,470
解决这个Varians问题，以及如何解决它，它将训练集旋转成十倍来解决

34
00:02:28,740 --> 00:02:29,740
蛋糕什么时候站立。

35
00:02:29,760 --> 00:02:31,760
而且大多数时候蛋糕都会站起来。

36
00:02:31,980 --> 00:02:36,760
然后将模型训练九倍，然后在最后一只脚上进行测试。

37
00:02:36,900 --> 00:02:42,550
由于发生了10次跌落，我们可以对9个四分之一进行10种不同的组合来对模型和一个进行趋势分析

38
00:02:42,550 --> 00:02:43,800
为了测试它。

39
00:02:43,800 --> 00:02:49,860
这意味着我们可以训练模型并在所有N10训练和测试组合中进行测试，并且

40
00:02:49,920 --> 00:02:54,570
这将使我们对模型性能有了更好的了解，因为我们必须做的是

41
00:02:55,020 --> 00:03:01,050
取不同精度的平均值，最多进行10次评估，并计算标准偏差

42
00:03:01,320 --> 00:03:02,890
看一下差异。

43
00:03:02,910 --> 00:03:08,520
因此，最终我们的分析将更加相关，此外，我们还将了解这四个中的哪一个

44
00:03:08,520 --> 00:03:14,010
类别是因为如果我们获得较高的准确度，并且较小的方差将位于左下方

45
00:03:14,010 --> 00:03:20,010
如果我们获得较大的准确度和较高的方差，那么如果我们获得较小的准确度，我们将位于右下方

46
00:03:20,010 --> 00:03:21,780
低方差的精度。

47
00:03:21,780 --> 00:03:26,730
我们将位于左上角，最终，如果我们得到的准确性低且方差大，我们将

48
00:03:26,730 --> 00:03:28,140
在右边的一个。

49
00:03:28,140 --> 00:03:31,310
因此，此K4交叉验证非常有用。

50
00:03:31,350 --> 00:03:35,200
除此以外，我们的绩效分析也更重要。

51
00:03:35,220 --> 00:03:38,630
因此，让我们从全国范围内的K4开始。

52
00:03:38,790 --> 00:03:41,180
我们第一个道德选择技术。

53
00:03:41,280 --> 00:03:45,280
因此，由于我们已经构建了许多模型，因此我们将不再构建另一个模型。

54
00:03:45,280 --> 00:03:50,410
我们将使用我们建立的模型之一，并在其上谨慎应用国家。

55
00:03:50,490 --> 00:03:56,040
因此，我们要使用的模型是该内核，即V.M。 我们在第三部分中进行了分类。

56
00:03:56,190 --> 00:04:01,470
我记得我们曾经预测客户是否会点击社交网络上的广告

57
00:04:01,710 --> 00:04:03,950
购买是的SUV。

58
00:04:03,960 --> 00:04:06,980
这样就已经建立了模型，我们已经拥有了一切。

59
00:04:07,080 --> 00:04:14,610
所以我们要做的是获取整个模型，然后在其中添加新的代码部分

60
00:04:14,610 --> 00:04:21,150
当然，这将是实现K4交叉验证的部分代码。

61
00:04:21,150 --> 00:04:26,260
因此，在开始执行操作之前，让我们选择正确的文件夹作为工作目录。

62
00:04:26,340 --> 00:04:27,550
所以我们去机器。

63
00:04:27,590 --> 00:04:30,150
正是我们现在处于本课程的最后一部分。

64
00:04:30,150 --> 00:04:36,830
恭喜您获得了调皮的鼠标选择和增强功能以​​及第48节的模型选择。

65
00:04:37,020 --> 00:04:37,380
好吧。

66
00:04:37,380 --> 00:04:40,210
确保在归档时拥有社交网络。

67
00:04:40,260 --> 00:04:42,200
如果是这样的话，您就准备好了。

68
00:04:42,600 --> 00:04:46,520
好的，现在我们在哪里应用K4交叉验证代码部分。

69
00:04:46,650 --> 00:04:52,890
好吧，因为这包括对它们的所有性能进行评估，所以可以说是最相关的位置

70
00:04:53,130 --> 00:04:57,160
在我们将内核构建为正确的模型之后是正确的。

71
00:04:57,180 --> 00:05:04,250
我们建立了模型，实际上在这里，我们可以预测测试结果和混淆

72
00:05:04,250 --> 00:05:08,240
矩阵，实际上是评估模型的第一种方法。

73
00:05:08,240 --> 00:05:13,820
但是正如我在本教程开始时所说的那样，这是评估模型的正确方法，但不是

74
00:05:13,820 --> 00:05:14,560
最好的。

75
00:05:14,660 --> 00:05:19,270
在今天的Statoil中，我们正在引入一种更好的方法来评估我们的模型。

76
00:05:19,550 --> 00:05:26,180
因此，就像更高级的性能评估方法一样，让我们​​将其放在本节之后。

77
00:05:26,180 --> 00:05:34,050
因此，我们将称之为K FULDE交叉验证的这一部分。

78
00:05:34,610 --> 00:05:40,550
好吧，现在我们要做的第一件事是安装胡萝卜包，因为其中包含

79
00:05:40,610 --> 00:05:45,120
一个非常实用的工具来创建我们训练集的十倍。

80
00:05:45,170 --> 00:05:53,430
因此，让我们从打包该安装并以括号括起来并引用Carrot的安装开始。

81
00:05:53,460 --> 00:05:54,030
好吧。

82
00:05:54,090 --> 00:05:59,640
所以我的已经安装了，我们可以检查一下并检查您的软件包列表中的内容。

83
00:05:59,640 --> 00:06:01,300
这是龋齿。

84
00:06:01,350 --> 00:06:04,300
因此，我将对此发表评论。

85
00:06:04,410 --> 00:06:11,880
但是不要忘记安装它，然后不要忘记自动导入库命令

86
00:06:11,880 --> 00:06:14,270
胡萝卜包。

87
00:06:14,370 --> 00:06:14,800
好吧。

88
00:06:14,820 --> 00:06:18,180
现在让我们开始编写仔细的交叉验证代码。

89
00:06:18,180 --> 00:06:24,450
所以首先我们要创建十个折痕，将我们的训练集分开，这样做非常

90
00:06:24,450 --> 00:06:25,220
简单。

91
00:06:25,220 --> 00:06:31,220
我们将使用胡萝卜包创建虚假函数来非常有效地创建这十折。

92
00:06:31,500 --> 00:06:32,220
因此，让我们开始吧。

93
00:06:32,220 --> 00:06:33,800
我们将这种情况称为折叠。

94
00:06:33,950 --> 00:06:39,050
折叠实际上是构成我们的训练集的10种不同测试折叠的列表。

95
00:06:39,180 --> 00:06:43,170
因此，让我们使用此创建首字母F的完整功能。

96
00:06:43,170 --> 00:06:44,040
这里是。

97
00:06:44,260 --> 00:06:48,660
在括号内，我们只需要指定训练集即可。

98
00:06:48,660 --> 00:06:50,720
所以在这里我要添加训练集。

99
00:06:51,000 --> 00:06:55,280
然后，我们使用我们的因变量，并调用它们以进行播放。

100
00:06:55,290 --> 00:07:00,000
您知道这就像我们在训练集和测试集之间划分天数时一样

101
00:07:00,000 --> 00:07:05,610
指定因变量进行拆分，以使测试集中的训练集分布均匀

102
00:07:05,700 --> 00:07:07,530
根据因变量。

103
00:07:07,650 --> 00:07:12,960
好吧，这是相同的，我们要创建10叠火车，并指定依赖项

104
00:07:12,960 --> 00:07:17,450
变量以确保根据因变量分布良好。

105
00:07:17,670 --> 00:07:24,590
因此，这就是为什么我们需要指定我们购买的Develin变量的原因。

106
00:07:24,610 --> 00:07:27,760
这是创建力函数的第一个参数。

107
00:07:27,760 --> 00:07:33,190
当然，您可能已经猜到了第二个参数是要除的FULDE数

108
00:07:33,190 --> 00:07:38,720
您选择的火车是四号的一个很好的选择。

109
00:07:38,740 --> 00:07:45,040
因为通过创建10折，我们最终将获得10精度，而10精度是相关方法

110
00:07:45,310 --> 00:07:49,500
通过这10个精度的平均值来测量准确性。

111
00:07:49,560 --> 00:07:50,720
因此，我们采取10。

112
00:07:50,740 --> 00:07:53,030
我建议在实践中这样做。

113
00:07:53,170 --> 00:07:57,520
所以这里我们只加K等于10

114
00:07:57,520 --> 00:07:58,360
好吧。

115
00:07:58,360 --> 00:08:03,850
现在，我们将执行仔细的交叉验证，因为我们在这里所做的只是创建

116
00:08:03,850 --> 00:08:04,600
折。

117
00:08:04,690 --> 00:08:10,960
但是现在我们需要实现算法本身，并且要做到这一点，有几种方法

118
00:08:10,960 --> 00:08:11,240
它。

119
00:08:11,350 --> 00:08:18,370
但是我们将在其中使用一个非常实用的函数，称为Laplae函数，该函数包括

120
00:08:18,700 --> 00:08:22,750
将函数应用于列表的不同元素的过程。

121
00:08:22,750 --> 00:08:30,280
因此，此列表将成为我们的完整列表，其中包含帐篷折叠，而函数是函数

122
00:08:30,280 --> 00:08:34,870
这将为这些帐篷中的每个帐篷计算准确性。

123
00:08:34,870 --> 00:08:41,620
因此，让我们首先创建一个新的，我们将其称为C-v，然后在这里使用此L适用

124
00:08:41,830 --> 00:08:42,930
功能。

125
00:08:42,970 --> 00:08:43,270
好吧。

126
00:08:43,300 --> 00:08:45,190
您将了解将会发生什么。

127
00:08:45,190 --> 00:08:51,700
因此，在此Laplae函数中，我们需要放置两个参数，第一个参数是元素列表

128
00:08:52,060 --> 00:08:55,900
我们将要应用下一个函数（下一个参数）的对象。

129
00:08:55,960 --> 00:08:59,440
因此，正如我刚才所说的，该列表是错误的。

130
00:08:59,440 --> 00:09:01,810
我们的帐篷清单如下。

131
00:09:02,170 --> 00:09:05,250
然后下一个参数是函数。

132
00:09:05,260 --> 00:09:09,860
因此，函数和R可以通过这种方式编写。

133
00:09:10,210 --> 00:09:17,490
然后在括号中，我们需要输入参数X，这是到目前为止的局部参数

134
00:09:17,800 --> 00:09:21,880
但是X实际上将是每个帐篷故障之一。

135
00:09:21,880 --> 00:09:25,930
所以这里是X，然后是一对括号。

136
00:09:25,930 --> 00:09:26,700
开始了。

137
00:09:26,860 --> 00:09:32,470
在这些括号内，我们将实现此功能，该功能将计算

138
00:09:32,470 --> 00:09:35,000
这些帐篷上的模型均会折叠。

139
00:09:35,170 --> 00:09:39,330
因此，基本上，在此功能中，我们将执行仔细的交叉验证。

140
00:09:39,640 --> 00:09:42,740
因此，我们需要执行仔细的交叉验证。

141
00:09:42,820 --> 00:09:49,060
首先我们需要训练场，训练场是我们退出的整个训练集

142
00:09:49,060 --> 00:09:49,980
测试折。

143
00:09:50,200 --> 00:09:58,570
因此，基本上，这里的培训是我创建一个新的局部变量，实际上称为“培训”

144
00:09:58,570 --> 00:09:59,230
故障。

145
00:09:59,230 --> 00:10:02,450
正如我刚才所说的，这是整个培训过程。

146
00:10:02,470 --> 00:10:03,270
开始了。

147
00:10:03,520 --> 00:10:12,280
但是我们撤回了减去X的测试折痕，因为您知道X实际上是X的每个元素

148
00:10:12,280 --> 00:10:13,690
这个虚假清单。

149
00:10:13,690 --> 00:10:17,120
因此，将负X放到这里，我们就可以得到整个训练集。

150
00:10:17,230 --> 00:10:18,580
但是没有测试失败。

151
00:10:18,700 --> 00:10:20,670
因此，这实际上是棘手的。

152
00:10:20,920 --> 00:10:24,940
然后拿起所有列好吧。

153
00:10:25,010 --> 00:10:26,800
所以我们得到了Tranfield。

154
00:10:26,840 --> 00:10:30,320
现在，让我们进行测试折叠或测试折叠。

155
00:10:30,380 --> 00:10:38,020
试着猜测等于等于训练集和方括号内的测试折数。

156
00:10:38,180 --> 00:10:39,690
好吧，我们需要在这里放什么。

157
00:10:39,830 --> 00:10:46,340
好吧，实际上是X，因为您知道X代表每个帐篷的所有观测值

158
00:10:46,340 --> 00:10:46,920
褶皱。

159
00:10:47,150 --> 00:10:49,830
因此，我们进行了测试。

160
00:10:50,270 --> 00:10:51,960
然后我们现在需要做什么。

161
00:10:52,190 --> 00:11:00,050
现在我们需要做的是训练我们的上校，因为我们都在训练场上，然后我们将进行测试

162
00:11:00,050 --> 00:11:02,270
它的性能在测试折叠上。

163
00:11:02,270 --> 00:11:04,170
因此，基本上，我们现在需要做什么。

164
00:11:04,310 --> 00:11:09,300
我们需要添加我们的模型作为V.M. 分类器。

165
00:11:09,620 --> 00:11:16,490
因此，我们现在可以做的只是在此处获取此代码部分，因为这是我们构建模型的地方，

166
00:11:16,490 --> 00:11:20,070
我们需要将此模型包含在函数中，这就是我们采用它的原因。

167
00:11:20,360 --> 00:11:25,240
复制并在此处添加粘贴。

168
00:11:25,460 --> 00:11:32,390
在这里，我们有了我们的模型，但我们没有在训练中训练该内核上校SVM分类器

169
00:11:32,390 --> 00:11:40,310
设置我们在训练力量上进行训练，因为这是Caple交叉验证的原则

170
00:11:40,310 --> 00:11:41,860
正在训练我们的分类器。

171
00:11:41,860 --> 00:11:44,250
十次训练中的每一次跌倒。

172
00:11:44,480 --> 00:11:51,920
这就是为什么我们在这里全力以赴，并在此功能内在此处创建

173
00:11:51,920 --> 00:11:55,340
现在，我们保持相同的论点。

174
00:11:55,520 --> 00:11:57,590
好吧，那我们需要做什么。

175
00:11:57,710 --> 00:12:03,140
好吧，这与我们制作预测测试的模型时所做的完全相同

176
00:12:03,140 --> 00:12:03,710
结果。

177
00:12:03,710 --> 00:12:10,400
这是下一步，因为从该测试得出的结果是，我们将计算出混淆

178
00:12:10,460 --> 00:12:16,220
矩阵，因此正是我们所需要的精度，也正是我们将要得到的精度

179
00:12:16,220 --> 00:12:21,350
由我们现在正在执行的函数返回的值，用于实现仔细的交叉验证。

180
00:12:21,350 --> 00:12:28,980
同样，让我们​​复制此行以预测测试结果，然后将其复制到此处。

181
00:12:29,120 --> 00:12:31,110
当然，这就是全部。

182
00:12:31,120 --> 00:12:38,610
否，因为我们不在测试集上进行测试或分类，而是在测试折叠上对其进行测试。

183
00:12:38,690 --> 00:12:38,960
对。

184
00:12:38,960 --> 00:12:44,080
因为您知道我们正在训练领域训练模型并在测试中测试其性能

185
00:12:44,080 --> 00:12:44,610
脚丫子。

186
00:12:44,840 --> 00:12:46,060
所以现在很好。

187
00:12:46,340 --> 00:12:52,470
现在让我们继续下一步，计算混淆矩阵。

188
00:12:52,500 --> 00:13:00,470
因此，仍然让我们在这里采取这一行，并将其粘贴在下面的粘贴中。

189
00:13:00,480 --> 00:13:06,710
现在，我们当然需要更改测试集，并通过测试折叠替换它。

190
00:13:06,740 --> 00:13:07,070
好吧。

191
00:13:07,070 --> 00:13:13,350
这会给我们这个分类器的混淆矩阵，因为它是所有上校SVM的全部

192
00:13:13,390 --> 00:13:14,310
分类器。

193
00:13:14,600 --> 00:13:19,780
然后在训练场上进行训练，并在测试场上进行测试。

194
00:13:20,000 --> 00:13:25,570
因此，这行代码将为您提供压缩矩阵，供您观察测试。

195
00:13:25,850 --> 00:13:26,540
好吧。

196
00:13:26,660 --> 00:13:33,740
现在最后一步，我们需要计算精度，因为我们正在做所有这些事情以获得精度的

197
00:13:34,130 --> 00:13:36,180
因为所有的帐篷都落在这里。

198
00:13:36,230 --> 00:13:42,840
因此，让我们计算准确度是我们已经多次计算了该准确度。

199
00:13:42,990 --> 00:13:51,030
我们将正确预测的数量视为n个得出的正确预测，因为这对应于

200
00:13:51,270 --> 00:13:59,640
第一类的正确预测加上cme的数量，因为这对应于

201
00:13:59,640 --> 00:14:02,610
第二类的正确预测数。

202
00:14:02,730 --> 00:14:09,020
并且由于我们有两个类别，因此该总和对应于正确预测的总数。

203
00:14:09,210 --> 00:14:18,030
然后我们将其除以测试中的观察总数，因此这就是

204
00:14:18,030 --> 00:14:20,950
正确的预测是这里的总和。

205
00:14:22,380 --> 00:14:29,430
我们也需要添加错误预测的数量，因此不能复制

206
00:14:30,000 --> 00:14:36,660
并取对应于第一类和第二类的错误预测的第一数量

207
00:14:36,660 --> 00:14:40,190
与第二类相对应的不正确操作的数量。

208
00:14:40,210 --> 00:14:46,320
因此，在这里，我们实际上采用了这个混淆矩阵的所有元素，即正确的数量

209
00:14:46,360 --> 00:14:49,110
动作加上错误预测的数量。

210
00:14:49,440 --> 00:14:54,870
因此，现在通过这一行代码，我们可以将准确性提高一倍。

211
00:14:54,930 --> 00:15:01,440
但是，由于我们正在使用此供应函数，因此将为所有

212
00:15:01,440 --> 00:15:06,690
10次​​测试跌落，因此我们将获得10个精度，并且我们将计算得出它的平均值，这将给我们

213
00:15:07,000 --> 00:15:13,410
与我们之前使用之前的方法获得的单个精度相比，相关精度要高得多。

214
00:15:13,470 --> 00:15:15,690
评估模型性能。

215
00:15:15,690 --> 00:15:22,850
好的，现在我们已经拥有了所有东西，但是我们只需要指定我们想要返回此精度即可

216
00:15:23,040 --> 00:15:28,380
因为这是一个函数，所以我们需要指定我们希望该函数返回的内容并执行此操作

217
00:15:28,380 --> 00:15:33,180
我们只添加返回括号和准确性。

218
00:15:33,180 --> 00:15:34,930
现在一切就绪。

219
00:15:34,980 --> 00:15:38,160
仔细的转换已得到很好的实施。

220
00:15:38,480 --> 00:15:44,250
好吧，现在我们准备好获得此10倍交叉验证所产生的10个准确度

221
00:15:44,250 --> 00:15:45,180
技术。

222
00:15:45,210 --> 00:15:52,210
因此，我们将选择从此处到顶部的所有内容，因为我们尚未导入数据集

223
00:15:52,290 --> 00:15:52,850
然而。

224
00:15:53,130 --> 00:15:57,360
因此，让我们让Presque美军进入以执行全部任务。

225
00:15:57,360 --> 00:15:58,100
开始了。

226
00:15:58,200 --> 00:16:01,720
一切都在不到一秒钟的时间内正确执行。

227
00:16:01,770 --> 00:16:02,840
太完美了。

228
00:16:03,000 --> 00:16:05,200
让我们看一下结果。

229
00:16:05,220 --> 00:16:07,860
所以首先让我们把它放下来。

230
00:16:07,860 --> 00:16:08,820
好吧。

231
00:16:08,820 --> 00:16:10,260
因此，在这里我们得到了所有结果。

232
00:16:10,260 --> 00:16:12,330
首先，数据集已导入。

233
00:16:12,400 --> 00:16:19,160
我们在此部分将其分为训练集和测试集，然后构建分类器

234
00:16:19,170 --> 00:16:21,460
这就是我们作为分类器的内核。

235
00:16:21,570 --> 00:16:30,080
当然，我们会得到我们的简历清单，这是我们通过仔细的交叉验证建立的，这就是阿维莱斯

236
00:16:30,150 --> 00:16:35,190
这是Caple转换产生的10个精度的列表。

237
00:16:35,410 --> 00:16:36,750
因此，让我们检查一下。

238
00:16:36,750 --> 00:16:39,310
让我们看一下这10个精度是什么。

239
00:16:39,540 --> 00:16:42,210
因此，我们将从控制台中进行查看。

240
00:16:42,320 --> 00:16:45,120
所以我在这里按Siri，然后按Enter。

241
00:16:45,510 --> 00:16:46,940
现在我们开始。

242
00:16:46,940 --> 00:16:48,450
那就是结果。

243
00:16:48,450 --> 00:16:50,010
那就是10个精度。

244
00:16:50,250 --> 00:16:58,740
如此完整，我们获得了93％的准确度，对于3 100％，准确率达到了87％，没有

245
00:16:58,770 --> 00:17:02,450
86％的完整预测错误5。

246
00:17:02,460 --> 00:17:12,150
96％在4：6上为90％90％7 93％和4 8 9％4 9并最终为83％

247
00:17:12,300 --> 00:17:13,300
全十。

248
00:17:13,470 --> 00:17:19,470
这样就清楚地说明了我告诉您的关于Varians问题的信息，当我们重新运行该问题时可能会发生

249
00:17:19,470 --> 00:17:25,500
多次使用该模型，因为实际上我们获得了不同的精度，有时甚至有很大的差异

250
00:17:25,560 --> 00:17:28,650
从一个领域到另一个领域的准确性。

251
00:17:28,650 --> 00:17:35,100
所以从这里到这里很好，但是例如从4 2 2 4 3那里我们得到13％的差异

252
00:17:35,400 --> 00:17:36,660
准确性。

253
00:17:36,840 --> 00:17:43,350
所以这就是为什么在一个分割上计算精度没有太大关系的原因，而它要重要得多。

254
00:17:43,350 --> 00:17:47,650
与计算10次拆分的准确性相关，因为这样我们就可以取平均值。

255
00:17:47,760 --> 00:17:50,030
这正是我们现在要做的。

256
00:17:50,030 --> 00:17:54,330
我们将在这里获得10个精度后计算平均值。

257
00:17:54,330 --> 00:17:58,600
所以要得到这个，我的意思是实际上很简单。

258
00:17:58,680 --> 00:18:01,980
我们将使用均值函数。

259
00:18:02,160 --> 00:18:09,090
因此，当我们当然输入CV时，请在此处及其中加上括号，因为CV是我们十种精度的列表

260
00:18:09,240 --> 00:18:10,500
我们在这里获得的。

261
00:18:10,500 --> 00:18:16,410
但是，只是为了确保我们获得十折的每一个的精度值，我们需要指定

262
00:18:16,410 --> 00:18:24,150
在此作为数字并在括号中，我们包括电视以确保我们取这些值的平均值

263
00:18:24,360 --> 00:18:32,220
这就是精确度，让我们将这些精确度的平均值放入一个将出现的变量中

264
00:18:32,280 --> 00:18:33,610
在这里的值。

265
00:18:33,690 --> 00:18:41,190
让我们简单地讲这些变量的准确性，因为这些精确度的均值只是最终的

266
00:18:41,310 --> 00:18:42,730
相关的准确性。

267
00:18:42,840 --> 00:18:48,240
因此，准确性是指民事清单中的准确性。

268
00:18:48,240 --> 00:18:56,970
好吧，让我们计算一下，我们将得出91％的准确度，这与

269
00:18:57,030 --> 00:18:58,030
准确性。

270
00:18:58,030 --> 00:18:59,150
我们正在寻找。

271
00:18:59,520 --> 00:19:08,110
因此，总的来说，我们可以更可信地说，我们将作为分类器的内核建模具有出色的性能。

272
00:19:08,160 --> 00:19:09,160
因此，这非常好。

273
00:19:09,240 --> 00:19:14,700
现在，恭喜您，您有了更高级的方法来评估模型性能和

274
00:19:14,700 --> 00:19:20,010
设计科学的目标是您将在下一个Statoil中看到的内容，我们将看到一种非常强大的技术，

275
00:19:20,010 --> 00:19:24,910
将帮助我们选择我们构建的任何机器学习模型的最佳超参数。

276
00:19:25,140 --> 00:19:27,640
因此，我期待在下一个Statoil中做到这一点。

277
00:19:27,660 --> 00:19:29,430
在此之前，请尽情学习。

