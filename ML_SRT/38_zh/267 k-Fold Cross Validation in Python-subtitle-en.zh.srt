1
00:00:00,300 --> 00:00:05,730
您好，欢迎使用此Python教程，也欢迎进行部分内容和道德选择与提升。

2
00:00:05,730 --> 00:00:07,600
因此，在这一部分中，我们将做两件事。

3
00:00:07,620 --> 00:00:13,410
首先评估我们的模型性能，然后改善我们的模型性能。

4
00:00:13,420 --> 00:00:17,850
然后将有一个关于机器学习中最强大的算法之一的奖励部分

5
00:00:18,150 --> 00:00:22,200
它变得越来越流行，这被称为前酋长。

6
00:00:22,200 --> 00:00:27,120
但是首先，我们希望能够改善我们拥有的所有机器学习模型的模型性能

7
00:00:27,120 --> 00:00:32,940
可以使用称为模型选择的技术来完成本课程的学习并提高模型性能

8
00:00:33,210 --> 00:00:38,880
包括选择最适合您机器学习的最佳参数，因为您知道记住

9
00:00:39,120 --> 00:00:43,730
每次我们建立机器学习模型时，我们都有两种类型的参数。

10
00:00:43,740 --> 00:00:48,600
模型学习的参数的第一种类型是已更改的参数，

11
00:00:48,600 --> 00:00:54,450
通过运行模型找到最佳值，然后第二种参数是参数

12
00:00:54,450 --> 00:00:56,160
我们选择了自己。

13
00:00:56,160 --> 00:01:02,130
例如，我们建模时内核中的内核参数，这些参数称为超级

14
00:01:02,130 --> 00:01:03,180
参数。

15
00:01:03,180 --> 00:01:08,310
因此，仍有改进模型的空间，因为我们仍然可以为这些模型选择一些最佳值

16
00:01:08,310 --> 00:01:09,190
参数。

17
00:01:09,360 --> 00:01:14,610
但是由于这些参数是模型学习的另一个参数，所以我们需要找出另一个

18
00:01:14,610 --> 00:01:19,800
为混合参数选择这些参数的最佳值的方法。

19
00:01:19,890 --> 00:01:24,570
这是我们在第10部分中将要做的强大功能之一，它将通过非常有效的方式

20
00:01:24,570 --> 00:01:26,820
这种技术称为网格搜索。

21
00:01:26,820 --> 00:01:32,970
但是在开始网格搜索之前，我们需要优化一种评估模型的方法，因为到目前为止

22
00:01:32,970 --> 00:01:36,940
我们所做的就是在训练集和测试集之间划分数据集。

23
00:01:37,050 --> 00:01:42,360
您知道我们在训练集上训练了我们的模型，并在测试中测试了其性能。

24
00:01:42,390 --> 00:01:45,610
这是评估模型性能的正确方法。

25
00:01:45,690 --> 00:01:49,410
但这不是最好的方法，因为我们实际上有一个方差问题。

26
00:01:49,530 --> 00:01:54,490
方差问题可以通过以下事实来解释：当我们获得测试集的准确性时。

27
00:01:54,720 --> 00:01:59,250
好吧，如果我们再次运行模型并再次测试，则它是另一个测试集的性能。

28
00:01:59,430 --> 00:02:06,600
好吧，我们可以获得非常不同的精度，因此仅根据一种精度来判断我们的模型性能

29
00:02:06,600 --> 00:02:09,090
测试集实际上不是超级相关的。

30
00:02:09,090 --> 00:02:12,870
这不是评估模型性能的最相关方法。

31
00:02:13,110 --> 00:02:18,750
因此，有一种称为K4交叉验证的技术对此进行了很大的改进，因为这会

32
00:02:18,750 --> 00:02:25,910
解决这个方差问题，以及如何解决它，它将训练集旋转成十倍来解决

33
00:02:26,180 --> 00:02:27,140
蛋糕什么时候站立。

34
00:02:27,150 --> 00:02:29,140
而且大多数时候蛋糕都会站起来。

35
00:02:29,370 --> 00:02:34,090
然后将模型训练九倍，然后在最后一只脚上进行测试。

36
00:02:34,320 --> 00:02:39,940
由于有10次跌倒，我们可以制作9个四分之一的10种不同组合来尝试建模和

37
00:02:39,940 --> 00:02:41,140
为了测试它。

38
00:02:41,190 --> 00:02:46,680
这意味着我们可以训练模型并通过训练和测试集的十种组合对它们进行全部测试

39
00:02:47,120 --> 00:02:51,840
这将使我们对模型的性能有了更好的了解，因为我们可以做的是

40
00:02:51,840 --> 00:02:57,720
两个词是最多十次评估的不同准确度的平均值，并计算标准

41
00:02:57,720 --> 00:03:00,160
看一下方差。

42
00:03:00,300 --> 00:03:05,910
因此，最终我们的分析将更加相关，此外，我们还将了解这四个中的哪一个

43
00:03:05,910 --> 00:03:11,400
类别是因为如果我们获得较高的准确度，并且较小的方差将位于左下方

44
00:03:11,400 --> 00:03:17,400
如果我们获得较大的准确度和较高的方差，那么如果我们获得较小的准确度，我们将位于右下方

45
00:03:17,400 --> 00:03:19,140
低方差的精度。

46
00:03:19,170 --> 00:03:23,970
我们将位于左上方，最终，如果我们获得较低的准确性和较高的方差，我们将

47
00:03:23,970 --> 00:03:25,280
在正确的位置。

48
00:03:25,530 --> 00:03:28,700
因此，这种仔细的交叉验证非常有用。

49
00:03:28,740 --> 00:03:32,610
除此以外，我们的绩效分析也更重要。

50
00:03:32,640 --> 00:03:36,150
因此，让我们从此K4验证开始。

51
00:03:36,210 --> 00:03:38,670
我们第一个道德选择技术。

52
00:03:38,670 --> 00:03:42,680
因此，由于我们已经建立了许多道德规范，因此我们不会再建立另一个道德规范。

53
00:03:42,680 --> 00:03:47,800
我们将使用我们构建的模型之一，并在模型上谨慎使用Nation。

54
00:03:47,880 --> 00:03:53,720
因此，我们要使用的模型是该内核，即V.M。 我们在第三部分进行了分类

55
00:03:53,760 --> 00:03:58,860
记住，我们用来预测客户是否会点击社交网络上的广告

56
00:03:59,130 --> 00:04:01,170
购买是或否的SUV。

57
00:04:01,380 --> 00:04:04,500
这样就已经建立了模型，我们已经拥有了一切。

58
00:04:04,500 --> 00:04:12,000
所以我们要做的是获取整个模型，然后在其中添加一个新的部分代码

59
00:04:12,000 --> 00:04:19,270
当然，这将是实现K4交叉验证的部分代码。

60
00:04:19,290 --> 00:04:27,010
所以在我们开始做之前，让我们选择正确的Fuller作为工作目录，以便我们探索机械。

61
00:04:27,060 --> 00:04:29,610
本课程的最后部分。

62
00:04:29,610 --> 00:04:36,480
恭喜您达到了这一目标，并进行了更多的选择和增强以及第48节的模型选择。

63
00:04:36,480 --> 00:04:36,840
好吧。

64
00:04:36,840 --> 00:04:42,060
确保在备案时拥有社交网络，如果是这样的话，就可以开始使用了。

65
00:04:42,060 --> 00:04:45,990
好的，现在我们在哪里应用K4严格的Deshaun代码部分。

66
00:04:46,110 --> 00:04:52,350
好吧，因为这包括对它们的所有性能进行评估，所以可以说是最相关的位置

67
00:04:52,620 --> 00:04:58,050
在将内核构建为模型之后，就正确了，然后我们构建了模型。

68
00:04:58,240 --> 00:05:04,730
实际上，在这段代码中，您可以预测测试结果和转换矩阵

69
00:05:04,750 --> 00:05:07,590
实际上是评估模型的Fris方法。

70
00:05:07,710 --> 00:05:13,270
但是正如我在本教程开始时所说的那样，这是评估模型的正确方法，但不是

71
00:05:13,270 --> 00:05:14,140
最好的。

72
00:05:14,140 --> 00:05:18,890
在今天的Statoil中，我们正在引入一种更好的方法来评估我们的模型。

73
00:05:19,000 --> 00:05:25,660
因此，让我们将其放在本节之后，作为更高级的性能评估方法。

74
00:05:25,660 --> 00:05:33,390
因此，我们将其称为申请交叉验证的部分。

75
00:05:33,400 --> 00:05:33,750
好吧。

76
00:05:33,770 --> 00:05:35,020
现在开始。

77
00:05:35,230 --> 00:05:40,930
因此，第一件事当然是为工作导入正确的类，更确切地说是为功能导入

78
00:05:41,170 --> 00:05:46,960
这个功能称为交叉阀核心，是从选型模块中导入的

79
00:05:46,960 --> 00:05:53,410
与我们在此处用于导入经过测试的功能以将数据集散布到其中的模块相同

80
00:05:53,410 --> 00:05:55,400
训练集和数据集。

81
00:05:55,420 --> 00:05:56,590
所以是一样的。

82
00:05:56,710 --> 00:06:00,090
因此，让我们导入十字弓得分功能。

83
00:06:00,100 --> 00:06:05,880
因此从规模上学习道德选择。

84
00:06:05,880 --> 00:06:07,090
开始了。

85
00:06:07,120 --> 00:06:09,620
进口药品。

86
00:06:10,110 --> 00:06:12,490
哇得分。

87
00:06:12,610 --> 00:06:13,390
好吧。

88
00:06:13,540 --> 00:06:14,340
完成了

89
00:06:14,500 --> 00:06:18,210
因此，现在让我们在训练集上应用K4音译。

90
00:06:18,220 --> 00:06:21,370
因此，在应用它之前，我们需要了解它会在哪里返回。

91
00:06:21,480 --> 00:06:27,730
那么它实际上将为将要创建的10个组合中的每一个返回10个精度

92
00:06:27,730 --> 00:06:29,560
通过仔细考虑。

93
00:06:29,590 --> 00:06:35,370
所以您知道，因为每种组合都由九种折叠组成，以训练模型并进行一次全面测试

94
00:06:35,710 --> 00:06:39,970
好吧，我之前说过，我们将得到10个组合，因此得到10个精度。

95
00:06:40,090 --> 00:06:46,240
所以要做的第一件事就是定义一个向量，我们将其称为准确性的向量

96
00:06:46,240 --> 00:06:53,290
是将通过创建的10个组合计算出的10个精度的向量

97
00:06:53,290 --> 00:06:55,170
通过仔细的CAUSLEY Deshaun。

98
00:06:55,180 --> 00:07:00,990
因此最终，此精度的向量将由10个元素组成，而这10个元素将为10

99
00:07:01,000 --> 00:07:03,800
准确性评估我们的模型。

100
00:07:04,240 --> 00:07:10,290
好吧，现在我们要做的是使用这种称为功能的Krust阀进行仔细的演示

101
00:07:10,300 --> 00:07:11,480
非常有效。

102
00:07:11,680 --> 00:07:19,480
因此，先跨瓣膜评分，然后再加上括号，然后再输入不同的参数。

103
00:07:19,480 --> 00:07:21,330
因此，让我们看看这些参数是什么。

104
00:07:21,400 --> 00:07:26,680
我将在此处发表评论以检查此跨核心功能。

105
00:07:26,680 --> 00:07:29,290
因此，让我们看看第一个参数是estimator。

106
00:07:29,440 --> 00:07:30,730
这就是您的模型。

107
00:07:30,730 --> 00:07:32,200
那是你的分类器。

108
00:07:32,500 --> 00:07:34,560
以及我们如何称呼测试火。

109
00:07:34,600 --> 00:07:36,420
我们称该分类器。

110
00:07:36,580 --> 00:07:43,130
因此，这里有一些分类的输入估计量。

111
00:07:43,250 --> 00:07:44,060
好吧。

112
00:07:44,060 --> 00:07:47,500
因此，第一个参数是我们的估算器分类器。

113
00:07:47,510 --> 00:07:51,930
然后第二个参数是x要拟合的数据。

114
00:07:52,190 --> 00:07:56,550
由于K4音译应用于训练集，因此实际上就是训练集。

115
00:07:56,690 --> 00:07:59,700
但这是训练集的特征矩阵。

116
00:07:59,750 --> 00:08:06,420
因此X将是极值，因为我们的火车是由特征矩阵中的多余元素组成的。

117
00:08:06,650 --> 00:08:09,310
以及为什么训练因变量矢量。

118
00:08:09,320 --> 00:08:14,810
因此，这里我们加X等于多余。

119
00:08:14,960 --> 00:08:15,950
好吧。

120
00:08:16,080 --> 00:08:22,170
现在，您可能已经猜到的下一个参数是为什么以及为什么当然是因变量矢量

121
00:08:22,500 --> 00:08:28,260
如您所见，尾随集被认为是要在这种情况下进行预测的目标变量

122
00:08:28,260 --> 00:08:29,510
监督学习。

123
00:08:29,730 --> 00:08:33,740
而且那仍然与火车课程相对应，这就是为什么要火车。

124
00:08:33,780 --> 00:08:34,700
所以我们在这里。

125
00:08:34,780 --> 00:08:35,120
为什么。

126
00:08:35,120 --> 00:08:38,440
因为为什么要火车。

127
00:08:38,530 --> 00:08:39,490
好吧。

128
00:08:39,570 --> 00:08:43,120
现在下一个参数下一个参数是组。

129
00:08:43,140 --> 00:08:44,990
但这实际上并不重要。

130
00:08:45,000 --> 00:08:47,080
同样，得分最高。

131
00:08:47,200 --> 00:08:54,060
我们最感兴趣的是此CV参数，因为CV参数实际上是数字

132
00:08:54,060 --> 00:08:57,130
您想要将火车组拆分为一组的傻瓜。

133
00:08:57,480 --> 00:09:00,970
这个简历编号最常见的选择是10。

134
00:09:01,020 --> 00:09:05,800
在大多数情况下，您将使用10:04交叉验证，因为10:04交叉验证意味着您将

135
00:09:05,820 --> 00:09:12,970
获得10个精度和10个精度实际上足以获得模型性能的相关信息。

136
00:09:12,990 --> 00:09:22,350
因此，在这里我们将CV等于10完美，这实际上是我们要在此处执行高效操作所需的全部

137
00:09:22,350 --> 00:09:24,210
仔细的交叉验证。

138
00:09:24,210 --> 00:09:30,300
如果要处理非常大的数据集，可以添加此最终作业参数并设置

139
00:09:30,300 --> 00:09:36,330
它的值为负1，因为负1表示您将使用计算机上的所有C-p用法，因此

140
00:09:36,330 --> 00:09:38,940
您的交叉分配将更快地运行。

141
00:09:39,150 --> 00:09:43,120
但这很好，本教程的重点不是在大型数据集上工作。

142
00:09:43,200 --> 00:09:46,980
而是要学习如何进行仔细的合并。

143
00:09:47,130 --> 00:09:54,590
因此，我们准备好获得10个精度，因此我们将对模型性能有一个更好的了解。

144
00:09:54,780 --> 00:10:02,850
因此，让我们选择从此处到顶部的所有代码行，它将运行预处理

145
00:10:02,850 --> 00:10:06,550
将内核作为模型拟合到训练集。

146
00:10:06,590 --> 00:10:09,070
创建一个导致混淆矩阵的测试。

147
00:10:09,090 --> 00:10:14,970
这是第一种绩效评估方法，并且还有更高级的绩效评估

148
00:10:14,970 --> 00:10:15,540
方法。

149
00:10:15,690 --> 00:10:17,180
K用于运输。

150
00:10:17,190 --> 00:10:21,660
更准确地说，是10:04整合，让我们看看会得到什么。

151
00:10:21,750 --> 00:10:24,770
因此，让我们按Command Control按Enter执行。

152
00:10:24,780 --> 00:10:25,760
开始了。

153
00:10:25,800 --> 00:10:30,420
我们只是有一个数据转换警告，因为一些整数已转换为浮点数。

154
00:10:30,540 --> 00:10:31,700
那也行。

155
00:10:31,710 --> 00:10:38,270
现在让我们看一下精度的向量和变量探索，这里就是精度的。

156
00:10:38,360 --> 00:10:44,630
如果打开它，我们将获得支架展示过程的10个准确性。

157
00:10:44,690 --> 00:10:46,090
所以我们在这里看到了什么。

158
00:10:46,160 --> 00:10:51,860
我们可以看到这样做的相关性，因为第一个精度为80％，然后第二个精度

159
00:10:51,860 --> 00:10:58,810
准确度是96％，然后是80％，然后是93％，86％和83％。

160
00:10:58,970 --> 00:11:03,560
这样就清楚地表明了我在一开始告诉您的全部信息，即您进行测试时

161
00:11:03,560 --> 00:11:06,020
一个测试集上模型的性能。

162
00:11:06,200 --> 00:11:11,810
好吧，您可以获得准确性，但是当您在另一个测试集上再次对其进行测试时，您会得到非常不同的结果

163
00:11:11,870 --> 00:11:13,010
准确性。

164
00:11:13,040 --> 00:11:17,670
因此，评估一个测试集的道德表现不是很相关。

165
00:11:17,870 --> 00:11:24,410
现在，通过K4交叉验证，我们正在10个测试集上对其进行测试，因此我们将获得并因此

166
00:11:24,410 --> 00:11:29,390
不是我们要做的是取所有这10个精度的平均值，这将给我们带来很多好处

167
00:11:29,390 --> 00:11:33,290
更好地了解我们模型的平均道德表现。

168
00:11:33,350 --> 00:11:39,290
这样就可以了，让我们得到这个平均值，实际上很简单。

169
00:11:39,290 --> 00:11:42,220
我们只需要说我们的准确性是向量。

170
00:11:42,230 --> 00:11:43,100
开始了。

171
00:11:43,190 --> 00:11:51,440
然后只添加一个点，然后添加均值函数，就是运行它会给我们

172
00:11:51,440 --> 00:11:56,380
此精度向量的10个精度的平均值。

173
00:11:56,420 --> 00:11:58,850
因此，我们得到了90％。

174
00:11:58,850 --> 00:12:03,750
这意味着这10个精度的平均值实际上是90％。

175
00:12:03,860 --> 00:12:11,490
因此，总的来说，这90％的准确性是对我们模型性能的相关评估。

176
00:12:11,510 --> 00:12:13,460
不是百分之八十。

177
00:12:13,460 --> 00:12:15,770
它也不是96％。

178
00:12:15,770 --> 00:12:20,070
至少是10次模型评估的平均值。

179
00:12:20,090 --> 00:12:22,760
准确性是如此完美。

180
00:12:22,760 --> 00:12:28,700
如果我们想进一步分析，我们可以做的是计算

181
00:12:28,700 --> 00:12:33,800
此精度的向量将告诉我们方差是高还是低。

182
00:12:33,830 --> 00:12:39,800
所以这也非常有趣，为此，我们要做的就是对精度向量进行处理，然后

183
00:12:39,800 --> 00:12:47,150
添加一个点，然后使用SDD函数，该函数将为我们提供此精度的标准偏差

184
00:12:47,150 --> 00:12:48,050
向量。

185
00:12:48,050 --> 00:12:50,010
所以我们开始。

186
00:12:50,450 --> 00:12:54,840
让我们运行它，我们得到6％的标准偏差。

187
00:12:54,860 --> 00:12:56,120
那是什么意思。

188
00:12:56,150 --> 00:13:00,950
这就是说，当

189
00:13:00,950 --> 00:13:07,840
评估我们的模型性能，平均准确率为90％就是6％。

190
00:13:07,880 --> 00:13:10,010
因此，实际上差异不是太大。

191
00:13:10,070 --> 00:13:14,930
可以，因为这意味着当我们评估自己的最佳表现时，大部分时间

192
00:13:14,930 --> 00:13:22,450
大约在84％和96％之间，因此最终这意味着我们处于这种低偏见且无差异

193
00:13:22,450 --> 00:13:23,220
类别。

194
00:13:24,180 --> 00:13:25,200
因此，这非常好。

195
00:13:25,270 --> 00:13:30,750
现在，恭喜您，您有了更高级的方法来评估模型性能

196
00:13:30,750 --> 00:13:36,060
您将在接下来的一个小时内看到的数据科学目标将看到一种非常强大的技术，

197
00:13:36,060 --> 00:13:41,180
将帮助我们选择所构建的任何机器或模型的最佳超参数。

198
00:13:41,190 --> 00:13:43,630
因此，我期待在下一个工作中做到这一点。

199
00:13:43,710 --> 00:13:45,470
直到那时我才真正开始学习。

