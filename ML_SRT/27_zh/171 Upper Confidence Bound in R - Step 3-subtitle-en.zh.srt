1
00:00:00,330 --> 00:00:02,570
您好，欢迎来到本美术教程。

2
00:00:02,730 --> 00:00:07,900
因此，让我们从中断的地方开始，我们尝试找出为什么使用此上限

3
00:00:07,900 --> 00:00:14,240
在此向此上限变量赋予400的幂的十分大的10的结果

4
00:00:14,340 --> 00:00:15,380
埃勒的病情。

5
00:00:15,570 --> 00:00:16,910
好吧，让我们看看会发生什么。

6
00:00:16,990 --> 00:00:19,820
您知道让我们看看第一轮比赛会发生什么。

7
00:00:20,010 --> 00:00:25,500
第一个回合之一，我们将在这里循环进行10个版本的添加操作。

8
00:00:25,680 --> 00:00:28,920
自第一轮以来，没有选择任何ADD。

9
00:00:29,130 --> 00:00:37,470
那么这里的这种情况如果选择数I大于零将永远不会成立，因此

10
00:00:37,580 --> 00:00:40,420
我们将直接在这里转到其他位置。

11
00:00:40,740 --> 00:00:46,590
因此，在400的幂处，上限将设置为等于10。

12
00:00:46,590 --> 00:00:50,980
然后我们继续这种情况，因为这是此故障的下一步。

13
00:00:51,150 --> 00:00:56,780
它说如果上限大于最大反弹，那当然是正确的，因为

14
00:00:56,840 --> 00:00:59,680
400和Maxo的功效中的10，我们将为零。

15
00:00:59,730 --> 00:01:01,170
所以这个条件是真的。

16
00:01:01,290 --> 00:01:05,220
因此，接下来发生的事情是Max supervillian等于上限。

17
00:01:05,250 --> 00:01:11,000
因此，最大前禁令将以400的幂等于10，并等于。

18
00:01:11,370 --> 00:01:14,810
因此，由于我们处在首屏位置，因此我等于1。

19
00:01:14,880 --> 00:01:16,770
所以我等于1。

20
00:01:16,920 --> 00:01:23,730
然后发生什么，然后我们进行下一步，因为我在这里循环，即我等于2并且

21
00:01:23,970 --> 00:01:28,370
对第二个广告做出响应，并且尚未选择第二个广告。

22
00:01:28,380 --> 00:01:33,060
因此，我听到的选择数量不会大于零。

23
00:01:33,090 --> 00:01:34,920
因此，这里的条件将不成立。

24
00:01:35,040 --> 00:01:37,460
因此，我们再次在这里解决这个问题。

25
00:01:37,740 --> 00:01:41,070
因此，Appelbaum等于400的幂。

26
00:01:41,370 --> 00:01:43,350
然后，如果在这里，请转到此。

27
00:01:43,350 --> 00:01:48,470
现在，让我们看一下该条件是否为真，上限为400的幂时等于10。

28
00:01:48,690 --> 00:01:54,840
并记得上一轮的最大上限是400的幂等于10

29
00:01:54,840 --> 00:01:56,740
据说等于上限。

30
00:01:57,000 --> 00:02:04,160
因此，此条件实际转换为400的幂中的10大于该幂时的10

31
00:02:04,160 --> 00:02:05,010
400。

32
00:02:05,190 --> 00:02:06,450
那是不对的。

33
00:02:06,510 --> 00:02:10,360
十的幂400不大于十的幂400。

34
00:02:10,530 --> 00:02:17,970
因此该条件不成立，因此add的值不等于2，因为现在等于2。

35
00:02:18,210 --> 00:02:20,030
但是它仍然等于1。

36
00:02:20,200 --> 00:02:26,170
这就是为什么在第一轮将要选择的广告等于1的原因。

37
00:02:26,250 --> 00:02:29,830
那是您可以尝试其他值的第一个。

38
00:02:29,880 --> 00:02:35,790
我听说预禁令将始终等于10，否则幂400和最大上限将保持等于

39
00:02:35,790 --> 00:02:37,240
电源400的10。

40
00:02:37,380 --> 00:02:41,470
因此，对于此处剩余的九个，永远不会验证此条件。

41
00:02:41,580 --> 00:02:47,990
因此，我们将其保持等于1，这是下一轮最多10次的相同原理，即

42
00:02:48,000 --> 00:02:54,330
一轮，他进入这个选择的数目，我听到的只有第一个和第二个会大于零

43
00:02:54,540 --> 00:02:59,670
因为第一个广告是在第1轮中选择的，因此该条件仅对

44
00:02:59,670 --> 00:03:00,440
第一。

45
00:03:00,690 --> 00:03:05,340
因此上限将等于此平均奖励加我听到的差额。

46
00:03:05,370 --> 00:03:09,910
但是接下来我们将继续我加一个对应于adversion 2的数字。

47
00:03:10,110 --> 00:03:17,120
而且由于尚未很好地选择广告2，因此我听到的这个选择数等于零

48
00:03:17,370 --> 00:03:21,230
因此不会验证此条件，因此我们将继续进行。

49
00:03:21,240 --> 00:03:25,700
否则，在400的幂处，上限将等于10。

50
00:03:25,800 --> 00:03:30,710
我们将忘记在此之前的眼睛计算出的该上限值。

51
00:03:30,810 --> 00:03:35,310
因此，接下来发生的情况是，相同的上Belang大于maksud反弹，因为

52
00:03:35,420 --> 00:03:40,170
Mac被认为等于先前AI的上限和先前AI的上限

53
00:03:40,230 --> 00:03:46,450
我的平均奖励是Plus Delta II，它当然比标准功率低400。

54
00:03:46,500 --> 00:03:51,840
这就是为什么我们这么说它是为了在这里有这个上限

55
00:03:52,080 --> 00:03:58,740
低于中心的400的幂，因此Maxo preven将以400的幂为10，我们

56
00:03:58,740 --> 00:04:00,390
将选择相等。

57
00:04:00,420 --> 00:04:06,590
那是第二，然后是和以前一样的原理，那是我们继续往下看的上限

58
00:04:06,630 --> 00:04:12,430
将等于10或400的幂或最大禁令也将等于400的10的幂。

59
00:04:12,570 --> 00:04:17,850
因此，这种情况不会得到验证，因此我们将保持第二。

60
00:04:17,850 --> 00:04:23,490
这就是为什么这里的这个小技巧对我们来说效果很好，并能为我们提供想要的东西。

61
00:04:23,490 --> 00:04:29,760
好吧，所以第一个10个回合中选择了10个相加，然后在大约10个后，我们使用该策略来选择

62
00:04:29,760 --> 00:04:30,830
添加。

63
00:04:30,840 --> 00:04:38,100
好吧，现在我们要做的唯一一件事就是在此处附加选中的内容

64
00:04:38,100 --> 00:04:38,900
向量在这里。

65
00:04:39,060 --> 00:04:40,840
而这正是我们现在要做的。

66
00:04:40,950 --> 00:04:42,390
因此，让我们开始吧。

67
00:04:42,390 --> 00:04:46,580
我们只需要退出for循环，因为我们已经完成了该循环。

68
00:04:46,590 --> 00:04:50,220
我们所做的正是选择正确的添加。

69
00:04:50,460 --> 00:04:56,760
现在我们需要退出循环，但仍要保持循环，因为我们仍处于

70
00:04:56,760 --> 00:04:57,520
具体路线。

71
00:04:57,550 --> 00:05:04,730
而且，我们现在要做的是在这个巨大的向量中选中一个乐队

72
00:05:05,060 --> 00:05:08,550
包含在每个回合中选择的所有不同广告。

73
00:05:08,780 --> 00:05:09,080
好。

74
00:05:09,080 --> 00:05:11,330
所以现在事情很简单。

75
00:05:11,390 --> 00:05:18,650
我们只需要对这些选定的巨大矢量广告然后使用一支笔使用附加功能。

76
00:05:18,650 --> 00:05:19,580
这里是。

77
00:05:19,880 --> 00:05:20,900
好吧。

78
00:05:20,900 --> 00:05:28,430
现在，在此附加函数中，我们将选择的第一个输入和第二个输入添加作为输入，因为

79
00:05:28,430 --> 00:05:33,490
它对应于此处在此for循环中选择的广告的索引。

80
00:05:33,500 --> 00:05:36,510
好的，在附上。

81
00:05:36,680 --> 00:05:43,280
现在，由于我们刚刚选择并在此处添加，我们需要做的就是更新此向量编号

82
00:05:43,280 --> 00:05:44,490
这里的选择。

83
00:05:44,570 --> 00:05:49,310
那就是您知道向量告诉每个加法器被选择的次数。

84
00:05:49,310 --> 00:05:56,070
因此，由于在这里我们知道刚选择专辑的哪个索引，我们需要做的就是添加一个加号。

85
00:05:56,090 --> 00:06:01,300
在这些选择向量数目的特定索引中，以更新该向量。

86
00:06:01,310 --> 00:06:02,660
所以现在就开始吧。

87
00:06:02,660 --> 00:06:09,500
我们当然会留在此for end循环中，因为此向量将包含每个循环的次数

88
00:06:09,590 --> 00:06:11,750
在此特定运行中选择了添加。

89
00:06:11,780 --> 00:06:18,410
因此，我们需要保持循环状态，我们将在这里简单地采用此向量。

90
00:06:18,410 --> 00:06:22,280
复制并粘贴到此处进行更新。

91
00:06:22,280 --> 00:06:29,880
因此，到目前为止，我们需要的是此选择向量数量的ADD索引，因为此加法

92
00:06:29,930 --> 00:06:35,540
index对应于刚刚在此处选择的广告的索引，该选择基于所有

93
00:06:35,540 --> 00:06:36,550
策略。

94
00:06:36,830 --> 00:06:42,090
因此，我们只需要做的就是在此向量上增加一个。

95
00:06:42,110 --> 00:06:44,810
因此，我们将再次复制。

96
00:06:45,020 --> 00:06:47,940
复制等于粘贴。

97
00:06:47,990 --> 00:06:50,330
然后再加一点。

98
00:06:50,330 --> 00:06:50,910
好吧。

99
00:06:51,020 --> 00:06:55,100
因此，现在已经很好地更新了选择向量的数量。

100
00:06:55,310 --> 00:07:00,230
这就是我们在此特定回合上需要针对此向量执行的所有操作，因为当然只有一个广告

101
00:07:00,230 --> 00:07:01,130
已选择。

102
00:07:01,600 --> 00:07:07,580
好，现在我们需要照顾好奖励，因为实际上我们这里有这些奖励向量

103
00:07:07,910 --> 00:07:13,910
我们需要更新，因为此向量包含10个中的每个向量的不同总和

104
00:07:14,000 --> 00:07:16,160
在每一轮增加。

105
00:07:16,160 --> 00:07:17,850
因此，我们需要对其进行更新。

106
00:07:17,960 --> 00:07:23,450
当然，此后，我们希望得到总数，我们希望该单位是一个包含以下内容的变量

107
00:07:23,630 --> 00:07:28,520
我们在各回合中积累的独特奖励总和。

108
00:07:28,520 --> 00:07:30,450
因此，让我们首先照顾一下。

109
00:07:30,470 --> 00:07:34,720
你们中有些人想来这里，然后我们会照顾您想要的全部。

110
00:07:34,760 --> 00:07:37,460
因此，今天有些词在这里。

111
00:07:37,550 --> 00:07:42,700
我们现在需要获得的是在此特定回合中获得的奖励。

112
00:07:42,740 --> 00:07:49,000
而且，因为您知道我们刚刚在这里选择了此广告，但还没有得到。

113
00:07:49,100 --> 00:07:52,500
我们刚刚选择了广告，因此现在我们需要获得奖励。

114
00:07:52,520 --> 00:07:58,430
因此，在现实生活中，发生的事情是您知道我们向用户展示了广告，然后用户点击了

115
00:07:58,430 --> 00:07:59,890
是或否在广告上。

116
00:08:00,200 --> 00:08:06,090
但是在这里，我们并不像我希望向您展示的真实实验那样真实。

117
00:08:06,140 --> 00:08:09,170
现在，在您眼前这不是那么简单。

118
00:08:09,200 --> 00:08:16,820
但是我们有这个模拟数据集，您知道这里的数据集包含真实结果

119
00:08:16,880 --> 00:08:22,260
您只能知道上帝，因为我们不知道每个用户都会点击哪个。

120
00:08:22,370 --> 00:08:28,470
提醒一下，第一个用户在5点和9点单击一个，而不是其余部分。

121
00:08:28,520 --> 00:08:31,150
因此，这只是一个模拟数据集。

122
00:08:31,160 --> 00:08:36,540
因此，我们现在要做的是根据所选的广告在每一轮中获得奖励。

123
00:08:36,650 --> 00:08:38,320
感谢这个数据集。

124
00:08:38,330 --> 00:08:47,180
因此，让我们去做，它会做的只是在此特定回合中得到1或0的单词，然后

125
00:08:47,180 --> 00:08:48,300
我们在哪里。

126
00:08:48,320 --> 00:08:54,980
因此，要做到这一点，我们要做的非常简单，那就是您知道我们的数据集并放在方括号中

127
00:08:54,980 --> 00:08:58,850
将需要指定我们所在行的索引。

128
00:08:58,850 --> 00:09:03,250
您知道哪个回合，并且与我们当前所在的回合相对应。

129
00:09:03,350 --> 00:09:08,180
因此，由于此数据集的所有行都不过是回合。

130
00:09:08,330 --> 00:09:10,330
好吧，第一个指数将是回合。

131
00:09:10,370 --> 00:09:12,850
例如，假设我们在第9轮。

132
00:09:12,950 --> 00:09:18,980
好吧，我们将需要获取数据集的行索引9，然后再获取列，因为列

133
00:09:18,980 --> 00:09:22,370
这里对应于10个不同广告的奖励。

134
00:09:22,580 --> 00:09:27,980
好吧，我们需要获取所选广告的索引，仅此而已，

135
00:09:28,100 --> 00:09:32,390
在这里建立索引，这就是我们要做的想法。

136
00:09:32,500 --> 00:09:36,520
但是，当然，在现实生活中，您将真正了解用户的情况。

137
00:09:36,520 --> 00:09:41,960
因此，我将结束本次演讲，现在我将全面获得真正的回报。

138
00:09:41,980 --> 00:09:46,420
这就是我们在这里选择此广告索引所得到的。

139
00:09:46,420 --> 00:09:47,620
因此，让我们开始吧。

140
00:09:47,620 --> 00:09:51,080
我们将这种真正的奖励简称为奖励。

141
00:09:51,100 --> 00:09:51,820
好吧。

142
00:09:51,870 --> 00:09:56,860
现在，正如我刚刚解释的那样，我们需要获取数据集，然后获取括号，然后获取

143
00:09:56,860 --> 00:09:59,160
对应于周围的线的索引。

144
00:09:59,200 --> 00:10:04,990
如此反复，我们需要获取与索引对应的列的索引

145
00:10:04,990 --> 00:10:06,710
刚刚选择的广告。

146
00:10:06,820 --> 00:10:09,280
所以就在这里，仅此而已。

147
00:10:09,370 --> 00:10:11,350
我们只是获得奖励。

148
00:10:11,350 --> 00:10:15,220
并为此使用此广告的特定选择。

149
00:10:15,390 --> 00:10:15,980
好。

150
00:10:16,000 --> 00:10:16,900
很好。

151
00:10:16,960 --> 00:10:23,320
我们刚刚获得了真正的奖励，现在我们可以在这里更新此奖励向量，以提醒您

152
00:10:23,320 --> 00:10:27,510
给每个末端的10个广告中的每个儿子奖励。

153
00:10:27,820 --> 00:10:36,340
因此，我们将获得此副本，然后在下面将增加此向量。

154
00:10:36,470 --> 00:10:42,430
当然，我们需要对该向量进行加法索引，因为仅选择了ADD

155
00:10:42,430 --> 00:10:43,450
在这个特定的回合。

156
00:10:43,480 --> 00:10:46,530
我们将更改其中的一些单词。

157
00:10:46,570 --> 00:10:52,060
因此，这只是我们需要更新的一些单词，因此我们需要做的就是增加

158
00:10:52,360 --> 00:10:58,770
当然，由于奖励是0或1，因此我们不仅仅通过奖励来通过词语。

159
00:10:58,980 --> 00:11:05,740
因此在这里等于等于，然后我们再进行一次再加上奖励。

160
00:11:06,130 --> 00:11:12,070
因此，如果我们将奖励设为零，则此特定添加项的奖励总和不会改变，并且我们等于

161
00:11:12,070 --> 00:11:12,710
一。

162
00:11:12,770 --> 00:11:16,870
此特定广告最糟糕的部分将增加1。

163
00:11:17,160 --> 00:11:17,790
好。

164
00:11:17,890 --> 00:11:19,990
现在我们只需要做最后一件事。

165
00:11:20,000 --> 00:11:25,100
当然，这是在结束回合中获得的总奖励。

166
00:11:25,210 --> 00:11:31,310
好吧，总回报对我们来说在任何回合都不是很有趣，但在最后一回合。

167
00:11:31,330 --> 00:11:37,120
那就是10000左右，因为我们当然都与得到的总数进行了比较

168
00:11:37,120 --> 00:11:42,800
提醒一下，这种随机选择算法平均为1200。

169
00:11:42,910 --> 00:11:46,780
这就是为什么我们很高兴能找到我们工作的总数的原因。

170
00:11:46,900 --> 00:11:53,690
但是在一万回合结束时，我们当然需要非常初始化这个总奖励

171
00:11:53,770 --> 00:11:58,050
因为您知道我们会在每个回合中对其进行更新。

172
00:11:58,120 --> 00:12:03,970
因此，我们需要像在物理学中一样给出其初始值，并且该初始值当然会给出零

173
00:12:04,000 --> 00:12:09,380
因为在本实验开始时大约为零，所以总奖励当然为零。

174
00:12:09,520 --> 00:12:12,270
我们实际上尚未获得任何奖励。

175
00:12:12,280 --> 00:12:22,530
因此，让我们在此处声明此新变量总奖励，然后将其设置为零，现在非常

176
00:12:22,530 --> 00:12:28,970
我们要做的只是计算在鳟鱼身上积累的总报酬。

177
00:12:29,190 --> 00:12:34,630
而且，我们需要做一些与刚才相同的增量。

178
00:12:34,680 --> 00:12:44,370
所以我在这里复制所有单词，然后粘贴到此处并等于，然后再次粘贴，再加上一个加号，然后

179
00:12:44,370 --> 00:12:46,130
根据您的需要添加什么。

180
00:12:46,140 --> 00:12:51,260
当然，我们需要添加在每个回合中得到的单词。

181
00:12:51,600 --> 00:12:56,060
这样便实现了UCB算法。

182
00:12:56,070 --> 00:12:57,380
恭喜你

183
00:12:57,480 --> 00:13:01,860
这是我们在本课程中从头实现的第一个算法。

184
00:13:01,860 --> 00:13:03,010
那太令人兴奋了。

185
00:13:03,120 --> 00:13:08,750
正如您所注意到的，我们像在现实生活中一样会构建并实现此算法。

186
00:13:08,760 --> 00:13:10,010
不，我们没有。

187
00:13:10,050 --> 00:13:16,860
Adeline一步一步地将其实现为开发人员，我们以相同的逻辑逐步实现它

188
00:13:16,860 --> 00:13:17,890
思维过程。

189
00:13:18,970 --> 00:13:20,260
恭喜你

190
00:13:20,280 --> 00:13:27,070
现在，我非常高兴地看到结果并找出他们使用该算法能击败多少人

191
00:13:27,310 --> 00:13:29,300
随机选择算法。

192
00:13:29,320 --> 00:13:34,960
提醒一下，随机选择算法给了我们1200的奖励。

193
00:13:35,020 --> 00:13:37,230
让我们看看你是如何击败它的。

194
00:13:37,330 --> 00:13:39,370
希望我们能取得不错的结果。

195
00:13:39,460 --> 00:13:44,700
因此，我将从这里选择所有内容。

196
00:13:44,710 --> 00:13:45,410
好吧。

197
00:13:45,490 --> 00:13:48,250
然后我们走了。

198
00:13:48,250 --> 00:13:49,170
这里是。

199
00:13:49,180 --> 00:13:51,660
让我们立即查看总奖励。

200
00:13:51,670 --> 00:13:56,710
我们可以看到，总奖励为211。

201
00:13:56,710 --> 00:14:02,450
我们几乎将随机选择算法获得的整个单词加倍。

202
00:14:02,500 --> 00:14:09,640
因此，您知道自己是否是Zino，并且广告不是广告，但是知道老虎机可以

203
00:14:09,640 --> 00:14:14,500
意味着您将赚到两倍的钱，而这还不是全部，因为这只是总字数

204
00:14:14,500 --> 00:14:15,570
实验的

205
00:14:15,730 --> 00:14:21,310
但是现在非常有趣的是，您获得了最高转化率的特定广告

206
00:14:21,310 --> 00:14:26,600
仅仅知道什么是最好的广告来展示给用户，以及我们如何才能发现这一点。

207
00:14:26,770 --> 00:14:32,830
好吧，我们只需要在这里将其作为选定的向量即可。

208
00:14:32,890 --> 00:14:39,370
因此，让我们先来看一下，我们可以看到的是，正如您所期望的，您知道我们的预期结果。

209
00:14:39,370 --> 00:14:46,810
实施这里，我们可以看到在第一轮中选择了帐篷广告

210
00:14:46,810 --> 00:14:52,710
我们选择一个，然后将一轮加到第3轮的第3轮，直到第10轮的约10。

211
00:14:52,750 --> 00:14:59,380
因此，这正是我们使用此巨大价值技巧获得的这10个广告的结果

212
00:14:59,380 --> 00:15:00,360
前十轮。

213
00:15:00,490 --> 00:15:02,420
然后策略开始了。

214
00:15:02,500 --> 00:15:07,780
您知道吗，因为我们会根据前10个广告中这10个广告的选择获得一些信息

215
00:15:07,780 --> 00:15:13,660
然后我们得到奖励和食物的总和以及选择信息的数量，这就是

216
00:15:13,660 --> 00:15:14,710
策略可以开始。

217
00:15:14,710 --> 00:15:21,220
这正是从这里开始执行策略并出现不同选择的地方。

218
00:15:21,550 --> 00:15:26,410
现在真正有趣的是看最后一轮比赛。

219
00:15:26,440 --> 00:15:33,280
您知道回合接近10000，因为如果该策略在逻辑上运作良好，则此算法

220
00:15:33,280 --> 00:15:39,040
应该在最后一轮中选择始终相同的广告，因为您知道有一个广告是

221
00:15:39,040 --> 00:15:41,700
转换率最高的最佳。

222
00:15:41,770 --> 00:15:44,620
您知道这可能是广告将汽车停在美丽的桥上的原因。

223
00:15:44,620 --> 00:15:51,520
因此，我们当然不知道这个获胜者广告，但这是该广告选择的载体

224
00:15:51,550 --> 00:15:52,080
告诉我们。

225
00:15:52,120 --> 00:15:54,320
如果我们看最后一轮，那就开始吧。

226
00:15:54,370 --> 00:15:56,440
我们将下去。

227
00:15:56,440 --> 00:15:56,690
好。

228
00:15:56,700 --> 00:15:57,350
开始了。

229
00:15:57,400 --> 00:16:03,520
因此，正如您所看到的，当我快要倒塌时，您会发现越来越多的五个不同的

230
00:16:03,520 --> 00:16:07,720
可以看到我们正在选择越来越多的五种干旱。

231
00:16:08,110 --> 00:16:14,710
如果我再次下降并下降得越来越好，我们将获得更多5，并且他们的最后一轮

232
00:16:14,710 --> 00:16:16,860
在最后一千回合中。

233
00:16:16,960 --> 00:16:24,100
好吧，我们只选择五个，正如您现在所看到的，我们现在大约为九千八百

234
00:16:24,100 --> 00:16:25,990
只能观察五个。

235
00:16:25,990 --> 00:16:27,640
所以显然是最好的。

236
00:16:27,660 --> 00:16:33,450
并且我们应该选择对使用进行展示，并且转换率最高是第五。

237
00:16:33,670 --> 00:16:35,440
很好。

238
00:16:35,440 --> 00:16:40,630
不仅总数几乎翻了一番，而且总数也达到了278个。

239
00:16:40,640 --> 00:16:45,970
奖励，但我们也知道什么是最好的广告展示给用户。

240
00:16:45,970 --> 00:16:47,470
当然，我们对两者都感兴趣。

241
00:16:47,470 --> 00:16:49,700
我们有兴趣知道什么是最好的。

242
00:16:49,720 --> 00:16:55,660
另外，为了达到最佳效果，我们告诉我们，因为您知道尝试这些广告的展示位置

243
00:16:55,660 --> 00:16:57,430
在社交网络上花费金钱。

244
00:16:57,550 --> 00:17:02,740
而且您知道我说的一开始我们的预算很有限，通常部门

245
00:17:02,740 --> 00:17:04,750
行销或任何业务。

246
00:17:04,840 --> 00:17:11,650
我们的预算有限，因此我们需要对此进行优化，以补偿成本，并希望

247
00:17:11,710 --> 00:17:12,920
已经赚了一些钱。

248
00:17:13,060 --> 00:17:15,650
因此，这两个结果非常重要。

249
00:17:15,670 --> 00:17:19,190
因此，非常感谢您使用此UCB算法。

250
00:17:19,330 --> 00:17:24,900
现在，像往常一样，我们将完成此UCAP算法部分，这是最后一步。

251
00:17:24,940 --> 00:17:31,270
可视化结果的令人兴奋的步骤以及我们将要做的就是绘制一个直方图，显示

252
00:17:31,270 --> 00:17:34,170
对于每个添加，选择它的次数。

253
00:17:34,180 --> 00:17:37,910
因此，我们将在下一个教程中做到这一点，直到享受机器学习。

