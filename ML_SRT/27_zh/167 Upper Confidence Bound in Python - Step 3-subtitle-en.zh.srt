1
00:00:00,300 --> 00:00:02,800
您好，欢迎来到香料和教程。

2
00:00:02,850 --> 00:00:08,020
因此，让我们从中断的地方开始，我们尝试找出为什么使用此上限

3
00:00:08,040 --> 00:00:14,720
对应于这个非常大的数字10，在此Elle公式中赋予该上限变量的幂400

4
00:00:14,730 --> 00:00:15,520
条件。

5
00:00:15,720 --> 00:00:17,080
好吧，让我们看看会发生什么。

6
00:00:17,130 --> 00:00:21,500
您知道让我们看看在回合时会发生什么，并且您在第一回合叫0。

7
00:00:21,650 --> 00:00:26,130
当它第一轮等于零时，我们将经历加法的10个版本。

8
00:00:26,190 --> 00:00:28,150
感谢这里的for循环。

9
00:00:28,290 --> 00:00:31,560
并且由于在第一轮中没有选择ADD。

10
00:00:31,770 --> 00:00:40,080
那么这里的这种情况如果选择数I大于零将永远不会成立，因此

11
00:00:40,260 --> 00:00:43,050
将直接转到此处的其他位置。

12
00:00:43,380 --> 00:00:49,220
因此，上限将设置为等于400的幂的10。

13
00:00:49,230 --> 00:00:53,600
然后我们进入这种状态，因为这是此论坛的下一步。

14
00:00:53,790 --> 00:00:59,130
它说如果上限大于最大上限，那当然是正确的，因为上限

15
00:00:59,160 --> 00:01:02,290
边界是400的乘方的10，最大值将为零。

16
00:01:02,340 --> 00:01:03,800
所以这个条件是真的。

17
00:01:03,900 --> 00:01:07,890
因此，接下来发生的事情是Max supervillian等于上限。

18
00:01:07,890 --> 00:01:13,460
因此，Max preven将等于400的乘方10，并等于。

19
00:01:14,010 --> 00:01:17,360
因此，由于我们处于后续跟踪的开始，因此我将其称为0。

20
00:01:17,460 --> 00:01:19,780
因此，亚当等于零。

21
00:01:19,830 --> 00:01:27,670
然后我们进入下一步，因为我在这里循环，即我等于1好我等于1等于一个对应

22
00:01:27,700 --> 00:01:31,820
添加到第二个广告，还没有选择第二个添加。

23
00:01:31,830 --> 00:01:36,430
因此，我听到的选择数量不会大于0。

24
00:01:36,570 --> 00:01:38,520
因此，这里的条件将不成立。

25
00:01:38,520 --> 00:01:41,180
因此，我们再次在这里解决这个问题。

26
00:01:41,190 --> 00:01:44,630
因此，上限为400的幂时等于10。

27
00:01:44,820 --> 00:01:46,770
然后，如果在这里，请转到此。

28
00:01:46,830 --> 00:01:51,930
现在，让我们看一下该条件是否为真，上限为400的幂时等于10。

29
00:01:52,170 --> 00:01:58,410
并记得上一轮的最大功率为400时说Max或PERVAN等于10，因为它

30
00:01:58,410 --> 00:02:00,220
设置为等于上限。

31
00:02:00,480 --> 00:02:07,650
因此，此条件实际上转换为10等于400的乘方大于10的乘方。

32
00:02:07,650 --> 00:02:08,480
400

33
00:02:08,670 --> 00:02:09,930
那是不对的。

34
00:02:10,080 --> 00:02:13,840
400的幂不大于400的10。

35
00:02:14,010 --> 00:02:21,630
因此该条件不成立，因此add的值不等于1，因为现在等于1，但是

36
00:02:21,690 --> 00:02:23,480
加保持等于零。

37
00:02:23,640 --> 00:02:31,050
这就是为什么在第一轮任何通话0时，将选择的ADD等于零的原因。

38
00:02:31,170 --> 00:02:36,390
您可以尝试使用其他值，我会听到上限始终等于10或400的幂

39
00:02:36,720 --> 00:02:40,110
并且最大上限仍将等于400的幂的10。

40
00:02:40,230 --> 00:02:45,510
因此，此条件永远不会在这里剩余的9个ATS中得到验证，因此我们

41
00:02:45,510 --> 00:02:47,180
保持此加等于零。

42
00:02:47,400 --> 00:02:49,770
这与下一轮比赛的原则相同。

43
00:02:49,770 --> 00:02:54,150
也就是说，在回合结束时，任何跟注1到10等于1。

44
00:02:54,160 --> 00:03:00,300
仅对于第一个添加，此处的选择数量将大于0，因为第一个广告是

45
00:03:00,300 --> 00:03:06,110
选择在地零，因此该条件仅在第一个I等于零时为真。

46
00:03:06,300 --> 00:03:10,750
因此上限将等于此平均奖励加我听到的差额。

47
00:03:10,950 --> 00:03:15,530
但是接下来我们将继续我加一个对应于adversion 2的数字。

48
00:03:15,720 --> 00:03:18,400
由于尚未选择adversion 2。

49
00:03:18,580 --> 00:03:24,600
好吧，我听到的这个选择数等于零，因此这种情况不会

50
00:03:24,600 --> 00:03:26,850
经过验证，因此您可以解决。

51
00:03:26,850 --> 00:03:31,370
否则，在400的幂处，上限将等于10。

52
00:03:31,410 --> 00:03:36,200
我们将忘记在此之前的眼睛计算出的该上限值。

53
00:03:36,390 --> 00:03:40,950
因此，接下来发生的是相同的上限将大于最大上限反弹，因为

54
00:03:41,070 --> 00:03:45,800
事件前的最大值等于前一只眼睛的上限和前一只眼睛的上限

55
00:03:45,810 --> 00:03:52,030
我的平均奖励是Plus Delta II，它当然比400的幂下的10低。

56
00:03:52,080 --> 00:03:58,020
这就是为什么顺便说一句，我们使用非常大的值表示它，以便使此上限在此处较低

57
00:03:58,020 --> 00:04:03,200
比中心功率高400，因此Maxo preven在功率400时将为10。

58
00:04:03,360 --> 00:04:06,000
我们将选择平等。

59
00:04:06,030 --> 00:04:11,180
那是第二，然后是与以前相同的原理，当我们转到下一个时。

60
00:04:11,180 --> 00:04:16,920
睁大眼睛的人将等于10，并且在上限时400 Max或预禁的功效也将等于10。

61
00:04:16,920 --> 00:04:18,040
电源400。

62
00:04:18,180 --> 00:04:23,070
因此，这种情况不会得到验证，因此我们将保持第二。

63
00:04:23,460 --> 00:04:29,100
这就是为什么这里的这个小技巧对我们来说效果很好，并能为我们提供想要的东西。

64
00:04:29,100 --> 00:04:35,370
好吧，所以第一个10个回合选择了10个，然后在大约10个之后，我们使用此策略来选择

65
00:04:35,370 --> 00:04:36,150
广告。

66
00:04:36,450 --> 00:04:43,710
好吧，现在我们要做的唯一一件事就是在此处附加选中的内容

67
00:04:43,710 --> 00:04:44,540
向量在这里。

68
00:04:44,670 --> 00:04:46,560
而这正是我们现在要做的。

69
00:04:46,560 --> 00:04:47,840
因此，让我们开始吧。

70
00:04:48,000 --> 00:04:52,160
我们只需要退出for循环，因为我们已经完成了该循环。

71
00:04:52,170 --> 00:04:55,820
我们所做的正是选择正确的添加。

72
00:04:56,070 --> 00:05:02,870
现在我们需要退出此for循环，但仍要保留此for循环，因为我们仍处于特定状态

73
00:05:02,880 --> 00:05:09,530
路线，我们现在要做的就是将此处选择的广告附加到这个巨大的矢量上

74
00:05:09,530 --> 00:05:14,170
在选定的位置，包含每个回合中选定的所有不同广告。

75
00:05:14,390 --> 00:05:16,930
好，现在事情很简单。

76
00:05:17,000 --> 00:05:24,290
我们只需要在选择了巨大矢量的这些广告上使用附加功能，并使用此方法，

77
00:05:24,290 --> 00:05:27,080
需要在此处添加一个点，然后再添加一支笔。

78
00:05:27,080 --> 00:05:28,310
这里是。

79
00:05:28,310 --> 00:05:29,330
好吧。

80
00:05:29,330 --> 00:05:35,840
现在，在此附加函数中，我们输入输入add，因为它对应于广告的索引

81
00:05:36,080 --> 00:05:38,970
我在这里选择的是这个

82
00:05:38,990 --> 00:05:42,040
好的，这样做取决于。

83
00:05:42,170 --> 00:05:48,860
现在，由于我们刚刚在这里选择了一个新广告，我们需要做的就是更新

84
00:05:48,860 --> 00:05:50,080
这里的选择。

85
00:05:50,090 --> 00:05:54,800
您知道向量告诉每个添加项被选择的次数。

86
00:05:54,800 --> 00:06:01,570
因此，由于在这里我们知道刚选择专辑的哪个索引，我们需要做的就是添加一个加号。

87
00:06:01,580 --> 00:06:06,790
在这些选择向量数目的特定索引中，以更新该向量。

88
00:06:06,800 --> 00:06:08,010
所以现在就开始吧。

89
00:06:08,150 --> 00:06:15,020
我们当然会留在此for end循环中，因为此向量将包含每个循环的次数

90
00:06:15,080 --> 00:06:17,250
在此特定运行中选择了添加。

91
00:06:17,270 --> 00:06:23,610
因此，我们需要保持循环状态，我们将在这里简单地采用此向量。

92
00:06:23,900 --> 00:06:27,650
复制并粘贴到此处进行更新。

93
00:06:27,770 --> 00:06:35,420
因此，到目前为止，我们需要的是这些选择向量数量的ADD索引，因为这会增加

94
00:06:35,420 --> 00:06:41,030
index对应于刚刚在此处选择的广告的索引，该选择基于所有

95
00:06:41,030 --> 00:06:42,050
策略。

96
00:06:42,320 --> 00:06:47,590
因此，我们只需要做的就是在此向量上增加一个。

97
00:06:47,600 --> 00:06:49,610
因此，我们将复制它。

98
00:06:49,610 --> 00:06:53,420
再次复制等于粘贴。

99
00:06:53,540 --> 00:06:55,840
然后再加一点。

100
00:06:55,850 --> 00:06:56,440
好吧。

101
00:06:56,540 --> 00:07:02,390
因此，这些选择向量的数量已经过时，这就是我们需要做的所有事情

102
00:07:02,660 --> 00:07:07,060
在此特定回合中，因为当然只选择了一个广告。

103
00:07:07,070 --> 00:07:07,440
好。

104
00:07:07,460 --> 00:07:13,130
现在我们需要注意奖励，因为实际上我们这里有一些奖励向量

105
00:07:13,430 --> 00:07:19,460
我们需要更新，因为此向量包含10个中的每个向量的不同总和

106
00:07:19,520 --> 00:07:21,660
在每一轮增加。

107
00:07:21,680 --> 00:07:23,420
因此，我们需要对其进行更新。

108
00:07:23,510 --> 00:07:28,970
当然，此后，我们希望获得总数，我们希望该单位将是一个包含

109
00:07:29,150 --> 00:07:34,040
我们在各回合中积累的独特奖励总和。

110
00:07:34,040 --> 00:07:36,000
因此，让我们首先照顾一下。

111
00:07:36,020 --> 00:07:40,080
你们中有些人想在这里进行引导，然后我们会照顾您想要的一切。

112
00:07:40,280 --> 00:07:47,930
因此，到目前为止，这里的奖励因素总和是我们现在需要获得的奖励

113
00:07:47,930 --> 00:07:48,270
回合。

114
00:07:48,290 --> 00:07:55,370
而且因为您知道我们只是在这里选择了它，但我们还没有得到它，所以我们只是选择了

115
00:07:55,370 --> 00:07:57,990
广告，所以现在我们需要获取广告。

116
00:07:58,040 --> 00:08:04,190
因此，在现实生活中，发生的事情是您知道我们向用户展示广告，然后用户点击“是”

117
00:08:04,190 --> 00:08:05,470
还是在广告上没有。

118
00:08:05,750 --> 00:08:11,690
但是在这里，我们并不像我希望向您展示的真实实验那样真实。

119
00:08:11,690 --> 00:08:17,690
现在，这并不是那么简单，但是我们有了这个模拟数据集。

120
00:08:17,840 --> 00:08:24,350
您知道这里的数据集包含只有上帝知道的真实结果，因为

121
00:08:24,350 --> 00:08:27,840
我们不知道每个用户都会点击哪个添加。

122
00:08:27,890 --> 00:08:32,730
提醒一下，第一个用户单击5和9之一。

123
00:08:32,750 --> 00:08:34,040
现在剩下的了。

124
00:08:34,040 --> 00:08:36,660
因此，这只是一个模拟数据集。

125
00:08:36,680 --> 00:08:42,170
因此，我们现在要做的是根据所选的广告在每一轮中获得奖励。

126
00:08:42,170 --> 00:08:43,840
感谢这个数据集。

127
00:08:43,850 --> 00:08:52,730
因此，让我们做的是，在此特定回合中简单地获得1或0的奖励，

128
00:08:52,730 --> 00:08:53,840
我们在哪里。

129
00:08:53,870 --> 00:08:59,910
因此，要做到这一点非常简单，我们需要做的就是知道我们导入的数据集

130
00:08:59,930 --> 00:09:06,950
与土匪，你知道在这个点值来获取值，在括号中，我们需要指定

131
00:09:07,250 --> 00:09:09,750
我们所在的线的索引。

132
00:09:09,770 --> 00:09:14,150
您知道哪个回合，并且与我们当前所在的位置相对应。

133
00:09:14,240 --> 00:09:19,110
因此，由于此数据集的所有行都只是回合而已。

134
00:09:19,250 --> 00:09:21,210
好吧，第一个指数将是回合。

135
00:09:21,260 --> 00:09:23,750
举例来说，假设我们现在是9点左右。

136
00:09:23,840 --> 00:09:29,870
好吧，我们将需要获取数据集的行索引9，然后调用它们，因为各列

137
00:09:29,870 --> 00:09:33,300
这里对应于10个不同广告的奖励。

138
00:09:33,470 --> 00:09:36,540
好吧，我们需要获取所选广告的索引。

139
00:09:36,590 --> 00:09:40,280
这里没有什么比这个广告索引更重要的了。

140
00:09:40,280 --> 00:09:46,700
举例来说，假设在本轮比赛中，我们选择了第三名，然后通过输入数据

141
00:09:46,700 --> 00:09:51,930
此处对应于三点的行索引和列索引的集合。

142
00:09:52,100 --> 00:09:53,880
好吧，我们会得到一个奖励。

143
00:09:54,050 --> 00:09:57,940
另一方面，假设选择了索引编号6。

144
00:09:58,130 --> 00:10:03,430
不幸的是，由于亚当六号对此值的响应为零。

145
00:10:03,520 --> 00:10:05,800
好吧，不幸的是我们将得到零。

146
00:10:05,800 --> 00:10:09,120
我们想要的就是我们必须要做的想法。

147
00:10:09,280 --> 00:10:13,250
但是，当然，在现实生活中，您将真正了解用户的情况。

148
00:10:13,270 --> 00:10:19,720
所以我要结束这个，现在我将获得真正的回报，那就是我们

149
00:10:19,720 --> 00:10:23,010
在此处选择此广告索引。

150
00:10:23,200 --> 00:10:24,400
因此，让我们开始吧。

151
00:10:24,400 --> 00:10:27,850
我们将这场真正的战争称为回报。

152
00:10:27,870 --> 00:10:28,650
好吧。

153
00:10:28,650 --> 00:10:35,050
现在，正如我刚刚解释的那样，我们需要获取数据集的Daut值，然后加上括号。

154
00:10:35,110 --> 00:10:38,110
然后，我们需要获取与周围对应的线的索引。

155
00:10:38,150 --> 00:10:43,930
如此反复，我们需要获取与索引对应的列的索引

156
00:10:43,930 --> 00:10:45,750
刚刚选择的广告。

157
00:10:45,760 --> 00:10:48,190
所以就在这里，仅此而已。

158
00:10:48,280 --> 00:10:50,280
我们只是获得真正的回报。

159
00:10:50,290 --> 00:10:54,290
并为此使用此广告的特定选择。

160
00:10:54,310 --> 00:10:54,790
好。

161
00:10:54,940 --> 00:10:55,840
很好。

162
00:10:55,900 --> 00:11:02,260
我们刚刚获得了真正的奖励，现在我们可以在此处更新此奖励向量之和，以提醒您

163
00:11:02,260 --> 00:11:06,250
在每个末端给10个儿子中的每个儿子奖励。

164
00:11:06,250 --> 00:11:15,290
因此，我们将获取此副本，然后在其下方将增加此向量。

165
00:11:15,400 --> 00:11:21,520
当然，我们需要采用此向量的ADD索引，因为只有在

166
00:11:21,520 --> 00:11:25,570
在这个特定的回合中，我们将对其中的一些单词进行更改。

167
00:11:25,570 --> 00:11:31,060
因此，这只是我们需要更新的一些单词，因此我们需要做的是增加

168
00:11:31,360 --> 00:11:39,040
当然，我们的话不是一种奖励，而是一种奖励，因为奖励是0或1，所以等于

169
00:11:39,040 --> 00:11:48,400
在这里，然后我们再拿一次，再加上奖励，所以如果我们去零，奖励单词的总和

170
00:11:48,400 --> 00:11:50,560
该特定广告不会更改。

171
00:11:50,560 --> 00:11:56,240
如果我们等于1，则此特定广告的一些最差结果将增加1。

172
00:11:56,540 --> 00:11:57,180
好。

173
00:11:57,280 --> 00:11:59,420
现在我们只需要做最后一件事。

174
00:11:59,440 --> 00:12:04,500
当然，这是在结束回合中获得的总奖励。

175
00:12:04,600 --> 00:12:10,690
好吧，总回报对我们来说在任何回合都不是很有趣，但在最后一回合。

176
00:12:10,720 --> 00:12:16,330
那就是10000左右，因为我们当然会将其与我们获得的总奖励进行比较

177
00:12:16,330 --> 00:12:22,320
提醒一下，这种随机选择算法平均为1200。

178
00:12:22,330 --> 00:12:26,220
这就是为什么我们很高兴能找到我们工作的总数的原因。

179
00:12:26,320 --> 00:12:33,150
但是在一万回合结束时，我们当然需要初始化总奖励Voivode

180
00:12:33,160 --> 00:12:37,410
因为您知道我们会在每个回合中对其进行更新。

181
00:12:37,510 --> 00:12:43,360
所以我们需要给它一个初始值，就像在物理学中一样，这个初始值当然会是零

182
00:12:43,390 --> 00:12:48,770
因为在本实验开始时大约为0，总奖励当然为零。

183
00:12:48,910 --> 00:12:51,670
我们实际上尚未获得任何奖励。

184
00:12:51,670 --> 00:13:01,100
因此，让我们在此处声明此新的无效总奖励，然后将其设置为零。

185
00:13:01,470 --> 00:13:08,890
现在，我们要做的非常简单，就是计算在鳟鱼身上积累的总奖励。

186
00:13:09,120 --> 00:13:14,530
而且，我们需要做一些与刚才相同的增量。

187
00:13:14,580 --> 00:13:23,900
因此，我要抄袭的内容是告诉我们我们要粘贴在这里，然后引用，然后再次粘贴并添加一个加号。

188
00:13:24,180 --> 00:13:26,270
然后根据您的需要添加什么。

189
00:13:26,280 --> 00:13:30,890
当然，我们需要添加在每个回合中得到的词。

190
00:13:30,990 --> 00:13:35,410
因此，我将其复制到此处并粘贴到此处。

191
00:13:35,420 --> 00:13:35,940
好。

192
00:13:36,210 --> 00:13:40,680
这样便实现了UCB算法。

193
00:13:40,680 --> 00:13:41,890
恭喜你

194
00:13:42,120 --> 00:13:47,850
这是我们在本课程中从头实现的第一个算法，非常令人兴奋。

195
00:13:47,850 --> 00:13:53,750
这样做的好处是您可以了解Python语法，并且知道我们在这里出错了。

196
00:13:53,980 --> 00:14:00,350
如您所知，我们就像在现实生活中一样会构建并实施此算法。

197
00:14:00,360 --> 00:14:01,650
不，我们没有。

198
00:14:01,660 --> 00:14:08,460
Adeline一步一步地将其实现为开发人员，我们以相同的逻辑逐步实现它

199
00:14:08,460 --> 00:14:11,860
思维过程如此恭喜。

200
00:14:11,870 --> 00:14:18,670
现在，我非常高兴地看到结果并找出他们使用该算法能击败多少人

201
00:14:18,910 --> 00:14:20,900
随机选择算法。

202
00:14:20,920 --> 00:14:26,570
提醒一下，随机选择算法给了我们1200的奖励。

203
00:14:26,620 --> 00:14:28,770
让我们看看你是如何击败它的。

204
00:14:28,930 --> 00:14:30,960
希望我们能取得不错的结果。

205
00:14:31,060 --> 00:14:36,300
因此，我将从这里选择所有内容。

206
00:14:36,310 --> 00:14:37,090
好吧。

207
00:14:37,090 --> 00:14:39,840
然后我们走了。

208
00:14:39,850 --> 00:14:40,770
这里是。

209
00:14:40,780 --> 00:14:43,260
让我们立即查看总奖励。

210
00:14:43,270 --> 00:14:48,300
我们可以看到，总奖励为211。

211
00:14:48,310 --> 00:14:54,060
我们几乎将随机选择算法获得的总奖励提高了一倍。

212
00:14:54,100 --> 00:15:00,820
太好了，您知道您是否是Dick Zino，并且这些广告不是广告，但您知道老虎机

213
00:15:01,120 --> 00:15:05,760
这意味着您将赚到两倍的钱，而这还不是全部，因为这只是总数

214
00:15:05,780 --> 00:15:07,170
实验的话。

215
00:15:07,330 --> 00:15:12,910
但是现在非常有趣的是，您获得了最高转化率的特定广告

216
00:15:12,910 --> 00:15:18,200
仅仅知道什么是最好的广告来展示给用户，以及我们如何才能发现这一点。

217
00:15:18,370 --> 00:15:24,460
好吧，我们只需要看这里就是这里的选定向量。

218
00:15:24,460 --> 00:15:29,120
因此，让我们先看一下我们所看到的是预期的情况。

219
00:15:29,140 --> 00:15:34,980
您知道，作为我们实施的预期结果，我们可以在第一轮中看到

220
00:15:35,290 --> 00:15:37,180
帐篷广告被选中。

221
00:15:37,360 --> 00:15:43,510
您知道，正如我告诉您的那样，我们在第0轮选择零井，这是我们在第一个轮选择的第一轮

222
00:15:43,660 --> 00:15:48,160
四舍五入到3的第3轮，直到9的第9轮。

223
00:15:48,190 --> 00:15:54,820
因此，这正是我们使用此巨大价值技巧将这10个添加到

224
00:15:54,820 --> 00:15:55,830
10发

225
00:15:55,930 --> 00:16:01,480
然后该策略就开始了，您会知道，因为我们会根据这些选择来获取一些信息

226
00:16:01,630 --> 00:16:07,720
在第一个10轮中，这里有10个广告，然后我们得到奖励的总和以及选择的数量

227
00:16:07,720 --> 00:16:10,120
信息，这就是该策略可以开始的时间。

228
00:16:10,120 --> 00:16:11,760
这正是这里发生的情况。

229
00:16:11,800 --> 00:16:16,670
从这里开始，策略开始运行，并且出现不同的选择。

230
00:16:16,990 --> 00:16:21,850
现在真正有趣的是看最后几轮比赛。

231
00:16:21,880 --> 00:16:28,720
您知道回合接近10000，因为如果该策略在逻辑上运作良好，则此算法

232
00:16:28,720 --> 00:16:30,370
应该选择始终相同。

233
00:16:30,370 --> 00:16:36,400
在最后几轮比赛中，因为您知道有一个，那就是转化率最高的最好的

234
00:16:36,400 --> 00:16:37,120
率。

235
00:16:37,180 --> 00:16:39,910
您知道这可能是广告将汽车停在美丽的桥上的原因。

236
00:16:40,060 --> 00:16:47,260
因此，我们当然不知道这个获胜者广告，但这就是该广告选择向量所能说明的

237
00:16:47,260 --> 00:16:47,520
我们。

238
00:16:47,560 --> 00:16:49,760
如果我们看最后一轮，那就开始吧。

239
00:16:49,810 --> 00:16:51,880
我们将下去。

240
00:16:51,880 --> 00:16:52,120
好。

241
00:16:52,120 --> 00:16:52,790
开始了。

242
00:16:52,840 --> 00:16:58,960
因此，正如您所看到的，它并没有下降，随着您的使用，不同品牌的数量越来越多

243
00:16:58,960 --> 00:17:03,160
可以看到我们正在为之选择越来越多的趋势。

244
00:17:03,550 --> 00:17:10,130
如果我再次下降并且下降得越来越好，我们将获得更多的4，并且他们的最后一轮

245
00:17:10,150 --> 00:17:12,290
在最后一千回合中。

246
00:17:12,460 --> 00:17:17,710
好吧，我们只有4个，正如您所看到的，我们这里只有4个。

247
00:17:17,710 --> 00:17:20,540
现在，我们大约有9.88万。

248
00:17:20,650 --> 00:17:22,760
我们只能观察4。

249
00:17:22,780 --> 00:17:28,180
显然最好，我们应该选择使用它，并且转换率最高

250
00:17:28,450 --> 00:17:32,930
是第4位，请注意，这是索引。

251
00:17:32,980 --> 00:17:37,680
因此，这是广告的索引号，由于index和putten开始为零。

252
00:17:37,810 --> 00:17:41,360
好吧，这实际上对应于版本号5。

253
00:17:41,500 --> 00:17:47,830
太好了，我们在这207个中不仅将所需总数几乎翻了一番

254
00:17:47,920 --> 00:17:53,800
总共八种奖励，但我们也知道什么是最好的广告展示给用户。

255
00:17:53,800 --> 00:17:55,300
当然，我们对两者都感兴趣。

256
00:17:55,300 --> 00:18:00,640
我们有兴趣了解什么是最好的，也有兴趣来优化此总数，因为您在这里

257
00:18:00,640 --> 00:18:05,240
知道在社交网络上尝试这些广告的放置会花费金钱。

258
00:18:05,380 --> 00:18:10,600
而且您知道我说的一开始我们的预算很有限，通常部门

259
00:18:10,600 --> 00:18:12,670
行销或任何业务。

260
00:18:12,670 --> 00:18:19,480
我们的预算有限，因此我们只需要优化我们要补偿的所有费用，并希望

261
00:18:19,540 --> 00:18:20,750
已经赚了一些钱。

262
00:18:20,890 --> 00:18:23,410
因此，这两个结果非常重要。

263
00:18:23,500 --> 00:18:26,970
因此，非常感谢您使用此UCB算法。

264
00:18:27,070 --> 00:18:28,290
所以我现在按OK。

265
00:18:28,440 --> 00:18:34,030
现在，像往常一样，我们将完成此UCB算法部分，这是最后一步。

266
00:18:34,090 --> 00:18:40,390
可视化结果的令人兴奋的步骤以及我们将要做的就是绘制一个直方图，显示

267
00:18:40,390 --> 00:18:43,120
对于每次添加，都会多次被选择。

268
00:18:43,330 --> 00:18:45,200
因此，我们将在Tauriel旁边进行操作。

269
00:18:45,220 --> 00:18:46,870
在那之前我是机器学习

