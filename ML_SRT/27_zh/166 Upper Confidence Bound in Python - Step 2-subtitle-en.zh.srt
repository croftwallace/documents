1
00:00:00,330 --> 00:00:02,520
您好，欢迎来到Spuyten教程。

2
00:00:02,580 --> 00:00:07,650
因此，在上一个教程中，我们导入了数据集，而今天，在本教程中，我们将实现

3
00:00:07,740 --> 00:00:10,940
UCB上会议上限算法。

4
00:00:11,100 --> 00:00:16,770
因此，我不确定这是个坏消息还是个好消息，但是实际上没有可以轻松使用的软件包

5
00:00:16,770 --> 00:00:19,700
以实现此UCB算法。

6
00:00:19,980 --> 00:00:21,350
因此，这是个坏消息。

7
00:00:21,360 --> 00:00:27,360
但是好消息是我们将从头开始实施UCB，这是一个好消息，因为

8
00:00:27,360 --> 00:00:31,680
这将为您提供真正提高Python技能的机会。

9
00:00:31,860 --> 00:00:33,330
所以准备好

10
00:00:33,330 --> 00:00:38,490
在实现之前，不需要花三到四行像以前那样

11
00:00:38,490 --> 00:00:42,260
整个算法从零开始，无需使用任何程序包。

12
00:00:42,390 --> 00:00:44,600
我们将逐步进行。

13
00:00:44,610 --> 00:00:51,030
说到步骤，现在让我们跳到上置信度值算法的幻灯片。

14
00:00:51,030 --> 00:00:53,970
因此，该算法需要三个步骤。

15
00:00:54,030 --> 00:00:59,740
第一步是每个回合，每个加法考虑两个数字。

16
00:00:59,910 --> 00:01:06,830
也就是说，对于每个版本的加法，这两个数字是和I被选择的次数

17
00:01:06,830 --> 00:01:11,970
最多一轮，与归并的奖励总和我有两轮。

18
00:01:12,200 --> 00:01:12,500
好。

19
00:01:12,540 --> 00:01:18,150
所以我们要做的第一件事是声明这两个变量，因为我们将需要它们

20
00:01:18,180 --> 00:01:18,860
然后。

21
00:01:18,990 --> 00:01:19,250
好。

22
00:01:19,260 --> 00:01:26,370
所以第一个是我被选择四舍五入的次数，实际上我们称这个变量为

23
00:01:26,700 --> 00:01:31,500
选择数量。

24
00:01:31,630 --> 00:01:32,230
好吧。

25
00:01:32,520 --> 00:01:35,440
因此，我们需要考虑每个数字。

26
00:01:35,630 --> 00:01:41,910
因此，我们要做的是创建一个向量，其中将包含每个数量的选择

27
00:01:42,000 --> 00:01:42,780
每个添加。

28
00:01:42,850 --> 00:01:49,080
因此，我们将将此变量设置为等于大小为D的向量，并初始化的所有分量。

29
00:01:49,080 --> 00:01:50,730
此向量为零。

30
00:01:50,850 --> 00:01:52,670
因此，我们如何在Python中做到这一点。

31
00:01:52,800 --> 00:01:56,020
好吧，我们可以在这里使用这个小技巧来非常有效地做到这一点。

32
00:01:56,040 --> 00:01:58,210
那就是我们在这里加上一些括号。

33
00:01:58,360 --> 00:02:03,210
将零放在里面，然后乘以三。

34
00:02:03,450 --> 00:02:04,030
好吧。

35
00:02:04,290 --> 00:02:10,380
这将创建一个仅包含零个零的大小为D的向量，我们这样做是因为

36
00:02:10,380 --> 00:02:14,750
当然，在第一轮还没有选择每个广告版本。

37
00:02:14,850 --> 00:02:19,380
因此，选择专辑的每个版本的次数当然为零。

38
00:02:19,590 --> 00:02:21,350
好的，第一个数字已完成。

39
00:02:21,510 --> 00:02:21,840
好吧。

40
00:02:21,840 --> 00:02:27,170
第二个数字是合计和的奖励总和。

41
00:02:27,410 --> 00:02:37,190
好吧，让我们以这种方式称呼这可怕的一些奖励，同样，您知道我们需要取总和

42
00:02:37,190 --> 00:02:40,110
试用中每个广告版本的奖励。

43
00:02:40,140 --> 00:02:45,150
因此，我们将把它设置为组件的向量，就像我们对数字所做的一样

44
00:02:45,150 --> 00:02:51,790
的选择和相同将其初始化为零，因为当然在第一轮奖励儿子

45
00:02:51,850 --> 00:02:55,130
每个版本的广告当然为零。

46
00:02:55,170 --> 00:03:00,080
因此，我们将复制此副本并将其粘贴到此处。

47
00:03:00,120 --> 00:03:00,610
好吧。

48
00:03:00,630 --> 00:03:03,460
所以基本上第一步就完成了。

49
00:03:03,480 --> 00:03:05,320
现在，我们继续第二步。

50
00:03:05,490 --> 00:03:08,400
第二步来自这两个数字。

51
00:03:08,490 --> 00:03:13,960
我们首先计算I的平均奖励，直到和之间。

52
00:03:14,250 --> 00:03:18,320
其次是置信区间。

53
00:03:18,350 --> 00:03:23,020
因此，基本上我们需要在每个回合中计算这两个数字。

54
00:03:23,370 --> 00:03:28,770
因此，让我们也执行此步骤，因为我们需要在每一轮计算这两个数字。

55
00:03:28,800 --> 00:03:32,600
当然，我们需要做的是创建一个for循环。

56
00:03:32,820 --> 00:03:34,870
好的，这就是我们要做的。

57
00:03:34,920 --> 00:03:41,020
我们将经历从0到10000的所有回合。

58
00:03:41,040 --> 00:03:42,960
所以每一轮。

59
00:03:43,000 --> 00:03:48,260
因此，我们称其为“回合”和“范围括号”。

60
00:03:48,360 --> 00:03:51,810
因此，现在我们需要输入下限零。

61
00:03:51,960 --> 00:03:56,250
所以这是第一轮回零，因为索引和位开始为零。

62
00:03:56,430 --> 00:04:03,960
然后上界是，所以是10000回合的总回合数，所以在

63
00:04:03,960 --> 00:04:11,880
如果您遇到更多回合或更多用户的问题，我们将在此处声明此变量，

64
00:04:12,330 --> 00:04:16,440
在这里等于等于一万。

65
00:04:16,470 --> 00:04:20,540
到目前为止，还可以10000，且范围为零。

66
00:04:20,640 --> 00:04:23,780
然后我们不要忘记这里的圆锥体。

67
00:04:23,940 --> 00:04:26,280
然后我们进入循环。

68
00:04:26,280 --> 00:04:27,850
好吧，现在我们处于循环中。

69
00:04:27,960 --> 00:04:29,630
因此，我们需要做什么。

70
00:04:29,760 --> 00:04:35,390
我们需要为广告的每个版本计算平均字数和置信区间。

71
00:04:35,490 --> 00:04:37,300
所以这正是我们要做的。

72
00:04:37,320 --> 00:04:43,650
由于我们正在针对每个广告版本进行操作，因此我现在需要做的另一件事是

73
00:04:43,650 --> 00:04:49,030
循环，这次我们将循环播放所有10个不同版本的广告。

74
00:04:49,140 --> 00:04:51,310
因此广告被i索引。

75
00:04:51,330 --> 00:05:00,330
因此，对于我来说，这里是范围，然后是零，因为我们有10个版本的广告，并且从

76
00:05:00,330 --> 00:05:01,840
0至9。

77
00:05:01,860 --> 00:05:02,950
所以来这里。

78
00:05:03,030 --> 00:05:10,170
再说一次，如果您有更多版本的ADD或更多的臂用于

79
00:05:10,170 --> 00:05:12,090
您的具体问题。

80
00:05:12,090 --> 00:05:19,410
因此，我们将在此处声明一个新变量D，由于这是我们要设置的广告数量

81
00:05:19,410 --> 00:05:21,310
等于10

82
00:05:21,330 --> 00:05:21,910
好吧。

83
00:05:22,290 --> 00:05:29,460
现在我们进入第二个循环，所以现在在这个级别上，我们处于特定的回合

84
00:05:29,580 --> 00:05:32,650
处理特定版本的头部。

85
00:05:33,090 --> 00:05:35,970
现在我们可以计算两个数字。

86
00:05:35,970 --> 00:05:40,020
眼睛的平均回报和置信区间。

87
00:05:40,020 --> 00:05:43,550
因此，让我们从第一个数字开始，第一个数字是平均单词。

88
00:05:43,680 --> 00:05:49,780
因此，在这里我们称之为平均奖励，即等于和平均。

89
00:05:50,070 --> 00:05:50,340
好吧。

90
00:05:50,350 --> 00:05:57,820
那么它说的是什么呢？这是我要四舍五入的除法词的总和

91
00:05:57,820 --> 00:06:04,530
根据这个广告被选中的次数，让我们写这个公式

92
00:06:04,540 --> 00:06:07,090
我们已经有了这两个变量。

93
00:06:07,090 --> 00:06:12,880
好吧，我们有矢量，但是我们当然会取这两个矢量的冰元素，因为它们

94
00:06:12,880 --> 00:06:16,660
对应于我们的广告版本。

95
00:06:16,660 --> 00:06:29,020
因此，让我们将其作为奖励总和，我们将这个部门的要素除以选择数

96
00:06:29,890 --> 00:06:33,860
同样，我们正在使用此向量的ice元素。

97
00:06:33,910 --> 00:06:34,460
大。

98
00:06:34,480 --> 00:06:38,420
因此，我们有第一个数字来计算平均单词。

99
00:06:38,470 --> 00:06:40,540
现在让我们处理第二个数字。

100
00:06:40,540 --> 00:06:46,660
置信区间好吧，我们不会建立将要正确计算的整个置信区间

101
00:06:46,660 --> 00:06:52,330
现在是置信区间的上限，因为这是我们可能要做的第3步

102
00:06:52,330 --> 00:06:52,870
看到。

103
00:06:52,870 --> 00:06:57,160
第三步，我们选择具有最高置信度的ADD。

104
00:06:57,170 --> 00:07:01,480
因此，我们只需要此置信区间的置信上限。

105
00:07:01,480 --> 00:07:03,510
那么这个最高置信度范围是多少。

106
00:07:03,580 --> 00:07:10,720
好吧，它是平均奖励加增量I和增量Delta，它由此公式给出。

107
00:07:10,930 --> 00:07:19,810
它是1.5 LUGG的平方根，然后除以结束次数，即结束次数I

108
00:07:19,810 --> 00:07:21,260
被选为四舍五入。

109
00:07:21,260 --> 00:07:26,590
因此，让我们先计算此增量，然后再计算上限置信度。

110
00:07:26,860 --> 00:07:31,360
因此，Delta会将其实际称为Delta下划线I。

111
00:07:31,570 --> 00:07:36,420
因此，它等于平方根，我称之为s q r t。

112
00:07:36,520 --> 00:07:42,550
但是实际上我们在这里得到警告，因为它说s q r t是一个未定义的名称，

113
00:07:42,550 --> 00:07:48,470
因为我们需要导入数学库才能在此处获得平方根函数。

114
00:07:48,670 --> 00:07:51,600
因此，我们需要在此处添加数学起点。

115
00:07:51,820 --> 00:07:56,380
而且，我们还需要在此处输入数学库。

116
00:07:56,470 --> 00:07:58,690
导入数学。

117
00:07:58,690 --> 00:07:59,430
好吧。

118
00:07:59,530 --> 00:08:00,580
很好。

119
00:08:00,580 --> 00:08:04,960
现在我们有了平方根函数，警告就消失了。

120
00:08:04,960 --> 00:08:07,340
现在让我们继续公式。

121
00:08:07,450 --> 00:08:09,350
括号在这里。

122
00:08:09,580 --> 00:08:10,940
好，那么我们首先要拥有什么。

123
00:08:10,960 --> 00:08:16,860
我们将这三除以10，然后取二。

124
00:08:17,050 --> 00:08:28,990
所以在这里，LUGG我们除以广告PI的选择次数即次数

125
00:08:29,140 --> 00:08:33,030
这次广告被我选中了。

126
00:08:33,330 --> 00:08:36,660
好的，这样很好，但是我们再次在这里得到警告。

127
00:08:36,710 --> 00:08:40,920
完全出于与平方根相同的原因，未定义的命名LUGG。

128
00:08:41,170 --> 00:08:45,850
我们需要在这里学习数学库。

129
00:08:46,120 --> 00:08:47,410
事实并非如此。

130
00:08:47,410 --> 00:08:50,130
您能猜出我们在这里还需要做什么。

131
00:08:50,140 --> 00:08:56,410
这是Python中的常见陷阱，并且与Python中的索引从零开始的事实有关。

132
00:08:56,590 --> 00:09:03,220
所以我知道这是公式，并且幻灯片给出了LOEG，这实际上是因为该公式考虑了

133
00:09:03,220 --> 00:09:06,070
第一轮从1开始

134
00:09:06,310 --> 00:09:09,660
但是在Python索引中不是这种情况，并且Python以0开始。

135
00:09:09,820 --> 00:09:14,160
如您所见，第一轮不是一个而是零。

136
00:09:14,470 --> 00:09:16,770
因此，您认为这里会做什么。

137
00:09:17,020 --> 00:09:24,010
好吧，我们需要在这里加1，因为这样锁定函数中变量的第一个值

138
00:09:24,010 --> 00:09:29,820
这是从1开始的0，再加上一个从1开始的数字，应该是1。

139
00:09:29,950 --> 00:09:32,940
这正是算法中所期望的。

140
00:09:33,310 --> 00:09:39,970
对Delta来说太好了，Delta已准备就绪，因此现在我们可以计算出最高置信度

141
00:09:39,980 --> 00:09:44,620
边界，这是此UCB算法的本质。

142
00:09:44,620 --> 00:09:53,350
因此，让我们计算UCD，并将其称为上限，即上限等于平均值

143
00:09:53,350 --> 00:09:54,100
奖励。

144
00:09:56,970 --> 00:09:59,910
加三角洲。

145
00:10:00,150 --> 00:10:01,710
就像幻灯片中的一样。

146
00:10:01,980 --> 00:10:03,030
好的，太好了。

147
00:10:03,030 --> 00:10:09,190
我们只是计算了平均奖励和上限，因此我们完成了步骤2。

148
00:10:09,360 --> 00:10:11,460
现在，让我们继续第三步。

149
00:10:11,550 --> 00:10:18,450
第三步是选择添加具有最大上限的广告I。

150
00:10:18,450 --> 00:10:25,080
所以现在事情变得有点复杂了，因为我们需要实际创建一个向量

151
00:10:25,080 --> 00:10:31,720
就像一个巨大的列表，其中将包含在每一轮中选择的不同版本的ADD。

152
00:10:31,830 --> 00:10:33,320
因此，让我们这样做。

153
00:10:33,320 --> 00:10:39,690
我们将在这里声明一个新变量，我们将调用选中的下划线，

154
00:10:39,690 --> 00:10:45,330
变量将成为巨大的向量，它将为我们提供所有不同版本的列表

155
00:10:45,330 --> 00:10:47,540
在每个前面选择的广告。

156
00:10:47,540 --> 00:10:53,250
也就是说，在算法运行结束时，您知道选择的ADD将是10000的向量

157
00:10:53,310 --> 00:10:58,180
元素以及这些元素中的每一个都是在每一轮中选择的广告。

158
00:10:58,350 --> 00:11:02,070
因此，我们将清楚地看到该算法使用的策略的结果。

159
00:11:02,330 --> 00:11:02,830
好。

160
00:11:02,970 --> 00:11:11,400
因此，像往常一样，我们需要对此进行初始化，而只是将其初始化为NMT向量，因为

161
00:11:11,760 --> 00:11:18,230
接下来我们要做的是将不同的广告一一附加到最后一轮10000。

162
00:11:18,530 --> 00:11:19,120
好。

163
00:11:19,230 --> 00:11:25,170
所以现在的问题是，我们如何在选定的位置添加add的不同版本

164
00:11:25,410 --> 00:11:26,140
向量。

165
00:11:26,430 --> 00:11:28,670
好吧，让我们回到幻灯片。

166
00:11:28,680 --> 00:11:34,310
第三步，我们选择ADD的最大置信上限。

167
00:11:34,350 --> 00:11:37,150
因此，我们已经计算出了置信区间的上限。

168
00:11:37,350 --> 00:11:42,600
现在我们需要创建另一个变量，该变量将是最高置信度上限，因为

169
00:11:42,600 --> 00:11:48,300
现在，这个上限变量只是每个ADD转换的上限

170
00:11:48,480 --> 00:11:49,880
在圆端。

171
00:11:50,070 --> 00:11:55,890
因此，这就是为什么我们需要创建另一个变量，该变量将采用这些上限的最大值

172
00:11:55,890 --> 00:11:57,800
这十个加法轮次。

173
00:11:57,800 --> 00:12:03,360
因此，让我们创建此新变量，然后将其称为Max上限。

174
00:12:03,360 --> 00:12:07,930
因此，由于这种零散的变量在每一轮中都会有所不同。

175
00:12:08,130 --> 00:12:11,330
好吧，我们需要在每个新回合中将其初始化。

176
00:12:11,400 --> 00:12:16,710
因此，此无效的Max上限将在​​此处初始化。

177
00:12:16,710 --> 00:12:23,660
因此，我们将将此Max上限变量初始化为零。

178
00:12:23,760 --> 00:12:29,100
然后发生的是，我们将计算10个x的每个的差异上限，然后

179
00:12:29,100 --> 00:12:35,090
我们将把这些上限与这个最大值比较一个问题，每次在这里将眼睛的上限

180
00:12:35,310 --> 00:12:37,270
将高于最大上限。

181
00:12:37,380 --> 00:12:40,760
然后我们将最大上限设置为等于两个上限。

182
00:12:40,770 --> 00:12:41,930
这就是想法。

183
00:12:41,940 --> 00:12:43,320
所以，现在就开始做吧。

184
00:12:44,110 --> 00:12:50,800
所以基本上，我们要做的是在此for循环中，我们需要添加一个新的IF条件，

185
00:12:50,800 --> 00:12:57,250
条件将是如果上限大于最大上限。

186
00:12:57,550 --> 00:13:01,560
然后，如果上限大于最大上限会发生什么。

187
00:13:01,630 --> 00:13:07,460
然后，我们需要将最大上限设置为等于上限。

188
00:13:07,480 --> 00:13:12,460
这样您就知道将要发生的事将计算出10个中的每个的不同上限

189
00:13:12,570 --> 00:13:13,650
因为那是圆的。

190
00:13:13,660 --> 00:13:17,110
乍一看，这点启示等于零。

191
00:13:17,140 --> 00:13:18,810
然后我们计算第一个上限。

192
00:13:18,820 --> 00:13:23,410
当然，它将大于Max的反弹，因为它等于零。

193
00:13:23,680 --> 00:13:26,240
因此，下一轮至尊回合将等于上限。

194
00:13:26,350 --> 00:13:31,270
所以这是上半年的内容，然后我们将计算其他广告的其他上限。

195
00:13:31,390 --> 00:13:36,670
每次我们发现下一个上限大于最大上限的边界数量为

196
00:13:36,670 --> 00:13:39,120
等于这个新的上限。

197
00:13:39,370 --> 00:13:40,060
好吧。

198
00:13:40,240 --> 00:13:46,600
这样，我们将在此特定回合中获得10个加法的不同上限的最大值。

199
00:13:46,620 --> 00:13:52,780
好的，现在我们需要做一件事，您知道我们需要选择具有最高值的ADD

200
00:13:52,780 --> 00:13:59,350
上限，因此每次我们发现此上限大于预弯曲的最大值时，

201
00:13:59,350 --> 00:14:05,470
不仅我们需要这样做以保持最大反弹，而且还需要跟踪具有

202
00:14:05,470 --> 00:14:08,050
最大反弹并跟踪该指数。

203
00:14:08,050 --> 00:14:15,190
我们需要在这里创建一个新变量，我们将其称为add并将其相等

204
00:14:15,190 --> 00:14:16,370
给我

205
00:14:16,480 --> 00:14:22,660
因为现在我们正在处理一个特定的广告，因为我们对此特别关注

206
00:14:22,660 --> 00:14:23,310
这里。

207
00:14:23,320 --> 00:14:27,350
因此，我听说有一个与特定广告对应的特定值。

208
00:14:27,610 --> 00:14:33,040
因此，每当我们发现一个大于

209
00:14:33,040 --> 00:14:36,940
最高或预先禁止成为新的最高或反弹。

210
00:14:37,210 --> 00:14:37,710
好吧。

211
00:14:37,780 --> 00:14:44,400
很好，但是您知道我们在这里使用新变量时，对其进行初始化总是很重要的。

212
00:14:44,500 --> 00:14:46,950
这就是我们现在要做的。

213
00:14:47,020 --> 00:14:49,050
初始化此添加变量。

214
00:14:49,120 --> 00:14:54,860
并且由于ADD存储的索引为0，我们会将其初始化为零。

215
00:14:55,360 --> 00:14:55,680
好。

216
00:14:55,690 --> 00:14:57,110
所以我们越来越近了。

217
00:14:57,130 --> 00:15:00,820
现在，我们需要做的是处理初始条件。

218
00:15:00,850 --> 00:15:05,730
那就是在零回合发生的事情，因为那是在那回合发生的事情。

219
00:15:05,770 --> 00:15:11,260
而且您知道这是全面发生的策略，但实际上并非如此

220
00:15:11,260 --> 00:15:16,630
一开始是因为您一开始就知道在前十轮中我们没有太多信息

221
00:15:16,630 --> 00:15:17,160
广告。

222
00:15:17,200 --> 00:15:22,960
关于他们的奖励，我们没有太多信息，无论他们获得的奖励等于1还是等于

223
00:15:22,960 --> 00:15:23,620
零。

224
00:15:23,620 --> 00:15:27,210
当我们选择它们的时候，因为我们还没有选择它们。

225
00:15:27,430 --> 00:15:33,790
因此，这就是为什么我们需要处理选择的初始条件的原因

226
00:15:33,790 --> 00:15:34,980
前十轮比赛。

227
00:15:35,080 --> 00:15:40,570
因此根据您的实际情况，将字符串选择为10轮的策略是什么

228
00:15:40,570 --> 00:15:42,210
我们没有任何信息。

229
00:15:42,400 --> 00:15:44,920
好吧，实际上没有策略。

230
00:15:44,980 --> 00:15:48,950
我们将只选择前10个广告，而不使用此处的策略。

231
00:15:49,000 --> 00:15:54,930
在获得10个广告中每一个的奖励信息后，我们将立即使用此策略。

232
00:15:54,940 --> 00:16:01,600
因此，基本上，我们在前10个回合中要做的就是简单地选择要投放的前10个广告

233
00:16:01,600 --> 00:16:08,320
一个会选择“添加一回合”，谁会选择运行三回合则选择“三回合”，最多约10个。

234
00:16:08,320 --> 00:16:14,680
我们将在10点进行选择，然后将为您提供一些有关您知道选择次数的信息

235
00:16:14,830 --> 00:16:16,780
10个中的每一个也是如此。

236
00:16:16,830 --> 00:16:22,840
在11点左右，选择的数量将是10个广告中的每一个，我们还将获得一些信息

237
00:16:22,840 --> 00:16:28,440
关于某些单词，其中某些单词将包含与广告对应的零

238
00:16:28,440 --> 00:16:34,450
在第一轮中被选中的广告或与

239
00:16:34,450 --> 00:16:38,110
在前10轮中被选中时，可获得一次奖励。

240
00:16:38,140 --> 00:16:44,740
因此，现在就开始做吧，让我们在前10个回合中，简单地选择三个或三个，最多十个，然后

241
00:16:44,830 --> 00:16:53,650
让我们使用该策略，以便执行此操作，我们将在此处添加if条件，如果条件为

242
00:16:53,770 --> 00:16:59,860
选择II在列中大于零。

243
00:16:59,860 --> 00:17:06,580
因此，这意味着如果至少选择一次我的版本，那么我们将使用此策略，并且实际上

244
00:17:06,850 --> 00:17:08,740
我们需要对此进行调整。

245
00:17:08,890 --> 00:17:14,390
因此，现在由于这种情况，该策略将在前10轮之后应用。

246
00:17:14,610 --> 00:17:15,250
好。

247
00:17:15,400 --> 00:17:20,890
现在我们只需要添加一些内容以确保算法选择了

248
00:17:20,890 --> 00:17:30,250
在前十轮比赛中，每三场比赛最多10场比赛，最高的是10点，这样做的诀窍是在此处添加其他

249
00:17:31,030 --> 00:17:38,700
然后调用然后我们将上限设置为一个非常大的值，如10

250
00:17:38,860 --> 00:17:40,470
和电源400。

251
00:17:40,840 --> 00:17:45,210
因此，要获得此值，我们可以使用四百之一。

252
00:17:45,380 --> 00:17:47,870
那就是400的幂的10。

253
00:17:48,230 --> 00:17:50,470
所以现在我想给你一点谜。

254
00:17:50,660 --> 00:17:54,290
我希望您弄清楚为什么我们要使用此大型事件。

255
00:17:54,290 --> 00:17:59,120
在else条件下，您可以在此处为上限打开400的幂。

256
00:17:59,120 --> 00:18:00,230
尝试找出原因。

257
00:18:00,230 --> 00:18:02,740
尝试弄清楚它将如何有用。

258
00:18:02,750 --> 00:18:03,720
我们想要什么。

259
00:18:03,950 --> 00:18:08,970
现在在下一个教程中给您答案和解释，然后再学习机器

260
00:18:08,980 --> 00:18:09,410
学习

