1
00:00:00,330 --> 00:00:02,520
您好，欢迎来到本美术教程。

2
00:00:02,580 --> 00:00:07,620
因此，在上一个教程中，我们导入了数据集，而今天，在本教程中，我们将实现

3
00:00:07,740 --> 00:00:10,940
UCB上会议上限算法。

4
00:00:11,100 --> 00:00:16,770
因此，我不确定这是个坏消息还是个好消息，但是实际上没有可以轻松使用的软件包

5
00:00:16,770 --> 00:00:19,700
以实现此UCB算法。

6
00:00:19,980 --> 00:00:21,360
因此，这是个坏消息。

7
00:00:21,360 --> 00:00:27,360
但是好消息是我们将从头开始实施UCB，这是一个好消息，因为

8
00:00:27,360 --> 00:00:31,490
这将使您有机会真正提高我们的技能。

9
00:00:31,860 --> 00:00:33,310
所以准备好

10
00:00:33,330 --> 00:00:38,490
在实现之前，不需要花三到四行像以前那样

11
00:00:38,490 --> 00:00:42,220
整个算法从零开始，无需使用任何程序包。

12
00:00:42,390 --> 00:00:44,600
我们将逐步进行。

13
00:00:44,610 --> 00:00:50,930
说到步骤，现在让我们跳到高可信度找到算法的幻灯片。

14
00:00:51,030 --> 00:00:53,970
因此，该算法需要三个步骤。

15
00:00:54,030 --> 00:00:59,760
第一步是每个回合，每个加法考虑两个数字。

16
00:00:59,910 --> 00:01:06,830
也就是说，对于每个版本的广告，这两个数字都是I，是我被选中的广告的次数

17
00:01:06,840 --> 00:01:11,970
最多一轮，与归并的奖励总和我有两轮。

18
00:01:12,200 --> 00:01:12,520
好。

19
00:01:12,540 --> 00:01:18,150
所以我们要做的第一件事是声明这两个变量，因为我们将需要它们

20
00:01:18,180 --> 00:01:18,860
然后。

21
00:01:18,980 --> 00:01:19,260
好。

22
00:01:19,260 --> 00:01:26,370
所以第一个是我被选择四舍五入的次数，实际上我们称这个变量为

23
00:01:26,700 --> 00:01:31,470
选择数量。

24
00:01:31,600 --> 00:01:32,190
好吧。

25
00:01:32,520 --> 00:01:35,530
因此，我们需要考虑每个数字。

26
00:01:35,700 --> 00:01:41,910
因此，我们要做的是创建一个向量，其中将包含每个数量的选择

27
00:01:42,000 --> 00:01:42,770
每个添加。

28
00:01:42,840 --> 00:01:49,080
因此，我们将将此变量设置为等于大小为D的向量，并初始化的所有分量。

29
00:01:49,080 --> 00:01:50,850
此向量为零。

30
00:01:51,160 --> 00:01:53,030
因此，我们如何才能做到这一点。

31
00:01:53,250 --> 00:01:58,350
好吧，我们只需要在括号D中键入整数即可。

32
00:01:58,860 --> 00:02:05,400
这将创建一个仅包含零的大小为D的向量，我们这样做是因为

33
00:02:05,540 --> 00:02:09,360
在第一轮中，尚未选择广告的每个版本。

34
00:02:09,420 --> 00:02:13,950
因此，选择专辑的每个版本的次数当然为零。

35
00:02:14,160 --> 00:02:16,080
好的，第一个数字已完成。

36
00:02:16,080 --> 00:02:16,410
好吧。

37
00:02:16,410 --> 00:02:21,750
第二个数字是合计和的奖励总和。

38
00:02:21,960 --> 00:02:31,850
好吧，让我们这样称呼这个可变的奖励之子，同样，您知道我们需要取

39
00:02:31,860 --> 00:02:34,670
试用中每个广告版本的奖励。

40
00:02:34,700 --> 00:02:39,800
因此，我们将其设置为组件的向量，就像我们对数量为

41
00:02:39,800 --> 00:02:43,410
选择和相同，我们将其初始化为零。

42
00:02:43,430 --> 00:02:49,560
当然，由于在第一轮中，奖励的儿子是广告的每个版本，当然都是零。

43
00:02:49,730 --> 00:02:54,640
因此，我们将复制此副本并将其粘贴到此处。

44
00:02:54,680 --> 00:02:55,190
好吧。

45
00:02:55,190 --> 00:02:58,030
所以基本上第一步就完成了。

46
00:02:58,040 --> 00:02:59,920
现在，我们继续第二步。

47
00:03:00,050 --> 00:03:03,050
第二步来自这两个数字。

48
00:03:03,050 --> 00:03:08,540
我们首先计算到和周围的平均眼睛奖励。

49
00:03:08,810 --> 00:03:12,860
其次是置信区间。

50
00:03:12,860 --> 00:03:17,420
因此，基本上我们需要在每个回合中计算这两个数字。

51
00:03:17,450 --> 00:03:23,250
因此，让我们执行第二步，因为我们需要在每个回合中计算这两个数字。

52
00:03:23,250 --> 00:03:27,160
当然，我们需要做的是创建一个for循环。

53
00:03:27,370 --> 00:03:29,500
好的，这就是我们要做的。

54
00:03:29,530 --> 00:03:35,570
我们将经历从0到10000的所有回合。

55
00:03:35,600 --> 00:03:37,530
所以每一轮。

56
00:03:37,560 --> 00:03:39,250
因此，我们正在召集回合。

57
00:03:39,310 --> 00:03:44,230
然后，我们需要输入下限1。

58
00:03:44,360 --> 00:03:45,760
这是第一轮。

59
00:03:45,920 --> 00:03:47,780
然后是上限。

60
00:03:48,020 --> 00:03:55,880
因此，总回合数为10000回合，所以如果您有更多问题

61
00:03:55,880 --> 00:04:03,800
回合或更多用户，我们将知道您在此处声明此变量，并在此等于我们的问题

62
00:04:03,800 --> 00:04:05,680
一万。

63
00:04:05,960 --> 00:04:07,170
好的10000。

64
00:04:07,190 --> 00:04:08,950
所以现在我们处于循环中。

65
00:04:09,050 --> 00:04:10,590
因此，我们需要做什么。

66
00:04:10,880 --> 00:04:14,810
我们需要平均计算每个版本的。

67
00:04:14,900 --> 00:04:16,490
和置信区间。

68
00:04:16,580 --> 00:04:18,390
所以这正是我们要做的。

69
00:04:18,410 --> 00:04:24,740
由于我们正在针对每个广告版本进行操作，因此我现在需要做的另一件事是

70
00:04:24,740 --> 00:04:30,070
循环，这次我们将循环播放所有10个不同版本的广告。

71
00:04:30,230 --> 00:04:32,390
因此广告被i索引。

72
00:04:32,420 --> 00:04:38,960
因此，对于我来说，我将一遍又一遍地在这里输入D。

73
00:04:39,080 --> 00:04:45,240
如果您有更多版本的ADD或针对特定问题的更多武器。

74
00:04:45,260 --> 00:04:49,720
因此，我们将在此处声明一个新变量D。

75
00:04:49,970 --> 00:04:54,480
由于这是广告数量，因此我们将其设置为10。

76
00:04:54,500 --> 00:05:01,490
好的，现在我们进入第二个循环，所以现在在这个级别上，我们处于特定状态

77
00:05:01,490 --> 00:05:09,140
并处理特定版本的广告，现在我们可以计算出两个数字。

78
00:05:09,140 --> 00:05:13,140
平均眼球和置信区间。

79
00:05:13,190 --> 00:05:16,780
因此，让我们从第一个数字开始，第一个数字是平均单词。

80
00:05:16,820 --> 00:05:21,840
因此，我们称其为平均奖励和均等。

81
00:05:21,920 --> 00:05:22,220
好吧。

82
00:05:22,230 --> 00:05:29,700
那么它说的是什么呢？这是我一直到周围和分裂的广告收益的总和

83
00:05:29,700 --> 00:05:33,740
根据这个广告在附近被选中的次数。

84
00:05:33,750 --> 00:05:36,420
因此，我们简单地编写此公式。

85
00:05:36,420 --> 00:05:43,200
我们已经有两个变量需要矢量，但是我们当然要使用ice元素

86
00:05:43,380 --> 00:05:47,130
这两个向量中的一个，因为它们与我们的版本相对应。

87
00:05:47,140 --> 00:05:48,500
我有添加。

88
00:05:48,540 --> 00:05:58,210
因此，让我们来做它的总和，然后取这个矢量的元素除以数字。

89
00:05:59,920 --> 00:06:05,800
选择和相同，我们采用此向量的元素。

90
00:06:05,800 --> 00:06:06,330
大。

91
00:06:06,340 --> 00:06:10,330
因此，我们有第一个数字来计算平均单词。

92
00:06:10,360 --> 00:06:12,360
现在让我们处理第二个数字。

93
00:06:12,430 --> 00:06:18,550
置信区间好吧，我们不会建立将要正确计算的整个置信区间

94
00:06:18,550 --> 00:06:23,750
现在是置信区间的上限，因为这是我们执行步骤3所需要的。

95
00:06:23,860 --> 00:06:29,530
如您所见，第三步是选择具有最大置信上限的应用程序

96
00:06:29,530 --> 00:06:33,200
需要此置信区间的置信上限。

97
00:06:33,340 --> 00:06:35,380
那么这个最高置信度范围是多少。

98
00:06:35,470 --> 00:06:43,480
好吧，它是平均奖励加delta I和delta，由下式给出它是平方

99
00:06:43,480 --> 00:06:52,910
1.5 LUGG的根，然后除以N，N是我被选择舍入的次数

100
00:06:52,930 --> 00:06:53,280
在。

101
00:06:53,470 --> 00:06:58,690
因此，让我们先计算此增量，然后再计算置信上限。

102
00:06:58,750 --> 00:07:03,280
因此，Delta将在此核心上削减其实际增量。

103
00:07:03,460 --> 00:07:08,300
因此，它等于平方根，我称之为s q r t。

104
00:07:08,380 --> 00:07:09,620
括号在这里。

105
00:07:09,880 --> 00:07:11,200
好，那么我们首先要拥有什么。

106
00:07:11,260 --> 00:07:17,160
我们将这三除以10，然后取二。

107
00:07:17,350 --> 00:07:28,270
因此，请在此处登录，然后我们将除数plie的选择数除以

108
00:07:28,270 --> 00:07:32,830
多次被选中，我被拒之门外。

109
00:07:33,220 --> 00:07:39,870
对Delta来说太好了，Delta已准备就绪，因此现在我们可以计算出最高置信度

110
00:07:39,940 --> 00:07:44,500
边界，这是此UCB算法的本质。

111
00:07:44,530 --> 00:07:53,230
因此，让我们计算UCD，并将其称为上限，即上限等于平均值

112
00:07:53,230 --> 00:07:53,830
奖励

113
00:07:56,870 --> 00:07:59,790
加三角洲。

114
00:08:00,050 --> 00:08:01,610
就像幻灯片中的一样。

115
00:08:01,880 --> 00:08:02,930
好的，太好了。

116
00:08:02,930 --> 00:08:09,090
我们只是计算了平均奖励和上限，因此我们完成了步骤2。

117
00:08:09,260 --> 00:08:11,360
现在，让我们继续第三步。

118
00:08:11,450 --> 00:08:18,350
第三步是选择添加具有最大上限的广告I。

119
00:08:18,350 --> 00:08:24,980
所以现在事情变得有点复杂了，因为我们需要实际创建一个向量

120
00:08:24,980 --> 00:08:31,630
就像一个巨大的列表，其中将包含在每一轮中选择的不同版本的ADD。

121
00:08:31,730 --> 00:08:33,170
因此，让我们这样做。

122
00:08:33,220 --> 00:08:39,590
我们将在这里声明一个新变量，我们将调用选中的下划线，

123
00:08:39,590 --> 00:08:45,230
变量将成为巨大的向量，它将为我们提供所有不同版本的列表

124
00:08:45,230 --> 00:08:47,430
在每个前面选择的广告。

125
00:08:47,440 --> 00:08:53,150
也就是说，在算法运行结束时，您知道选择的ADD将是10000的向量

126
00:08:53,210 --> 00:08:58,170
元素以及这些元素中的每一个都是在每一轮中选择的广告。

127
00:08:58,250 --> 00:09:01,970
因此，我们将清楚地看到该算法使用的策略的结果。

128
00:09:02,230 --> 00:09:02,740
好。

129
00:09:02,870 --> 00:09:10,700
因此，像往常一样，我们需要对此进行初始化，而只是将其初始化为NMT向量，因为

130
00:09:11,060 --> 00:09:17,530
接下来我们要做的是将不同的广告一一附加到最后一轮10000。

131
00:09:17,880 --> 00:09:24,470
好的，所以现在的问题是，我们如何在选定的位置添加add的不同版本

132
00:09:24,710 --> 00:09:25,440
向量。

133
00:09:25,730 --> 00:09:27,970
好吧，让我们回到幻灯片。

134
00:09:27,980 --> 00:09:33,620
第三步，我们选择ADD的最大置信上限。

135
00:09:33,650 --> 00:09:36,460
因此，我们已经计算了前提条件的界限。

136
00:09:36,650 --> 00:09:41,900
现在我们需要创建另一个变量，该变量将是最高置信度上限，因为

137
00:09:41,900 --> 00:09:47,600
现在，这个上限变量只是每个ADD转换的上限

138
00:09:47,780 --> 00:09:49,170
在圆端。

139
00:09:49,370 --> 00:09:55,190
因此，这就是为什么我们需要创建另一个变量，该变量将采用这些上限的最大值

140
00:09:55,190 --> 00:09:57,050
这十个加法轮次。

141
00:09:57,050 --> 00:10:02,660
因此，让我们创建此新变量，然后将其称为Max上限。

142
00:10:02,660 --> 00:10:07,230
因此，由于这种零散的变量在每一轮中都会有所不同。

143
00:10:07,430 --> 00:10:10,630
好吧，我们需要在每个新回合中将其初始化。

144
00:10:10,700 --> 00:10:15,970
因此，此无效的Max上限将在​​此处初始化。

145
00:10:16,010 --> 00:10:22,450
因此，我们将将此Max上限变量初始化为零。

146
00:10:22,550 --> 00:10:27,740
然后发生的是，我们将计算10个加法和

147
00:10:27,740 --> 00:10:31,160
然后我们将这些上限与该上限进行比较。

148
00:10:31,280 --> 00:10:35,990
而且，每次我听到的广告上限都会高于最大上限。

149
00:10:36,170 --> 00:10:39,410
然后我们将最大上限设置为等于两个上限。

150
00:10:39,560 --> 00:10:40,680
这就是想法。

151
00:10:40,760 --> 00:10:42,160
所以，现在就开始做吧。

152
00:10:42,910 --> 00:10:49,600
所以基本上，我们要做的是在此for循环中，我们需要添加一个新的IF条件，

153
00:10:49,600 --> 00:10:55,750
条件将是如果上限大于最大上限。

154
00:10:55,750 --> 00:10:59,830
然后，如果上限大于最大上限会发生什么。

155
00:10:59,830 --> 00:11:04,950
然后，我们需要将最大上限设置为等于上限。

156
00:11:04,990 --> 00:11:09,610
这样，您知道会发生什么，我们将计算每个

157
00:11:09,610 --> 00:11:11,130
10加圆。

158
00:11:11,170 --> 00:11:14,530
乍一看，这点启示等于零。

159
00:11:14,620 --> 00:11:16,300
然后我们计算第一个上限。

160
00:11:16,300 --> 00:11:20,920
当然，它会大于回弹最大值，因为它等于零。

161
00:11:21,190 --> 00:11:23,740
因此，下一个上限将等于上限。

162
00:11:23,860 --> 00:11:28,810
因此，这是第一次添加，然后我们将计算其他广告的其他上限。

163
00:11:28,900 --> 00:11:34,190
每次我们找到一个大于下一个上限的上限，该上限将大于max或pre-ban

164
00:11:34,190 --> 00:11:36,880
等于这个新的上限。

165
00:11:36,880 --> 00:11:37,550
好吧。

166
00:11:37,750 --> 00:11:44,120
这样，我们将在特定回合中获得10 x的不同上限的最大值。

167
00:11:44,150 --> 00:11:50,260
好的，现在我们需要做一件事，您知道我们需要选择具有最高值的ADD

168
00:11:50,260 --> 00:11:56,480
上限，因此每次我们发现该上限大于最大上限时。

169
00:11:56,620 --> 00:12:02,800
我们不仅需要这样做以保持最大反弹，还需要跟踪该指数。

170
00:12:02,800 --> 00:12:05,500
具有最大的反弹并跟踪该指数。

171
00:12:05,560 --> 00:12:12,700
我们需要在这里创建一个新变量，我们将其称为add并将其相等

172
00:12:12,700 --> 00:12:13,880
给我

173
00:12:13,990 --> 00:12:20,170
因为现在我们正在处理一个特定的广告，因为我们对此特别关注

174
00:12:20,170 --> 00:12:20,820
这里。

175
00:12:20,820 --> 00:12:26,410
因此，我听说有一个与特定广告对应的特定值，因此我们需要跟踪

176
00:12:26,410 --> 00:12:32,500
每次我们找到另一个大于最大值的波段时，这个特定的相加或我们必然会变成

177
00:12:32,770 --> 00:12:34,440
这个新的反弹最大值。

178
00:12:34,720 --> 00:12:35,260
好吧。

179
00:12:35,260 --> 00:12:36,160
太好了。

180
00:12:36,220 --> 00:12:41,960
但是您知道，当我们在此处使用新变量时，对其进行初始化总是很重要的。

181
00:12:41,980 --> 00:12:44,080
这就是我们现在要做的。

182
00:12:44,080 --> 00:12:46,650
我们将其初始化为变量。

183
00:12:46,660 --> 00:12:49,420
我们将其初始化为零。

184
00:12:49,830 --> 00:12:50,190
好。

185
00:12:50,200 --> 00:12:51,510
所以我们越来越近了。

186
00:12:51,610 --> 00:12:57,890
现在，我们需要做的是处理初始条件，因为这是该回合发生的情况。

187
00:12:57,940 --> 00:13:03,430
而且您知道这是全面发生的策略，但实际上并非如此

188
00:13:03,430 --> 00:13:08,790
一开始是因为您一开始就知道在前十轮中我们没有太多信息

189
00:13:08,890 --> 00:13:09,340
然而。

190
00:13:09,370 --> 00:13:15,130
关于他们的奖励，我们没有太多信息，无论他们获得的奖励等于1还是等于

191
00:13:15,130 --> 00:13:15,760
零。

192
00:13:15,790 --> 00:13:19,380
当我们选择它们的时候，因为我们还没有选择它们。

193
00:13:19,600 --> 00:13:25,960
因此，这就是为什么我们需要处理选择的初始条件的原因

194
00:13:25,960 --> 00:13:27,140
前十轮比赛。

195
00:13:27,250 --> 00:13:32,650
因此，根据您的实际情况，根据您的选择，将星号选择为10发的策略是什么

196
00:13:32,650 --> 00:13:34,380
我们没有任何信息。

197
00:13:34,570 --> 00:13:37,070
好吧，实际上没有策略。

198
00:13:37,150 --> 00:13:41,140
我们将只选择前10个广告，而不使用此处的策略。

199
00:13:41,140 --> 00:13:47,110
在获得10个广告中每一个的奖励信息后，我们将立即使用此策略。

200
00:13:47,110 --> 00:13:53,290
因此，基本上，我们在前10个回合中要做的就是简单地选择前10个

201
00:13:53,500 --> 00:14:00,390
跑一会选择加一回合将选择跑三回合。我们将选择3，直到大约10。

202
00:14:00,400 --> 00:14:06,850
我们将在10点进行选择，然后将为您提供一些有关您知道选择次数的信息

203
00:14:07,000 --> 00:14:08,970
10个中的每一个也是如此。

204
00:14:08,990 --> 00:14:14,950
那是第11轮，选择的数量将是10个中的每个的一个，我们还将获得一些信息

205
00:14:15,010 --> 00:14:20,650
关于您的某些单词将包含对应于go的零的奖励总和

206
00:14:20,710 --> 00:14:26,620
在第一轮中被选中的广告或与

207
00:14:26,620 --> 00:14:30,110
在前10轮中被选中时，可获得一次奖励。

208
00:14:30,310 --> 00:14:37,360
因此，现在就开始吧，我们在前十轮比赛中简单地选择一，二，三，最多10个，然后

209
00:14:37,360 --> 00:14:47,010
使用策略，以便执行此操作，我们将在此处添加if条件，即条件是选择的数量

210
00:14:47,500 --> 00:14:50,780
by大于零。

211
00:14:51,010 --> 00:14:57,730
因此，这意味着如果至少选择一次我的版本，那么我们将使用此策略，并且实际上

212
00:14:57,970 --> 00:14:59,970
我们需要对此进行调整。

213
00:15:00,060 --> 00:15:05,520
因此，现在由于这种情况，该策略将在前10轮之后应用。

214
00:15:05,740 --> 00:15:06,400
好。

215
00:15:06,520 --> 00:15:12,470
现在我们只需要添加一些内容，以确保算法选择了一个或两个

216
00:15:12,480 --> 00:15:14,930
在首轮第十轮中三比十。

217
00:15:15,100 --> 00:15:25,720
为此，窍门是在其他地方添加else，然后将上限设置为

218
00:15:25,720 --> 00:15:28,250
像10这样的大价值。

219
00:15:28,390 --> 00:15:30,260
和400的力量。

220
00:15:30,370 --> 00:15:37,390
因此，要获得此值，我们可以使用三四百，即10等于400的幂。

221
00:15:37,750 --> 00:15:40,090
所以现在我想给你一点谜。

222
00:15:40,180 --> 00:15:46,240
我想请您弄清楚为什么我们要使用这个很大的值，而您将400的幂设为

223
00:15:46,240 --> 00:15:52,180
在else条件下的上限尝试找出为什么试图找出它将如何有用

224
00:15:52,180 --> 00:15:53,270
为了我们想要的

225
00:15:53,470 --> 00:15:57,040
现在，您可以在Torro旁边的目录中找到答案和解释。

226
00:15:57,280 --> 00:15:58,950
在那之前享受机器学习

