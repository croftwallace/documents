1
00:00:00,300 --> 00:00:05,560
您好，欢迎使用Embree中的Python教程使用我们已经实现了倍数的方法

2
00:00:05,570 --> 00:00:09,080
在我们的回归模型中，我们适合训练集。

3
00:00:09,360 --> 00:00:14,340
但是，当我们退后一步时，您认为这实际上是我们可以使用

4
00:00:14,340 --> 00:00:15,770
我们这里的数据集。

5
00:00:15,900 --> 00:00:21,250
您知道，因为在构建此模型时，实际上使用了所有自变量。

6
00:00:21,420 --> 00:00:26,610
但是，如果这些自变量中有一些在统计上具有高度意义

7
00:00:26,790 --> 00:00:34,050
对因变量利润产生重大影响或影响，而一些在统计上没有

8
00:00:34,050 --> 00:00:35,300
意义重大。

9
00:00:35,310 --> 00:00:41,610
这意味着，如果我们从道德世界中删除这些非统计学意义的变量，我们将

10
00:00:41,610 --> 00:00:44,040
仍然得到一些惊人的预测。

11
00:00:44,040 --> 00:00:50,610
因此，本教程的目标是实际找到一个最佳的独立变量团队，以便

12
00:00:50,610 --> 00:00:57,750
团队的每个独立变量对辩论变量的利润都有很大影响

13
00:00:57,750 --> 00:01:03,810
团队的自变量是一个有力的预测器，具有很高的统计意义，并且

14
00:01:03,810 --> 00:01:08,820
肯定会对因变量利润产生影响，并且这种影响可能是积极的。

15
00:01:08,940 --> 00:01:12,210
也就是说，自变量增加了1个单位。

16
00:01:12,240 --> 00:01:14,920
利润将增加或可能为负。

17
00:01:14,970 --> 00:01:18,030
也就是说，自变量增加了1个单位。

18
00:01:18,060 --> 00:01:23,790
利润将减少，因此我们将划分构建最佳模型的最后一步

19
00:01:23,790 --> 00:01:29,340
在本教程的第一篇教程中，将向后消除方法分为三篇教程

20
00:01:29,350 --> 00:01:29,500
。

21
00:01:29,640 --> 00:01:34,320
我将引导您完成向后淘汰的准备工作，因为在python中，我们实际上需要

22
00:01:34,320 --> 00:01:37,710
准备一些您将在本教程中看到的特定内容。

23
00:01:37,800 --> 00:01:42,990
然后在第二个教程中，我们将一起开始向后消除而不完成它

24
00:01:43,050 --> 00:01:44,070
直到最后。

25
00:01:44,070 --> 00:01:50,100
这意味着在第二篇教程的最后，您将获得一份作业，其中包括完成

26
00:01:50,220 --> 00:01:52,290
我们从向后淘汰开始。

27
00:01:52,290 --> 00:01:57,030
因此，我相信您不会有任何问题，因为我将引导您逐步了解反向

28
00:01:57,060 --> 00:02:03,040
消除，使您可以了解所有内容并拥有完成作业所需的所有工具。

29
00:02:03,390 --> 00:02:08,010
然后在第三个教程中，我为您提供此作业的解决方案，我们将一起完成

30
00:02:08,010 --> 00:02:09,570
向后淘汰。

31
00:02:09,660 --> 00:02:11,050
所以我希望你很兴奋。

32
00:02:11,130 --> 00:02:12,130
让我们现在开始。

33
00:02:12,150 --> 00:02:14,260
向后淘汰。

34
00:02:14,710 --> 00:02:14,960
好。

35
00:02:14,970 --> 00:02:17,480
因此，让我们开始吧，首先准备我们需要做的事情。

36
00:02:17,480 --> 00:02:24,840
向后消除，因此我们当然将像往常一样需要一个库，它将成为统计数据Morell的

37
00:02:24,960 --> 00:02:31,160
公式API库，它将以M作为统计信息模型的快捷方式进行调用。

38
00:02:31,350 --> 00:02:36,170
然后，我们只需要做一些技巧，以便消除偏僻木材的正常运行，然后我们将

39
00:02:36,170 --> 00:02:37,350
开始走。

40
00:02:37,350 --> 00:02:41,200
因此，让我们先导入所需的库。

41
00:02:41,220 --> 00:02:49,030
因此，导入公式化该API的统计模型。

42
00:02:49,380 --> 00:02:54,840
然后给我们一个快捷方式，因为这是一个长名称，所以我们给S和

43
00:02:54,840 --> 00:02:59,120
静态模型，现在我们几乎准备开始向后层压。

44
00:02:59,130 --> 00:03:05,070
我们只需要在特征矩阵或自变量矩阵中添加一列

45
00:03:05,070 --> 00:03:10,380
了解为什么我们只需要回顾一下回归方程中的倍数

46
00:03:10,770 --> 00:03:15,880
y等于零加b 1 x 1加上B和重音。

47
00:03:16,230 --> 00:03:22,650
好吧，您在此等式中注意到，存在一个常量零，该常量与独立变量无关

48
00:03:22,650 --> 00:03:26,690
变量x就像这里没有0，但实际上是0。

49
00:03:26,790 --> 00:03:30,400
我们可以将x 0与此常数关联为零。

50
00:03:30,510 --> 00:03:32,690
实际上为零等于1。

51
00:03:32,700 --> 00:03:39,270
因此，这意味着如果我们说x 0等于1，则或回归方程中的多极点变为y

52
00:03:39,360 --> 00:03:41,690
等于零零。

53
00:03:41,760 --> 00:03:44,960
另外，我们希望x 1加一个重音。

54
00:03:45,600 --> 00:03:50,730
实际上，我们现在将要使用的统计模型库并未考虑在内

55
00:03:50,970 --> 00:03:53,210
这个BS的零常数。

56
00:03:53,670 --> 00:04:00,660
因此，我们将需要以某种方式将其添加到自变量矩阵中，因为您可以看到我们的

57
00:04:00,660 --> 00:04:06,570
特征X的矩阵，此处仅包含独立变量，例如虚拟变量

58
00:04:06,570 --> 00:04:10,510
适用于adman所在市场营销支出中的州。

59
00:04:10,650 --> 00:04:17,280
在此要素矩阵中以及大多数库（如库）中的任何地方都没有零等于1

60
00:04:17,280 --> 00:04:23,640
我们在这里用来建立线性回归模型的事实肯定包括

61
00:04:23,640 --> 00:04:26,780
常数在回归方程的倍数中为零。

62
00:04:26,970 --> 00:04:33,060
但这实际上不是这个统计模型库的情况，我们将使用它来计算p值

63
00:04:33,210 --> 00:04:37,440
并评估我们自变量的统计意义。

64
00:04:37,590 --> 00:04:43,050
所以这就是为什么我们需要在这里做些什么，而这实际上是添加这一列

65
00:04:43,050 --> 00:04:45,240
在我们的功能矩阵中

66
00:04:45,360 --> 00:04:52,500
因此，我们将在这里使用特征X矩阵，并在此处添加一列对应的特征

67
00:04:52,500 --> 00:04:57,810
等于零等于一个与我们的常数零相关的值。

68
00:04:57,990 --> 00:05:03,120
这就是为什么我们的统计资料Morell的图书馆会理解，将回归方程式乘以

69
00:05:03,120 --> 00:05:08,740
实际上y等于零加上Bubon X1加上b 2 x 2加上仿生。

70
00:05:08,910 --> 00:05:14,370
否则，如果我们没有在X矩阵的此处添加这一列的列，则我们的独立矩阵

71
00:05:14,370 --> 00:05:19,470
该库统计模型的变量会认为我们回归方程中的倍数

72
00:05:19,470 --> 00:05:28,840
如果y等于一个X-1，请设为2 x 2加上b 3 x 3 4 x 4加上5 x 5，而不必保持繁忙的道路

73
00:05:28,830 --> 00:05:29,080
这里。

74
00:05:29,070 --> 00:05:34,710
那就是在回归方程中，没有零以下零以下的分量。

75
00:05:34,750 --> 00:05:41,220
所以这就是为什么现在我们需要在此矩阵的特征矩阵中添加一列

76
00:05:41,230 --> 00:05:41,560
。

77
00:05:41,560 --> 00:05:42,300
因此，让我们这样做。

78
00:05:42,310 --> 00:05:46,360
实际上非常简单，我们只需要一行即可完成此操作。

79
00:05:46,360 --> 00:05:48,170
现在就开始吧。

80
00:05:48,390 --> 00:05:54,630
因此，由于我们要将此处的这一列添加到特征X的矩阵中，因此我们将从

81
00:05:54,730 --> 00:06:02,610
x在这里，然后我们将使用非P的附加函数，它将在我们的列中附加这一列

82
00:06:02,620 --> 00:06:04,180
特征X的矩阵。

83
00:06:04,260 --> 00:06:10,080
因此，让我们执行此操作，我们将在此处调用Dot，然后追加函数。

84
00:06:10,080 --> 00:06:15,590
现在，让我们添加一些括号，然后按下该命令命令控件并检查append函数。

85
00:06:15,750 --> 00:06:18,040
好吧，我们的参数是什么。

86
00:06:18,030 --> 00:06:20,670
第一个参数是我们的四个数组。

87
00:06:20,760 --> 00:06:26,490
因此，这当然是我们要向其中添加此列的数组，因此

88
00:06:26,520 --> 00:06:28,870
这将成为我们特征X的矩阵。

89
00:06:28,890 --> 00:06:34,200
所以这是第一个参数将输入我们的等式x。

90
00:06:34,630 --> 00:06:36,490
OK，然后第二个参数是什么。

91
00:06:36,510 --> 00:06:38,970
第二个参数是值和符号。

92
00:06:39,000 --> 00:06:45,420
当然，这些值都是将两个值加到X X上的值，如您所见，这些值在形状中

93
00:06:45,450 --> 00:06:46,240
数组

94
00:06:46,300 --> 00:06:48,620
这意味着这里的值将是一个数组。

95
00:06:48,940 --> 00:06:53,920
这对我们来说是完美的，因为我们实际上想向x添加一列。

96
00:06:53,940 --> 00:06:57,650
您知道我们将添加一列作为x的第一列。

97
00:06:57,810 --> 00:07:04,710
所以我们要在此处输入的数组将是50行矩阵，因为您可以看到X具有

98
00:07:04,720 --> 00:07:07,820
50条线和一列。

99
00:07:07,930 --> 00:07:14,050
因此，我们需要在一列中添加50行矩阵，且其中仅包含一个值，实际上

100
00:07:14,050 --> 00:07:14,860
一个窍门。

101
00:07:14,860 --> 00:07:20,800
我们可以很快地做到这一点，我们只需要使用另一个函数即可，它不会被调用一次

102
00:07:21,030 --> 00:07:23,520
内部只有一个值的数组。

103
00:07:23,680 --> 00:07:29,260
因此，我们需要指定此数组的行数，即列数。

104
00:07:29,280 --> 00:07:36,330
因此，我们的第二个参数将是值等于，然后从Numby中获取一个函数。

105
00:07:36,430 --> 00:07:43,860
所以我们在这里加上那个在括号里，因为一个有一个函数，然后因为这个函数

106
00:07:43,870 --> 00:07:50,280
一旦返回一个仅包含一个值的矩阵，我们需要指定行数和行数

107
00:07:50,280 --> 00:07:54,900
此函数一次返回的一列矩阵的列数。

108
00:07:55,090 --> 00:08:01,080
如果我们通过检查紧迫的命令控件以及

109
00:08:01,310 --> 00:08:01,790
一世。

110
00:08:01,870 --> 00:08:07,440
好吧，我们在参数中看到，第一个参数是该形状，即矩阵的形状

111
00:08:07,440 --> 00:08:08,890
我们要创建的对象。

112
00:08:08,910 --> 00:08:14,110
如您所见，我们需要这样表达，我们需要在数字内部加上括号

113
00:08:14,110 --> 00:08:16,050
行数和列数。

114
00:08:16,240 --> 00:08:23,580
因此，在这里，我们只需要输入新的括号，在其中添加行数为50和

115
00:08:23,570 --> 00:08:26,000
列数为1。

116
00:08:26,010 --> 00:08:27,770
所以要小心。

117
00:08:28,290 --> 00:08:34,580
这里所有带有括号的都是该函数的第一个参数。

118
00:08:34,650 --> 00:08:40,030
好吧，这是您唯一需要输入的参数，但不要与括号混淆

119
00:08:40,020 --> 00:08:40,650
。

120
00:08:40,650 --> 00:08:47,190
黄色的括号是一个函数的括号，而里面的括号是

121
00:08:47,430 --> 00:08:52,140
是该函数的第一个参数的括号，即形状。

122
00:08:52,140 --> 00:08:57,070
因此，正如我刚才提到的那样，这是我们唯一需要提出的论点，我们对此并不在乎。

123
00:08:57,070 --> 00:09:02,180
因此N.P. 准备好返回这一列51。

124
00:09:02,250 --> 00:09:05,400
这将附加到特征X的矩阵中。

125
00:09:05,820 --> 00:09:10,980
但是现在我们需要做一件事，因为否则我们将收到数据类型错误并防止

126
00:09:10,990 --> 00:09:17,670
发生这种数据类型错误，我们只需要将此处的这个数组转换为整数

127
00:09:17,670 --> 00:09:26,710
类型并执行此操作非常简单，我们只需要实际添加为类型并在括号中添加

128
00:09:26,740 --> 00:09:33,250
只是这样做是为了防止发生数据类型错误，您可以尝试执行此行而无需

129
00:09:33,250 --> 00:09:36,960
这种S型，您将得到一个数据类型错误。

130
00:09:36,970 --> 00:09:38,950
所以现在我们很好。

131
00:09:38,980 --> 00:09:44,880
现在我们只需要在这里添加最后一个参数，即access，因为您可以使用pen函数

132
00:09:44,880 --> 00:09:51,130
这里将这些值的一行或这些值的一列添加到矩阵中，这是我们的

133
00:09:51,120 --> 00:09:55,760
特征X的矩阵，因此我们需要指定是否要添加列或线。

134
00:09:55,870 --> 00:09:58,990
因此，如果我们要添加一条线，则其访问权限为零。

135
00:09:59,110 --> 00:10:02,110
如果要添加一列，则其轴等于1。

136
00:10:02,250 --> 00:10:07,540
因此，这里我们只添加等于1的访问权限。

137
00:10:07,800 --> 00:10:08,650
好。

138
00:10:08,740 --> 00:10:14,560
现在我很抱歉，在此行准备执行之前，只有一件小事要做

139
00:10:14,580 --> 00:10:14,740
。

140
00:10:14,880 --> 00:10:22,080
与以下事实有关：现在我们确实将此处的51列添加到了

141
00:10:22,100 --> 00:10:27,970
功能X，但实际上我们将其添加到功能X矩阵的末尾。我们想

142
00:10:27,960 --> 00:10:29,000
一开始就拥有它。

143
00:10:29,110 --> 00:10:31,480
因此，根据您的意见，我们可以在这里做什么。

144
00:10:31,500 --> 00:10:37,440
我们可以使用一个非常简单的技巧在矩阵的开头将这一列实际添加到此处

145
00:10:37,440 --> 00:10:38,330
如果你只是x。

146
00:10:38,400 --> 00:10:39,430
诀窍是什么。

147
00:10:39,550 --> 00:10:43,760
就像您在这里注意到的那样，前两个参数是数组。

148
00:10:43,810 --> 00:10:48,810
一个函数期望一个数组，并且都在这里和值。

149
00:10:49,020 --> 00:10:56,850
那么，如果不将51中的此列添加到矩阵X中，该怎么办呢？

150
00:10:56,910 --> 00:10:59,500
X到此列或此处为51。

151
00:10:59,640 --> 00:11:02,170
因此，这样做实际上非常简单。

152
00:11:02,320 --> 00:11:06,390
我们只需要反转并以这种方式放入即可。

153
00:11:06,690 --> 00:11:14,130
然后将X放到值上，以便现在我们将特征X矩阵添加到这个

154
00:11:14,180 --> 00:11:21,150
在此列一次50，而在此50列中，该列将作为我们的第一列

155
00:11:21,150 --> 00:11:26,020
矩阵正是我们想要的未来主义者X，因为这样我们就可以更容易地对其进行解释

156
00:11:26,010 --> 00:11:26,070
。

157
00:11:26,080 --> 00:11:32,700
您知道我们有多重回归方程，首先常数为零，因此

158
00:11:32,940 --> 00:11:34,100
零等于1。

159
00:11:34,240 --> 00:11:38,060
然后，我们拥有所有自变量x1 x2 XM。

160
00:11:38,270 --> 00:11:40,950
好的，现在准备好了。

161
00:11:40,950 --> 00:11:47,040
抱歉，这有点多，但这实际上对您很有用，因为您会遇到

162
00:11:47,050 --> 00:11:52,090
一些库，您需要在其中将这种需求添加到功能矩阵中。

163
00:11:52,090 --> 00:11:57,220
因此，您只需要复制此行，就可以知道将正确的矩阵放入要素中（如果它是X）

164
00:11:57,210 --> 00:11:57,920
或另一个。

165
00:11:58,000 --> 00:12:01,780
然后，这只会将第一列添加到矩阵功能中。

166
00:12:01,770 --> 00:12:03,600
因此，这实际上非常有用。

167
00:12:03,690 --> 00:12:06,560
这值得花一点时间在此上。

168
00:12:06,630 --> 00:12:11,050
现在，我当然会向您展示，这实际上将这一列添加为一种矩阵

169
00:12:11,050 --> 00:12:13,730
矩阵开头的特征X。

170
00:12:13,750 --> 00:12:15,600
因此，让我们在这里去找变量专家。

171
00:12:15,750 --> 00:12:17,920
现在让我们看一下X。

172
00:12:17,980 --> 00:12:23,650
因此，您可以看到X包含所有独立变量，而此处没有第一列。

173
00:12:23,640 --> 00:12:26,530
因此，这是状态的两个虚拟变量。

174
00:12:26,520 --> 00:12:27,950
这已经花了。

175
00:12:27,960 --> 00:12:35,880
这是R.D.支出，这是营销支出，现在，如果我选择此行并按Command Control

176
00:12:35,880 --> 00:12:37,520
按Enter执行。

177
00:12:37,840 --> 00:12:45,360
现在让我们看一下X，您会看到x现在包含一次包含此内容的第一列

178
00:12:45,370 --> 00:12:52,760
对应于此零的一栏等于与此常数零和

179
00:12:52,760 --> 00:12:58,850
回归方程y等于零加1加上2 x 2加上重音。

180
00:12:59,370 --> 00:13:01,370
OK，所以我们按OK。

181
00:13:01,810 --> 00:13:08,500
现在，我们一直在等待的那一刻，我们将开始向后消除，但我们只是

182
00:13:08,500 --> 00:13:12,690
现在要休息一下，我们将在下一个Statoil中开始这样做。

183
00:13:12,880 --> 00:13:14,600
在那之前享受机器学习

