1
00:00:00,270 --> 00:00:06,000
您好，欢迎您前来辛勤工作，我们已经处理了所有数据预处理工作

2
00:00:06,000 --> 00:00:09,510
并且我们为回归中的多个数据准备好了数据集。

3
00:00:09,660 --> 00:00:15,540
因此，在今天的故事中，我们已经准备好将多元乘以回归火车的方法，那就是

4
00:00:15,540 --> 00:00:17,160
我们现在要做什么。

5
00:00:17,160 --> 00:00:22,970
因此，要求简单回归，我们要做的第一件事是引入多极点

6
00:00:23,000 --> 00:00:24,170
现在回归或。

7
00:00:24,390 --> 00:00:26,950
我们将其称为严格的。

8
00:00:27,390 --> 00:00:30,850
因此，这是建立回归模型的常用方法。

9
00:00:30,870 --> 00:00:36,360
您将看到我们每次都会创建回归，或者我们将适合训练集，然后

10
00:00:36,450 --> 00:00:42,030
应用于对其进行预测的功能以进行预测，以对新观测值进行预测，例如

11
00:00:42,030 --> 00:00:47,730
测试集观察值，然后要求简单回归，我们将在这里使用LN函数

12
00:00:47,790 --> 00:00:52,040
Ellen，并在括号中，我们将输入参数。

13
00:00:52,380 --> 00:00:56,620
好的，让我们按F 1来查看LN功能。

14
00:00:56,630 --> 00:00:58,880
在这里，我们将填写您的模型。

15
00:00:58,890 --> 00:01:00,180
让我们看看我们的论点。

16
00:01:00,210 --> 00:01:04,300
这与简单回归相同，实际上第一个参数是公式。

17
00:01:04,320 --> 00:01:09,030
但是这次您将看到我们将如何更改公式语法。

18
00:01:09,030 --> 00:01:13,350
对于那些还不知道窍门的人，我将为您提供编写公式的超级窍门

19
00:01:13,620 --> 00:01:18,620
很快，第二个必填参数输入就是数据。

20
00:01:18,750 --> 00:01:20,890
当然，这将是火车。

21
00:01:21,120 --> 00:01:23,180
因此，我们首先输入公式。

22
00:01:23,650 --> 00:01:24,990
所以这里的公式。

23
00:01:25,440 --> 00:01:32,370
因此请记住，在回归过程中我们很简单，我们根据您的经验编写了公式Sellery

24
00:01:32,370 --> 00:01:32,500
。

25
00:01:32,580 --> 00:01:38,310
这几乎是相同的，但不同之处在于我们有几个独立变量

26
00:01:38,320 --> 00:01:38,480
。

27
00:01:38,640 --> 00:01:46,260
在足够简单的回归中我们有四个自变量，因变量是成比例的

28
00:01:46,260 --> 00:01:48,620
到唯一的独立变量。

29
00:01:48,870 --> 00:01:50,580
好吧，这将是相同的。

30
00:01:50,580 --> 00:01:54,760
利润将与这些自变量成比例。

31
00:01:54,960 --> 00:02:02,460
只有正确的说法是不成比例的，而是利润将是线性组合

32
00:02:02,730 --> 00:02:09,630
的自变量和公式等于获利。

33
00:02:09,720 --> 00:02:16,950
这里的想法是添加所有用加号分隔的自变量。

34
00:02:16,950 --> 00:02:18,650
因此，让我们看看它们。

35
00:02:19,020 --> 00:02:22,720
这是我们的D跨度。

36
00:02:22,840 --> 00:02:29,570
我在这里使用点是因为在数据集中我们有一些空格，并用点代替它们。

37
00:02:29,580 --> 00:02:36,150
所以这是然后加号然后是管理变量

38
00:02:39,150 --> 00:02:41,640
加上行销支出

39
00:02:44,370 --> 00:02:47,380
花加州，仅此而已。

40
00:02:47,640 --> 00:02:54,240
因此，这就是将利润表示为所有这些自变量的线性组合的方式。

41
00:02:54,240 --> 00:02:56,890
这就是这个公式的确切含义。

42
00:02:57,030 --> 00:03:01,780
但是，有一种技巧可以更有效地编写此公式。

43
00:03:02,010 --> 00:03:08,550
它不是在这里编写所有自变量，我们只需编写一个点即可。

44
00:03:09,000 --> 00:03:10,360
那就是我们可以简单地写的。

45
00:03:10,380 --> 00:03:17,070
这就是完全相同的方程式，您可以将利润表示为线性组合

46
00:03:17,250 --> 00:03:19,210
所有自变量。

47
00:03:19,290 --> 00:03:22,390
因此，此处的点仅表示所有自变量。

48
00:03:22,590 --> 00:03:22,950
好。

49
00:03:22,950 --> 00:03:27,690
因此，对于第一个参数公式，利润等于所有独立变量的线性组合

50
00:03:27,690 --> 00:03:28,560
变量。

51
00:03:28,560 --> 00:03:30,320
第二个参数是数据。

52
00:03:30,510 --> 00:03:39,000
正如我们所说的，这当然是训练集，因为我们想在回归中训练乘数

53
00:03:39,000 --> 00:03:43,590
在训练集上进行建模，然后在测试中测试性能。

54
00:03:43,590 --> 00:03:48,220
好的，对于建筑物或多个回归回归器而言。

55
00:03:48,360 --> 00:03:53,210
因此，我们将选择它并执行它。

56
00:03:53,220 --> 00:04:00,090
现在，有一件非常重要的事情要做，这是非常实际，非常有用的事情

57
00:04:00,090 --> 00:04:07,260
我们要看的是我们在这里建立的回归器的信息，

58
00:04:07,260 --> 00:04:12,540
要做到这一点，真的非常简单，我们只需要它就像简单，就知道回归

59
00:04:12,690 --> 00:04:16,230
这一次会变得更加有趣，因为我们将有几个独立变量

60
00:04:16,230 --> 00:04:19,510
其中一些会对因变量产生更强的影响。

61
00:04:19,530 --> 00:04:24,100
因此，我们将看到它会变得更加有趣并且在开发过程中如此简单

62
00:04:24,100 --> 00:04:27,500
总结我们的遗憾。

63
00:04:27,850 --> 00:04:28,610
好吧。

64
00:04:28,680 --> 00:04:31,770
只需按Enter即可。

65
00:04:31,770 --> 00:04:39,030
我只是将其调高，在这里，我们获得了回归器的所有信息。

66
00:04:39,480 --> 00:04:39,750
好的。

67
00:04:39,750 --> 00:04:43,730
因此，这里的第一件事只是提醒您该公式是什么。

68
00:04:43,740 --> 00:04:50,250
因此，利润表示为所有自变量与我们的回归指标的线性组合

69
00:04:50,250 --> 00:04:51,800
趋势和趋势集。

70
00:04:52,020 --> 00:04:57,220
好的残差我们将在本部分结尾处讨论。

71
00:04:57,300 --> 00:04:59,490
因此，让我们现在不专注于此。

72
00:04:59,760 --> 00:05:03,520
但是，这是系数的重要部分。

73
00:05:03,660 --> 00:05:09,960
这就是我们现在需要重点关注的内容，因为您可以看到它为您的每个人提供了一些信息

74
00:05:10,170 --> 00:05:16,530
自变量或状态3的状态是虚拟变量，这是因为

75
00:05:16,530 --> 00:05:21,120
您知道我告诉过您，图书馆会为您处理一切。

76
00:05:21,120 --> 00:05:26,340
它不仅创建了虚拟变量，或者知道必须为状态创建虚拟变量

77
00:05:26,340 --> 00:05:27,120
变量。

78
00:05:27,120 --> 00:05:32,310
并且我们帮助我们理解了这一点，因为我们将状态变量编码为因素。

79
00:05:32,470 --> 00:05:38,970
因此，我们为您完成了所有工作，因为他不仅为状态变量创建了虚拟变量

80
00:05:39,000 --> 00:05:44,880
但我们也没有落入哑变量，因为如您所见，它会自动删除一个

81
00:05:44,880 --> 00:05:49,690
可评估性以避免某些冗余依赖性。

82
00:05:49,800 --> 00:05:50,670
太完美了。

83
00:05:50,670 --> 00:05:54,690
那就是我们的库以及Python中的Python库的优点。

84
00:05:54,690 --> 00:05:59,490
我知道我们指定了一个新部分来删除哑变量，但这只是提醒您

85
00:05:59,490 --> 00:06:00,160
陷阱。

86
00:06:00,210 --> 00:06:02,390
我们不需要在Python上执行此操作。

87
00:06:02,400 --> 00:06:03,690
照顾好你。

88
00:06:03,990 --> 00:06:04,530
太好了。

89
00:06:04,530 --> 00:06:08,700
首先要注意的是，然后我告诉您的是，对于每个系数

90
00:06:08,700 --> 00:06:14,610
我们有不同的信息，实际上线性回归方程中有系数。

91
00:06:14,790 --> 00:06:20,730
然后我们得到标准误，然后是T值，然后是p值，然后是显着性水平

92
00:06:20,750 --> 00:06:21,050
。

93
00:06:21,300 --> 00:06:27,660
因此，通过查看此内容，最重要的信息是p值和有效值的最后两列

94
00:06:27,660 --> 00:06:34,800
水平，因为这些缺点告诉我们关于自变量对

95
00:06:34,800 --> 00:06:36,450
因变量。

96
00:06:36,450 --> 00:06:42,480
这意味着它告诉我们每个自变量是否对因变量有重大影响

97
00:06:42,480 --> 00:06:43,550
变量。

98
00:06:44,070 --> 00:06:46,910
好的，让我首先解释一下p值是什么。

99
00:06:47,010 --> 00:06:53,940
最重要的是要理解，p值越低，统计意义上的意义就越明显

100
00:06:54,240 --> 00:06:57,110
您的自变量将会是。

101
00:06:57,300 --> 00:07:03,990
这意味着p值越低，对自变量的影响越大或会影响

102
00:07:03,990 --> 00:07:11,030
具有独立的生存能力，并且通常使用的良好阈值为5％。

103
00:07:11,190 --> 00:07:16,740
这意味着，如果您的p值低于5％，则意味着您的自变量

104
00:07:16,740 --> 00:07:19,620
具有很高的统计意义。

105
00:07:19,620 --> 00:07:24,390
大约5％越大，统计意义上的重要性就越小。

106
00:07:24,390 --> 00:07:27,040
这就是您必须整合价值的方式。

107
00:07:27,270 --> 00:07:33,030
然后我们有最后一列，这只是解释系数的一种更快的方法，因为

108
00:07:33,090 --> 00:07:38,790
如您所见，我们在这里有这条线，它向我们介绍了有关恒星的信息，以及有关恒星的本质

109
00:07:38,790 --> 00:07:44,760
意思是因为那是当p值介于零和0.1％之间时。

110
00:07:44,760 --> 00:07:50,400
然后将有三颗星，这意味着您独立

111
00:07:50,400 --> 00:07:51,150
变量。

112
00:07:51,480 --> 00:07:59,490
如果p值介于0.1％和1％之间，则其统计显着性水平很高

113
00:07:59,490 --> 00:08:00,000
。

114
00:08:00,000 --> 00:08:06,180
然后，如果您的p值介于1％和5％之间，则自变量仍在统计上

115
00:08:06,180 --> 00:08:10,940
显着，但效果不如第一类。

116
00:08:11,310 --> 00:08:16,920
然后，如果您的p值介于5％和10％之间，则为临界线。

117
00:08:17,120 --> 00:08:23,610
可能在一定程度上具有统计意义，但没有那么多，而且您的体重比

118
00:08:23,610 --> 00:08:27,300
那些具有三颗星和两颗星的自变量。

119
00:08:27,660 --> 00:08:34,280
然后，如果您的P P值在10％到1之间，则绝对没有统计意义

120
00:08:34,280 --> 00:08:34,300
。

121
00:08:34,290 --> 00:08:39,280
这意味着它们是自变量，不会对因变量产生任何影响。

122
00:08:39,360 --> 00:08:46,140
这很有趣，因为当我们在这里查看自变量时，我们注意到

123
00:08:46,140 --> 00:08:51,210
一个变量对因变量具有很高的统计意义。

124
00:08:51,240 --> 00:08:52,740
这是研发支出。

125
00:08:52,980 --> 00:08:58,020
因此，看来利润主要由研发支出决定。

126
00:08:58,020 --> 00:09:04,220
这意味着研发支出对利润的影响最大。

127
00:09:04,230 --> 00:09:09,210
因此，这对于投资者而言是非常重要的信息，因为他们现在知道，他们不仅应该

128
00:09:09,210 --> 00:09:15,720
看利润本身，就知道看最大利润来决定在哪里投资

129
00:09:15,720 --> 00:09:15,960
。

130
00:09:16,050 --> 00:09:20,940
但同时，它也应该关注研发支出变量，该变量应该关注研发支出

131
00:09:20,940 --> 00:09:25,420
进行研发以在其投资决策中添加另一个标准。

132
00:09:25,590 --> 00:09:26,960
因此，这是一个非常好的信息。

133
00:09:27,000 --> 00:09:32,250
基本上，这意味着所有的意思是，在这里所有自变量中

134
00:09:32,280 --> 00:09:39,810
唯一的预测指标利润的唯一有力预测指标是研发支出，其余的绝对像

135
00:09:39,950 --> 00:09:41,130
并且有用。

136
00:09:41,130 --> 00:09:48,780
所以实际上这意味着我们可以在回归方程中重写此倍数

137
00:09:48,780 --> 00:09:55,470
并在我们的回归分析中将其转化为简单的变量，因为

138
00:09:55,470 --> 00:10:01,910
对利润因变量的影响是研发支出，则公式可能是利润等于

139
00:10:01,990 --> 00:10:09,600
r点d点的支出，这没关系，实际上可以给出相同的预测。

140
00:10:10,450 --> 00:10:11,070
好的。

141
00:10:11,070 --> 00:10:16,560
因此，您在本教程中学到了很多东西，但是在我们的回归分析中，这是非常重要的事情

142
00:10:16,570 --> 00:10:16,740
。

143
00:10:16,890 --> 00:10:18,360
恭喜你

144
00:10:18,420 --> 00:10:22,360
我们只剩下一个教程，可以用来预测测试结果。

145
00:10:22,530 --> 00:10:24,120
因此，我期待与您相会。

146
00:10:24,120 --> 00:10:25,880
直到那时，机器学习

