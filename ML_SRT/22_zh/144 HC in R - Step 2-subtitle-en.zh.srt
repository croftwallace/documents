1
00:00:00,390 --> 00:00:06,480
您好，欢迎收看英国Statoil的艺术教程，我们导入了商城数据集，并准备了

2
00:00:06,540 --> 00:00:11,820
通过选择我们对年收入和支出得分感兴趣的两列来正确获取我们的数据

3
00:00:11,830 --> 00:00:11,990
。

4
00:00:12,150 --> 00:00:17,520
因此，我们创建了包含这两列的变量x，现在事情将会变得更多

5
00:00:17,520 --> 00:00:23,910
有趣，因为在本教程中，我们将构建我们的DNA程序，我们将使用它来查找

6
00:00:23,910 --> 00:00:30,120
最佳簇数完全像我们在开曼部分所做的一样

7
00:00:30,120 --> 00:00:33,960
第二，我们使用弯头法图表找到最佳的簇数。

8
00:00:34,140 --> 00:00:40,050
在分层聚类的第二步中，我们还将寻找最佳数量的聚类

9
00:00:40,050 --> 00:00:40,320
。

10
00:00:40,320 --> 00:00:42,510
只有这次，我们才不会使用其他方法。

11
00:00:42,630 --> 00:00:45,060
我们将使用then程序。

12
00:00:45,060 --> 00:00:47,010
所以，现在就开始做吧。

13
00:00:47,010 --> 00:00:51,910
关于它的非常酷的事情是，我们只需要一行代码即可构建该程序。

14
00:00:52,260 --> 00:00:54,880
因此，让我们编写它，让我们编写这一行代码。

15
00:00:54,900 --> 00:01:02,020
我们首先创建一个变量，然后是程序，然后等于它，然后我们将使用H类

16
00:01:02,040 --> 00:01:02,210
。

17
00:01:02,370 --> 00:01:06,860
因此，让我们在这里键入每个班级，然后按F 1。

18
00:01:07,170 --> 00:01:10,780
在这里，我们获得了该年龄段课程的所有信息。

19
00:01:10,950 --> 00:01:14,880
因此，让我们看看这里的参数，我们只需要前两个参数。

20
00:01:15,090 --> 00:01:20,520
第一个参数是由此产生的相异结构，在本例中，该参数是

21
00:01:20,520 --> 00:01:26,850
将是我们的数据集X的距离矩阵，该矩阵可以告诉每对客户

22
00:01:27,170 --> 00:01:29,170
两者之间的欧几里得距离。

23
00:01:29,280 --> 00:01:34,500
因此，这意味着对于每对客户，我们采用两个坐标来计算年收入和支出

24
00:01:34,500 --> 00:01:38,300
得分，我们计算两者之间的欧几里得距离。

25
00:01:38,310 --> 00:01:40,010
基于这些坐标。

26
00:01:40,320 --> 00:01:44,070
好的，那只是为了解释H class类的第一个参数。

27
00:01:44,080 --> 00:01:46,260
因此，让我们将其放入代码中。

28
00:01:46,260 --> 00:01:55,650
我们输入d'Este并在括号X中出现，然后方法等于Euclidean，从而指定

29
00:01:55,650 --> 00:01:59,780
我们要为数据X计算单位和距离矩阵。

30
00:02:00,300 --> 00:02:02,710
确定，所以这是第一个参数。

31
00:02:02,730 --> 00:02:07,100
这个距离矩阵和第二个参数就是方法。

32
00:02:07,350 --> 00:02:14,250
因此，该方法只是用于查找集群的方法，就像在Python中一样，我们将选择

33
00:02:14,250 --> 00:02:17,100
最常见的方法是单词方法。

34
00:02:17,100 --> 00:02:23,730
在这里，它被称为单词D点，它实际上是一种试图最小化内部偏差的方法。

35
00:02:23,790 --> 00:02:25,260
每个集群。

36
00:02:25,290 --> 00:02:30,030
有点像我们在尝试最小化愿意的群集平方和时没有k。

37
00:02:30,330 --> 00:02:34,530
好吧，这是基于相同的思想，而不是试图使内部的总和最小化。

38
00:02:34,530 --> 00:02:39,750
我们试图最小化聚类内部的方差以找到聚类。

39
00:02:40,350 --> 00:02:44,790
所以在这里，我们写的方法等于单词darty。

40
00:02:44,880 --> 00:02:48,390
这就是构建此密集程序的代码行的结尾。

41
00:02:48,480 --> 00:02:50,170
现在我们只需要绘制它。

42
00:02:50,310 --> 00:02:58,290
所以在下面，我们将要编写图，然后在括号中，然后在程序中命名，

43
00:02:58,290 --> 00:03:05,640
通过键入main等于粘贴括号，然后在引号中进行编程。

44
00:03:05,640 --> 00:03:10,800
然后，通过添加x爱等于客户，为x轴命名。

45
00:03:10,980 --> 00:03:16,170
因为在无效程序中，我们所有的客户都将位于x轴上，然后让我们给出

46
00:03:16,170 --> 00:03:18,370
我们白色标签的名称。

47
00:03:18,460 --> 00:03:23,580
我们将其称为欧几里得距离，这是因为在牙科克中垂直线

48
00:03:23,580 --> 00:03:29,430
我们将要看到的实际上是质心之间的闭合器的欧几里得距离

49
00:03:29,430 --> 00:03:30,670
的集群。

50
00:03:30,690 --> 00:03:33,060
好的，所以我们很高兴与我们的A情节一起去。

51
00:03:33,090 --> 00:03:35,390
因此，实际上是我们的牙克。

52
00:03:35,390 --> 00:03:39,300
因此，让我们选择此处执行的所有代码段。

53
00:03:39,420 --> 00:03:41,470
这是我们的den程序。

54
00:03:41,700 --> 00:03:43,530
因此，让我们来看看它。

55
00:03:43,530 --> 00:03:46,020
我要点击此处将其放大。

56
00:03:46,260 --> 00:03:47,200
好。

57
00:03:47,550 --> 00:03:50,830
现在，让我们尝试找到最佳的群集数量。

58
00:03:50,880 --> 00:03:52,520
感谢这个帐篷计划。

59
00:03:52,740 --> 00:03:59,880
因此，正如Cuil在直觉部分中解释的那样，为了找到最佳数目的簇，我们需要找到

60
00:03:59,880 --> 00:04:07,510
在不跨越任何其他水平线的情况下我们可以达到的最大垂直距离。

61
00:04:08,400 --> 00:04:12,220
然后我们只需要计算此级别的垂直线数即可。

62
00:04:12,600 --> 00:04:12,840
好。

63
00:04:12,840 --> 00:04:16,340
因此，让我们开始寻找最大的垂直距离。

64
00:04:16,560 --> 00:04:22,950
因此，显然不是在这里，也许这是一个很大的距离，实际上

65
00:04:22,950 --> 00:04:27,500
我们三个集群，因为正如您在这里看到的那样，我正在跨越三个垂直线。

66
00:04:27,990 --> 00:04:29,720
绝对不是这个。

67
00:04:29,760 --> 00:04:36,900
从这个点到这个点，我们还有另一个很大的距离

68
00:04:37,260 --> 00:04:40,120
然后在下面显然我们没有太大的距离。

69
00:04:40,140 --> 00:04:45,650
所以现在的问题是，这个距离和这个距离之间最大的距离是多少。

70
00:04:45,900 --> 00:04:51,240
好吧，如果您对它有更好的了解，我们可以看到最大距离实际上就是这个距离

71
00:04:51,250 --> 00:04:51,560
。

72
00:04:52,050 --> 00:04:54,930
以及在此级别上有多少垂直线。

73
00:04:54,930 --> 00:04:58,470
让我们看看一二三四和五。

74
00:04:58,470 --> 00:05:04,470
因此，这意味着群集的最佳数量为五个群集，这当然是一种解脱，因为

75
00:05:04,470 --> 00:05:08,820
这就是我们使用肘方法使用Kamins算法获得的结果。

76
00:05:08,820 --> 00:05:12,170
因此，一切都很好，一切都非常一致。

77
00:05:12,270 --> 00:05:18,810
因此，我们欢迎第二步，现在我们可以继续进行下一步，以适应我们的层次结构

78
00:05:18,810 --> 00:05:23,990
数据X的聚类算法。这就是我们在下一个教程中将要做的。

