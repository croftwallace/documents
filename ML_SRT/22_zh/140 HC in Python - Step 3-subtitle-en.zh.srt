1
00:00:00,390 --> 00:00:06,150
您好，欢迎来到Spuyten教程，在复活节之前，我们踩了den程序，我们

2
00:00:06,150 --> 00:00:12,450
用它来找到最佳的群集数，即五个群集，现在，既然我们有权利

3
00:00:12,450 --> 00:00:18,570
我们准备进行下一步以适应层次化集群的数量

4
00:00:18,660 --> 00:00:23,390
算法将我们的数据与正确的聚类数五个聚类。

5
00:00:23,400 --> 00:00:30,060
因此，层次聚类的第三步与Kamins聚类完全相同

6
00:00:30,080 --> 00:00:30,430
。

7
00:00:30,750 --> 00:00:40,280
好的，现在让我们介绍一个新的部分，该部分的注释适合购物中心数据的层次结构聚类

8
00:00:40,290 --> 00:00:41,550
数据集。

9
00:00:41,610 --> 00:00:42,150
好。

10
00:00:42,570 --> 00:00:47,970
因此，我们要做的第一件事是导入正确的工具，以帮助我们适应

11
00:00:47,970 --> 00:00:51,550
对数据x的分层聚类算法。

12
00:00:51,570 --> 00:00:57,200
请记住，在Kamins中，此工具是Kamins类，在这里它将是相同的。

13
00:00:57,270 --> 00:01:03,450
我们将使用层次化聚类来将层次化聚类适合我们的数据

14
00:01:03,450 --> 00:01:04,330
手电筒。

15
00:01:04,620 --> 00:01:07,160
好的，这是什么一堂课。

16
00:01:07,250 --> 00:01:13,090
请记住，在直觉部分中，Carol谈到了两种用于层次聚类的算法。

17
00:01:13,230 --> 00:01:19,530
一种是聚集的层次聚类，另一种是分裂的层次聚类。

18
00:01:19,530 --> 00:01:23,280
他还说，最常见的是比较聚类。

19
00:01:23,280 --> 00:01:29,450
因此，这些类现在将要导入，以适合分层聚类的两个或更多数据集

20
00:01:29,460 --> 00:01:36,450
将从很棒的sikat学习中适应集群类，因此让我们导入该类

21
00:01:36,450 --> 00:01:36,730
。

22
00:01:36,870 --> 00:01:44,970
因此我们从S-K那里学习到群集导入Agam叙事群集。

23
00:01:44,970 --> 00:01:48,420
请记住，Kamins类的首字母为K，首字母为M。

24
00:01:48,540 --> 00:01:51,540
好吧，这里和大写字母C一样。

25
00:01:51,900 --> 00:01:52,520
好。

26
00:01:52,650 --> 00:01:58,200
现在我们已经准备好适合作为增量式层次聚类的层次聚类

27
00:01:58,500 --> 00:02:01,420
根据我们的数据X，与Kamins相同。

28
00:02:01,440 --> 00:02:09,690
我们从创建足够的类比较聚类开始，因此我们键入H C等于增补

29
00:02:09,690 --> 00:02:11,320
聚类。

30
00:02:11,970 --> 00:02:17,040
现在，在括号中的主题上，我们将指定不同的参数。

31
00:02:17,100 --> 00:02:23,460
因此，第一个参数是簇，而聚类是我们现在知道的癌症数目。

32
00:02:23,670 --> 00:02:26,680
因此，我们键入，并且群集等于五。

33
00:02:26,790 --> 00:02:32,990
然后第二个参数是无穷大，实际上是您知道链接的距离。

34
00:02:33,270 --> 00:02:37,100
和往常一样，我们将选择欧几里得距离。

35
00:02:37,200 --> 00:02:38,840
因此，我们添加了第二个参数。

36
00:02:38,850 --> 00:02:46,560
无限等于欧几里得，最后是最后一个参数，最重要的一个是链接。

37
00:02:46,560 --> 00:02:52,890
因此，我们将使用与构建DNA程序时使用的链接相同的链接，

38
00:02:52,890 --> 00:02:59,610
请记住，“连锁”一词是我想提醒的“方法”一词，它试图将

39
00:02:59,610 --> 00:03:02,330
每个聚类中的方差。

40
00:03:02,370 --> 00:03:08,910
好的，因此通过编写此行，我们仅准备了分层聚类算法，因为您注意到了

41
00:03:08,910 --> 00:03:14,570
我们已经输入了数据X，所以我们还没有将层次聚类Unger拟合到我们的数据中

42
00:03:14,580 --> 00:03:15,320
X。

43
00:03:15,360 --> 00:03:17,900
但是，我们现在将要这样做。

44
00:03:18,090 --> 00:03:20,820
因此，让我们编写新的代码行。

45
00:03:21,090 --> 00:03:26,370
在这一方面，我们将使层次聚类算法适合于数据X，而

46
00:03:26,370 --> 00:03:32,910
创建聚类向量，该向量是为每个客户指示该客户哪个聚类的向量

47
00:03:32,910 --> 00:03:33,810
属于。

48
00:03:34,200 --> 00:03:42,340
因此，我们将称该向量y为下划线h c，然后等于，然后取目标H.C。 包含

49
00:03:42,340 --> 00:03:48,660
具有正确数目的聚类的扩充聚类算法准备好五个聚类的欧几里得

50
00:03:48,660 --> 00:03:51,220
距离和单词联动。

51
00:03:51,240 --> 00:03:57,390
现在，与包含fit方法的Kamins类相同，Agam也是主动聚类类

52
00:03:57,390 --> 00:04:04,890
包含拟合预测方法，因此我们在此处添加拟合下划线预测即预测方法

53
00:04:05,030 --> 00:04:11,040
这将返回簇的向量，然后在括号x 2中指定

54
00:04:11,040 --> 00:04:15,870
我们将填充聚类算法填充到数据X中，并且我们正在预测聚类

55
00:04:15,870 --> 00:04:18,530
客户的数据x。

56
00:04:18,540 --> 00:04:22,570
因此，基本上，我们所做的工作与玩游戏完全相同。

57
00:04:22,650 --> 00:04:28,380
唯一的区别是我们使用的类是增强聚类而不是Kamins

58
00:04:29,060 --> 00:04:29,710
大。

59
00:04:29,730 --> 00:04:31,920
至此，我们完成了拟合部分。

60
00:04:31,920 --> 00:04:36,360
因此，让我们在这里喜欢这段代码并执行它。

61
00:04:36,360 --> 00:04:40,800
好的，现在我们可以看到，探索这种新的集群向量非常有价值。

62
00:04:40,830 --> 00:04:44,060
为什么要HC 出现了，所以我们双击它。

63
00:04:44,430 --> 00:04:48,340
让我们也打开数据集以查看关联。

64
00:04:48,600 --> 00:04:57,210
因此，第一个客户的客户ID号是一个客户，那么客户ID号44

65
00:04:57,840 --> 00:04:59,850
属于我们属于1。

66
00:05:00,330 --> 00:05:06,900
我们的最后一位客户的客户ID号200属于Chris或2。

67
00:05:08,010 --> 00:05:13,170
好的，我们完成了将分层聚类算法拟合到我们的数据这一新步骤

68
00:05:13,170 --> 00:05:13,850
X。

69
00:05:13,980 --> 00:05:18,270
因此，这意味着我们做得很好，我们可以为所有成就感到自豪。

70
00:05:18,360 --> 00:05:23,610
因此，现在我们应该获得一些乐趣，这正是我们接下来的一个小时所要获得的

71
00:05:23,610 --> 00:05:23,870
。

72
00:05:23,880 --> 00:05:26,520
因此，我期待在下一个教程中见到您。

73
00:05:26,520 --> 00:05:28,590
直到那时快乐的聚类

