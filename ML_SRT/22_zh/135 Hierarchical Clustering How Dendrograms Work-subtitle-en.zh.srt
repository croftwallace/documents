1
00:00:00,750 --> 00:00:06,630
您好，欢迎回到我们谈论分层的微风教程中的机器学习课程

2
00:00:06,630 --> 00:00:10,760
将其背后的直觉及其工作方式归类。

3
00:00:10,800 --> 00:00:16,020
但与此同时，我们还不太了解H.C.的全部目的。 不是什么好处

4
00:00:16,110 --> 00:00:22,380
是的，我们来自大量的分类器，在那里每个点或数据元素都被认为是

5
00:00:22,380 --> 00:00:27,600
一个集群，然后到一个大集群，但是结果是，现在我们有一个巨大的成本是什么

6
00:00:27,600 --> 00:00:28,800
所有的重点。

7
00:00:28,950 --> 00:00:31,300
我们如何获得想要的结果。

8
00:00:31,300 --> 00:00:36,450
实际的聚类，这样我就可以Kamins例如，我们将有两个或三个更接近的聚类。

9
00:00:36,450 --> 00:00:39,680
我们如何获得正确数量的集群。

10
00:00:39,690 --> 00:00:44,070
因此，这就是Dinda Gram出现的地方，它们将帮助我们理解一切。

11
00:00:44,070 --> 00:00:45,960
因此，让我们直接了解它。

12
00:00:45,960 --> 00:00:51,750
所以在这里，我在左侧有一个包含六个点的图表，在右侧有另一个图表

13
00:00:51,750 --> 00:00:54,500
图表，我们将使用此图表创建Dendron Graham。

14
00:00:54,540 --> 00:00:59,670
现在我知道一开始听起来可能有些混乱，尤其是因为我们还没有讨论过这些图

15
00:00:59,970 --> 00:01:02,720
但是通过创建一个，我们将了解它们是什么。

16
00:01:02,820 --> 00:01:10,590
首先，为了使内容更清晰，我将在底部添加点，以便

17
00:01:10,590 --> 00:01:13,250
它们更大一些，因此您可以更好地看到它们。

18
00:01:13,320 --> 00:01:14,740
等等。

19
00:01:14,800 --> 00:01:18,500
在那里，它们只是在垂直轴的底部列出。

20
00:01:18,500 --> 00:01:21,450
我们已经有了欧几里得距离，而这一切现在才有意义。

21
00:01:21,480 --> 00:01:26,340
所以我们现在要经历H.C. 算法并慢慢创建这些集群。

22
00:01:26,400 --> 00:01:30,110
因此，从每个点开始都是一个单独的集群。

23
00:01:30,210 --> 00:01:32,760
是的，所以这些要点中的每一个都是一个单独的集群。

24
00:01:32,760 --> 00:01:37,410
接下来，我们要做的是找到两个最接近的点，即这两个并放

25
00:01:37,410 --> 00:01:38,640
他们成一簇。

26
00:01:38,640 --> 00:01:41,700
这也是我们算法中的步骤。

27
00:01:41,700 --> 00:01:42,270
所以我们走了。

28
00:01:42,270 --> 00:01:44,310
这是两个最接近的点。

29
00:01:44,310 --> 00:01:47,460
现在我们将它们放在一个集群中。

30
00:01:47,460 --> 00:01:54,150
现在，我们想在此图上执行的操作是想以某种方式表明这些是

31
00:01:54,150 --> 00:02:00,490
确实是两个最接近的点，因为DNA gram有点像AC算法的记忆。

32
00:02:00,570 --> 00:02:03,590
记住我们正在执行的每个步骤。

33
00:02:03,750 --> 00:02:06,120
因此，那里有两个男孩P2和P3。

34
00:02:06,150 --> 00:02:11,670
我们如何表示我们已经将它们连接起来，并且它们是连接它们的最接近的孔

35
00:02:11,680 --> 00:02:13,690
会像一条水平线一样使用。

36
00:02:13,770 --> 00:02:17,850
但是，然后我们将其放置在最底部，我们将放置在更高的位置。

37
00:02:18,000 --> 00:02:19,920
用什么来确定距离。

38
00:02:19,920 --> 00:02:22,320
我们要去多高的地方。

39
00:02:22,470 --> 00:02:29,040
因此，实际上将这条线放置在这个高度上实际上意味着这个高度是中间距离

40
00:02:29,040 --> 00:02:29,950
它们之间。

41
00:02:30,090 --> 00:02:36,930
并且它还表示计算出的两个点之间的相似性是两个聚类。

42
00:02:36,930 --> 00:02:39,510
这意味着两点距离更远。

43
00:02:39,510 --> 00:02:42,220
因此，例如P2与P3相距甚远。

44
00:02:42,420 --> 00:02:47,230
对我们来说，这可能是一个变量，可能是一个人的年龄。

45
00:02:47,370 --> 00:02:47,630
对。

46
00:02:47,640 --> 00:02:52,440
例如，这个变量可能是一个人的工资。

47
00:02:52,560 --> 00:02:52,870
对。

48
00:02:52,890 --> 00:02:57,760
或者，这个变量可能是一个人在公司里待了多长时间以及这个。

49
00:02:57,840 --> 00:03:00,680
此变量可以是人员的薪水。

50
00:03:00,760 --> 00:03:01,530
或类似的东西。

51
00:03:01,530 --> 00:03:09,420
所以基本上我们可以看到P2和P3之间的距离是P2和P4之间的距离

52
00:03:09,420 --> 00:03:15,150
它们之间的距离更大，这意味着这两个点P2和P3具有一定的相似性

53
00:03:15,150 --> 00:03:21,060
通过它们之间的距离来衡量，因此该距离代表了两者之间的差异

54
00:03:21,060 --> 00:03:26,280
P2和之前的两个点也有不同点，并且更大，因为您可以看到

55
00:03:26,280 --> 00:03:27,180
距离更大。

56
00:03:27,180 --> 00:03:33,350
因此，可以说这是年龄还是工资这两个点，即使它们并不相同

57
00:03:33,390 --> 00:03:38,570
在年龄和薪资方面，他们的差异不如P2和P4。

58
00:03:38,580 --> 00:03:43,110
同样，这些变量只是任意变量，只是调用任意变量，它们可以是任何东西

59
00:03:43,110 --> 00:03:45,880
否则，此数据集可能不完整。

60
00:03:45,890 --> 00:03:52,240
它可能是一台机器，也可能是欧洲核子研究组织从自然界观察到的几乎所有事物。

61
00:03:52,530 --> 00:03:57,470
这里的要点是，它们相距越远，两点就越不相似。

62
00:03:57,480 --> 00:04:03,480
这是根据该栏的高度在Gramp身份中测量或捕获的，我们将其设置为多高

63
00:04:03,470 --> 00:04:03,810
它。

64
00:04:03,870 --> 00:04:07,300
然后，条形图本身仅向我们显示我们已连接P2和P3。

65
00:04:07,320 --> 00:04:07,560
好吧。

66
00:04:07,560 --> 00:04:09,730
这是我们在丹佛的第一步。

67
00:04:10,020 --> 00:04:16,890
接下来，我们将继续前进，我们将继续进行庇护所的下一步，我们可以执行

68
00:04:16,890 --> 00:04:17,950
第三步。

69
00:04:17,970 --> 00:04:22,980
因此，我们将在接下来的两个最接近的集群中进行查找并将它们连接起来。

70
00:04:22,980 --> 00:04:27,380
因此，在这里，我们得到了这四个点中的每个点都是一个集群。

71
00:04:27,370 --> 00:04:28,680
然后我们有了这个集群。

72
00:04:28,710 --> 00:04:31,290
现在我们需要找到最接近的两个。

73
00:04:31,440 --> 00:04:37,700
再说一遍，或者从我们看到的其他两个最接近的角度，让我们对其进行概述。

74
00:04:37,950 --> 00:04:38,610
我们到了。

75
00:04:38,610 --> 00:04:40,170
因此，现在它们形成了自己的集群。

76
00:04:40,170 --> 00:04:43,050
现在我们还要在den trigram中指出这一点。

77
00:04:43,050 --> 00:04:46,720
因此，我们将再次放置垂直或水平线。

78
00:04:46,740 --> 00:04:49,710
我们将其替换的位置有多高。

79
00:04:49,700 --> 00:04:51,920
高于或低于此线。

80
00:04:52,080 --> 00:04:59,010
好吧，我们同意该垂直轴代表欧几里得距离，而欧几里德距离代表

81
00:04:59,130 --> 00:05:02,960
我们两个观察之间的差异。

82
00:05:02,970 --> 00:05:09,480
所以在这里我们可以看到P5和P-Six实际上相距比三个之间的距离更远，这当然是

83
00:05:09,660 --> 00:05:17,070
很自然，因为如果P5和P-Six距离更近，那么在上一步中，我们就不会放两个

84
00:05:17,070 --> 00:05:21,340
还有三分之一的距离，我们会记住P5和六分之一的集群。

85
00:05:21,360 --> 00:05:24,600
我们一直在寻找最接近的，然后我们继续下一步。

86
00:05:24,600 --> 00:05:31,290
所以在B-3之间我们是最接近的，这就是为什么这个距离P5和D6距离

87
00:05:31,290 --> 00:05:34,130
彼此之间的距离必须大于P2和P3，因此距离必须更大。

88
00:05:34,350 --> 00:05:39,960
这就是为什么我们要在图表上显示该条设置得更高的原因。

89
00:05:39,990 --> 00:05:40,740
好吧。

90
00:05:40,800 --> 00:05:46,370
下一步是再次重复步骤3，因此我们将在这些步骤中进行查找。

91
00:05:46,500 --> 00:05:49,770
所有这些簇都是最接近的。

92
00:05:49,770 --> 00:05:50,670
所以我们走了。

93
00:05:50,670 --> 00:05:54,230
所以这是我要回到这里的最接近的那个。

94
00:05:54,270 --> 00:06:00,480
这个星团更接近这个星团，包含所有距离更近的星团

95
00:06:00,480 --> 00:06:01,200
在集群之间。

96
00:06:01,200 --> 00:06:06,280
这又是最低的，这取决于您测量距离的方式。

97
00:06:06,280 --> 00:06:13,260
您可以看到before和此群集之间的距离非常接近此距离。

98
00:06:13,320 --> 00:06:17,010
但是，我们要说的是最后的距离。

99
00:06:17,010 --> 00:06:17,310
好吧。

100
00:06:17,310 --> 00:06:22,020
因此，接下来我们要做的是将这些群集合并为一个群集。

101
00:06:22,020 --> 00:06:23,740
那里就是那里。

102
00:06:23,740 --> 00:06:24,870
所以现在我们有了一个集群。

103
00:06:24,870 --> 00:06:29,280
现在我们需要在这里以某种方式表示它，所以我们要做的就是将这个拥有的集群

104
00:06:29,430 --> 00:06:32,220
与P1连接。

105
00:06:32,220 --> 00:06:39,690
因此，我们将再次绘制一条线，并在此处再次绘制垂直线，

106
00:06:39,740 --> 00:06:47,340
从P1到此处顶部的距离代表该簇之间的差异

107
00:06:47,340 --> 00:06:47,860
我们有。

108
00:06:47,880 --> 00:06:51,350
我们将其连接到什么地方？

109
00:06:51,360 --> 00:06:53,500
好的，现在让我们连接。

110
00:06:53,760 --> 00:06:54,270
让我们找出。

111
00:06:54,270 --> 00:07:00,390
下一步又是什么，下一步是第三步，我们将从一两个三簇中寻找

112
00:07:00,390 --> 00:07:01,980
最接近的

113
00:07:01,980 --> 00:07:05,030
好吧，这是以前的事情，并且与这些事情最接近。

114
00:07:05,280 --> 00:07:06,390
再次出现。

115
00:07:06,390 --> 00:07:08,170
我们正在扩大集群。

116
00:07:08,190 --> 00:07:13,020
现在，我们将在丹佛格兰普上代表，因为您可以看到这条线的高度与

117
00:07:13,020 --> 00:07:18,030
上一条线，因为P1和该簇之间的距离与该距离大致相同

118
00:07:18,030 --> 00:07:20,150
在四到五到六之间。

119
00:07:20,250 --> 00:07:22,760
也许这个更大。

120
00:07:22,920 --> 00:07:28,040
有时很难说，这就是为什么我们拥有算法，这就是机器为我们做到的原因。

121
00:07:28,050 --> 00:07:34,560
到目前为止，我们的数据报看起来是这样的原因之一，而我们的最后一步是将剩下的这两个结合起来

122
00:07:34,560 --> 00:07:39,030
集群，因为默认情况下它们将是最接近的，因为没有其他集群。

123
00:07:39,030 --> 00:07:42,750
所以我们将把它们结合起来并用Adinda gram表示。

124
00:07:42,780 --> 00:07:48,810
因此，这里的热线电话非常热，因为两者之间的距离差异非常大

125
00:07:48,810 --> 00:07:49,530
集群。

126
00:07:49,830 --> 00:07:50,470
然后我们走了。

127
00:07:50,580 --> 00:07:56,020
这就是我们从头到尾缓慢构建DNA Graham的方式。

128
00:07:56,250 --> 00:08:02,370
最后，我们得到了一个集群或所有这些都是一个集群，这就是我的意思，当

129
00:08:02,370 --> 00:08:07,070
我说地下包含分层聚类算法的内存。

130
00:08:07,110 --> 00:08:12,330
因此，您只需查看丹佛语法即可了解这些类的形成顺序

131
00:08:13,020 --> 00:08:19,470
这是一个例子，所以这是由算法生成的计算机生成的实际例子

132
00:08:19,830 --> 00:08:22,380
向我们展示了层次聚类。

133
00:08:22,380 --> 00:08:28,320
所以我们在这里有要点，我们在这边有五角星形，这就是它的实际外观

134
00:08:28,320 --> 00:08:29,280
喜欢。

135
00:08:29,280 --> 00:08:34,470
好吧，现在我们知道在下一个教程中Grahams的构造密度如何

136
00:08:34,470 --> 00:08:42,270
使用它们来增强我们或实际执行我们的分层聚类算法。

137
00:08:42,270 --> 00:08:43,200
所以我们走了。

138
00:08:43,200 --> 00:08:45,660
希望您喜欢今天的教程，下次再讲。

139
00:08:45,660 --> 00:08:47,490
直到那时在德国学习

