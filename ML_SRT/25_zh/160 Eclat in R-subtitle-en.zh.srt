1
00:00:00,240 --> 00:00:02,330
您好，欢迎来到本美术教程。

2
00:00:02,520 --> 00:00:07,740
因此，在上一节中，我们实现了先验模型以查找一些相关的关联规则

3
00:00:07,890 --> 00:00:13,110
可以帮助我们在南部的杂货店中找到一些更具战略意义的产品放置

4
00:00:13,110 --> 00:00:13,860
法国。

5
00:00:14,040 --> 00:00:18,780
因此，由于这些关联规则，该商店的经理很可能会优化

6
00:00:18,780 --> 00:00:24,540
销售并因此增加收入，因此我们设法在此方面创造一些附加值

7
00:00:24,540 --> 00:00:27,710
业务得益于关联规则学习。

8
00:00:27,780 --> 00:00:34,770
今天，我们将实施一种称为Ekla模型的新的关联学习模型

9
00:00:34,790 --> 00:00:35,070
。

10
00:00:35,310 --> 00:00:39,710
因此，我想说的第一件事是防止您可能会感到失望。

11
00:00:39,900 --> 00:00:45,450
与我们之前所做的相比，A类模型实际上非常简单，因为该示例是

12
00:00:45,450 --> 00:00:50,520
基本上简化了先验模型，因为以前我们有两个参数。

13
00:00:50,520 --> 00:00:53,670
我们有支持和信心，我们也有左翼。

14
00:00:53,730 --> 00:00:57,830
顺便说一下，当我们按规则的递减顺序对规则进行排序时。

15
00:00:58,080 --> 00:01:03,720
但是在云中，我们只有一个参数，它将是支持参数，因此

16
00:01:03,720 --> 00:01:09,270
当我们获得规则时，这些规则将不是我们先前获得的规则，或者像购买商品的人那样

17
00:01:09,270 --> 00:01:14,910
这也买了，但是我们经常会得到一些不同的产品，但是我们在一起

18
00:01:14,910 --> 00:01:19,720
将获得最常见的预购产品。

19
00:01:19,740 --> 00:01:20,960
这就是我们所得到的。

20
00:01:20,970 --> 00:01:22,360
我们必须期待这一点。

21
00:01:22,500 --> 00:01:28,980
但是您知道，如果您没有太多时间想要获得一些简单的结果，那么这可能非常有用。

22
00:01:28,980 --> 00:01:29,110
。

23
00:01:29,190 --> 00:01:33,690
如果您不想使用太多参数来支持这种信心，我们甚至都不会

24
00:01:33,690 --> 00:01:35,600
必须计算支撑的价值。

25
00:01:35,610 --> 00:01:40,350
此外，我们甚至不必为信心选择价值，因为没有信心

26
00:01:40,350 --> 00:01:41,150
参数。

27
00:01:41,340 --> 00:01:46,090
因此，您将看到这是最简单的使用关联规则学习的方法。

28
00:01:46,230 --> 00:01:47,430
所以现在就开始吧。

29
00:01:47,460 --> 00:01:49,990
在本教程的最后，您将明白我的意思。

30
00:01:50,100 --> 00:01:52,120
因此，让我们从第一步开始。

31
00:01:52,290 --> 00:01:57,990
设置正确的工作目录将使我们的机器更完整地进入第5部分

32
00:01:57,990 --> 00:01:58,870
规则学习。

33
00:01:58,980 --> 00:02:01,040
现在我们在一个俱乐部中。

34
00:02:01,200 --> 00:02:06,260
因此，这就是我们拥有的市场购物篮优化功能可以解决相同的业务问题。

35
00:02:06,420 --> 00:02:10,760
因此，我们可以在此处单击更多按钮，现在为我们设置工作目录。

36
00:02:11,010 --> 00:02:17,400
而且您知道，自从我告诉您以来，该示例是Premium的简化版本，或者是我们将要做的

37
00:02:17,400 --> 00:02:24,060
现在采用我们的先验模型，您将看到它几乎是相同的，我们只需要

38
00:02:24,060 --> 00:02:25,280
改变一件事。

39
00:02:25,440 --> 00:02:30,070
因此，我将从这里选择所有内容。

40
00:02:30,360 --> 00:02:34,260
复制并粘贴在喧闹的地方。

41
00:02:34,380 --> 00:02:35,260
好吧。

42
00:02:35,430 --> 00:02:39,920
因此，在本节中，数据预处理没有任何更改。

43
00:02:39,970 --> 00:02:47,290
我们将要导入具有区域实际功能的数据集，请注意不要与结果有关

44
00:02:47,390 --> 00:02:54,180
我们找到了，因为我们仍然需要我们的稀疏矩阵，这也是Ekla函数的输入

45
00:02:54,390 --> 00:02:56,300
如此处的先验功能。

46
00:02:56,550 --> 00:03:00,260
因此，我们将选择它并执行。

47
00:03:00,420 --> 00:03:05,700
当然，我们得到的CSP文件重复次数相同。

48
00:03:05,700 --> 00:03:09,870
我们有五个重复项，没有重复的只有五个重复项。

49
00:03:10,020 --> 00:03:10,830
好。

50
00:03:10,830 --> 00:03:15,870
然后，我们当然可以使用summary函数来获取有关此数据集的一些信息，但是当然这些

51
00:03:15,870 --> 00:03:17,750
对我们来说将是一样的。

52
00:03:17,820 --> 00:03:26,880
因此，我们有7500个交易，共有119种产品，密度为0.03，这意味着

53
00:03:26,880 --> 00:03:32,260
矩阵中非零值的比例为0.03 3％。

54
00:03:32,480 --> 00:03:34,520
然后，我们当然拥有最常使用的物品。

55
00:03:34,590 --> 00:03:40,950
首先是矿泉水，然后是鸡蛋，实际上，我们可以更好地了解这些最常见的物品

56
00:03:41,250 --> 00:03:43,400
通过选择此行并执行。

57
00:03:43,560 --> 00:03:46,580
当然，我们得到相同的频率图。

58
00:03:46,590 --> 00:03:48,230
所以那完全像以前一样。

59
00:03:48,240 --> 00:03:50,640
但是，我们在这里没有任何更改。

60
00:03:50,760 --> 00:03:56,660
现在，我们进入第二个代码部分，以在数据集上训练eclat模型，因此对我们来说

61
00:03:56,670 --> 00:04:01,060
只是在这里用时钟代替先验。

62
00:04:01,080 --> 00:04:01,880
开始了。

63
00:04:02,190 --> 00:04:04,680
猜猜它是如此简单。

64
00:04:04,680 --> 00:04:08,500
在这里，我们具有先验功能来训练先验或模型。

65
00:04:08,610 --> 00:04:11,660
并猜出训练Clamato的功能是什么。

66
00:04:11,730 --> 00:04:13,860
将会是埃克拉。

67
00:04:14,100 --> 00:04:15,120
非常简单。

68
00:04:15,180 --> 00:04:21,750
我们几乎准备在我们的数据集上训练Ekla，但相机当然要简单得多。

69
00:04:21,780 --> 00:04:24,510
它不包括置信度和参数。

70
00:04:24,510 --> 00:04:28,980
如果现在，我们从直觉教程中获得eclat算法的幻灯片。

71
00:04:29,160 --> 00:04:35,250
好，我们可以看到Ekla算法包含三个步骤，第一步是设置最低支持

72
00:04:35,250 --> 00:04:35,460
。

73
00:04:35,550 --> 00:04:40,710
请记住，在使用apriori算法之前，第一步是设置最小支持和最小

74
00:04:40,710 --> 00:04:41,670
置信度。

75
00:04:41,670 --> 00:04:45,470
现在，我们只需要设置最低支持，因此我们不需要这样做。

76
00:04:45,510 --> 00:04:51,450
实际上，此参数仅适用于先验模型，因此，如果我们保留该参数，将会得到一个错误，因此我将

77
00:04:51,450 --> 00:04:56,750
只需删除此选项，我们就可以将最小支持设为0.04。

78
00:04:56,760 --> 00:04:59,580
但是您会发现这里甚至没有必要。

79
00:04:59,580 --> 00:05:06,330
您将看到为什么最后但是我们可能需要添加另一个参数，因为既然您知道我提到过

80
00:05:06,330 --> 00:05:13,240
该算法将返回一组最常一起购买的物品。

81
00:05:13,410 --> 00:05:17,410
好吧，只有一个项目才是一件有趣的事情。

82
00:05:17,430 --> 00:05:23,580
因此，为了获得至少两个项目的一些集合，我们将在此处添加另一个参数

83
00:05:23,580 --> 00:05:31,110
这是主线参数，我们将其设置为2，因为我们想

84
00:05:31,110 --> 00:05:35,800
将至少两个项目的不同集合最常一起预紧。

85
00:05:36,130 --> 00:05:37,900
好的，现在我们准备好了。

86
00:05:38,010 --> 00:05:39,440
看看这是多么简单。

87
00:05:39,510 --> 00:05:46,050
因此，让我们选择它并在完成的数据集上训练Clamato。

88
00:05:46,400 --> 00:05:47,020
好。

89
00:05:47,430 --> 00:05:49,840
所以现在情况有所改变。

90
00:05:49,860 --> 00:05:56,190
当然，首先我们看到显然只是训练了骆驼，然后我们有了参数说明

91
00:05:56,190 --> 00:05:59,160
像以前一样，但是这次我们没有信心参数。

92
00:05:59,160 --> 00:06:03,050
我们拥有设为0.04的支持。

93
00:06:03,050 --> 00:06:04,520
那是最小的支持。

94
00:06:04,740 --> 00:06:09,840
当然，这一次，我们有一个最小值要记住，然后将millin参数设置为

95
00:06:09,840 --> 00:06:15,970
1，但是我们没有任何问题，因为我们的所有规则至少包含两种产品，但

96
00:06:15,990 --> 00:06:22,320
使用Ekla时，我们需要将此最小参数设置为2，因为否则我们会得到一些

97
00:06:22,320 --> 00:06:23,890
只有一项。

98
00:06:24,210 --> 00:06:27,870
好的，那么我们这里有其他更高级的信息。

99
00:06:27,960 --> 00:06:31,210
然后，我想在这里强调一下。

100
00:06:31,350 --> 00:06:34,950
它是集合的数量而不是规则。

101
00:06:34,950 --> 00:06:38,990
记住，在我们知道您之前，我们有845个。

102
00:06:39,060 --> 00:06:44,120
它写成八百四十五条规则，因为我们有论坛的规则。

103
00:06:44,220 --> 00:06:49,300
如果人们像奶油一样撒谎，那么他们可能会以40％的信心购买鸡肉

104
00:06:49,500 --> 00:06:51,010
有40％的机会。

105
00:06:51,180 --> 00:06:57,420
在这里，由于您知道我们没有得到这种形式的规则，所以我们只得到项目集

106
00:06:57,430 --> 00:06:57,560
。

107
00:06:57,720 --> 00:06:58,990
好吧，这次我们确实有。

108
00:06:59,170 --> 00:07:01,110
八百四十五套。

109
00:07:01,110 --> 00:07:07,170
因此，即使A类被视为规则早期模型的协会，这也不会返回规则

110
00:07:07,200 --> 00:07:09,370
确实返回了一些集合。

111
00:07:09,630 --> 00:07:12,560
好，我们现在就来看一下这些场景。

112
00:07:12,630 --> 00:07:18,690
我们已经准备好迈向角色的最后一步，实际上我们可以跳回到幻灯片上，

113
00:07:18,690 --> 00:07:23,970
我们可以看到第二步是获取所有子集和交易的支持高于最小

114
00:07:23,970 --> 00:07:24,420
支持。

115
00:07:24,420 --> 00:07:26,850
这就是功能包夹所在的地方。

116
00:07:26,970 --> 00:07:31,910
然后最后一步第三步是通过减少支持来对子集进行排序。

117
00:07:31,980 --> 00:07:37,310
因此，这一次并没有像先验的那样通过减少左移来解决。

118
00:07:37,440 --> 00:07:44,190
因此，这次我们将通过减少支持来对规则进行排序。

119
00:07:44,200 --> 00:07:44,760
好吧。

120
00:07:44,760 --> 00:07:49,860
我们将在10个第一世界中获得10个最高支持，因此我们已经准备好了。

121
00:07:49,950 --> 00:07:52,550
好了，整个代码实际上已经准备好了。

122
00:07:52,620 --> 00:07:55,500
我们非常有效地做到了这很简单。

123
00:07:55,530 --> 00:08:01,320
所以最终让我们看一下规则，您会发现它更加简单和诚实

124
00:08:01,320 --> 00:08:03,570
没有先验的有趣。

125
00:08:03,750 --> 00:08:05,180
但这就是我们所得到的。

126
00:08:05,190 --> 00:08:08,970
因此，我将选择此行并执行。

127
00:08:09,180 --> 00:08:17,660
正如我刚刚告诉您的那样，我们只不过获得了最常一起购买的不同套物品。

128
00:08:17,670 --> 00:08:24,150
因此，例如，最常一起购买的一组商品是矿泉水和意大利面，

129
00:08:24,150 --> 00:08:27,210
点0 5的支撑9。

130
00:08:27,210 --> 00:08:32,560
然后是巧克力，然后是巧克力和矿泉水，然后是鸡蛋和矿泉水。

131
00:08:32,640 --> 00:08:35,090
这当然与此密切相关。

132
00:08:35,310 --> 00:08:38,090
商店中最常购买的产品。

133
00:08:38,280 --> 00:08:41,870
因此，结果比先验有趣得多。

134
00:08:42,000 --> 00:08:46,180
但是，如果您正在寻找一些非常简单的信息，那可能会非常有用。

135
00:08:46,230 --> 00:08:52,800
顺便说一句，因为我告诉过您，我们是否知道更改了支持并将其设置为0.03，就像我们

136
00:08:52,800 --> 00:08:55,520
首先是先验模型。

137
00:08:55,680 --> 00:09:00,930
好吧，您会看到我们在这里得到相同的排名，因为您可以看到这10个支持者

138
00:09:00,930 --> 00:09:09,320
最常进行预追随的第一组物品的支持率都高于0.04或0.03。

139
00:09:09,330 --> 00:09:16,780
所以的确，如果我们以最低支持0.03训练Clamato，然后再次选择

140
00:09:16,800 --> 00:09:25,040
执行时，我们得到的排名相同，首先是矿泉水和意大利面，然后是冷冻蔬菜

141
00:09:25,050 --> 00:09:30,470
矿泉水是最经常一起预购的第十组产品。

142
00:09:30,480 --> 00:09:33,110
好的，那就是克莱蒙索。

143
00:09:33,330 --> 00:09:38,430
同样，如果您想对如何为您的业务创造一些增值进行认真的分析

144
00:09:38,730 --> 00:09:42,570
优化您应该先验的销售和收入。

145
00:09:42,750 --> 00:09:48,120
但是，如果您要查找一些非常简单的信息，例如最经常在购买前购买的产品集

146
00:09:48,120 --> 00:09:51,120
在一起，那么你可以去乌云密布。

147
00:09:51,390 --> 00:09:53,110
无论如何，恭喜你。

148
00:09:53,220 --> 00:09:58,900
您现在知道了如何实现先验角色模型和Ekla的关联。

149
00:09:59,070 --> 00:10:01,170
而且您知道该如何使用它们。

150
00:10:01,170 --> 00:10:05,670
因此，非常感谢您观看这些教程，我期待在下一部分中与您见面

151
00:10:05,670 --> 00:10:05,770
。

152
00:10:05,850 --> 00:10:07,560
强化学习。

153
00:10:07,560 --> 00:10:09,490
在此之前，请享受机器学习。

