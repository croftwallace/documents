1
00:00:00,300 --> 00:00:02,690
您好，欢迎来到本Python教程。

2
00:00:02,760 --> 00:00:08,010
因此，在上一节中，我们介绍了我们的业务问题，今天我们将使用

3
00:00:08,020 --> 00:00:09,780
Python中的Kamins。

4
00:00:09,810 --> 00:00:11,220
所以这里是Python。

5
00:00:11,220 --> 00:00:16,350
我们要做的第一件事是设置工作目录，因此我们在此单击该文件夹。

6
00:00:16,560 --> 00:00:18,720
然后我们进入机器学习文件夹。

7
00:00:18,780 --> 00:00:24,720
然后是第3部分聚类，最后打开Kamins聚类部分文件夹，然后单击select

8
00:00:25,320 --> 00:00:28,350
完美，找到包含数据集的文件夹。

9
00:00:28,650 --> 00:00:32,870
并且不要忘了单击此处将我们的文件夹设置为工作目录。

10
00:00:33,240 --> 00:00:36,910
现在，让我们逐步实现Kamins算法。

11
00:00:36,930 --> 00:00:43,650
因此，像往常一样，首先是导入库，因此我们编写了导入库的注释，

12
00:00:43,650 --> 00:00:51,000
在下面导入三个基本库Numby以使用数学matplotlib绘制漂亮的图表

13
00:00:51,450 --> 00:00:55,230
和Pender可以更轻松地导入和管理数据集。

14
00:00:55,230 --> 00:01:00,010
我们选择三个导入，然后按Command Control Pass Enter执行它们。

15
00:01:00,180 --> 00:01:00,930
完善。

16
00:01:00,930 --> 00:01:05,820
现在，我们继续执行第二步，即使用熊猫导入小型数据集。

17
00:01:05,820 --> 00:01:09,420
好的，所以在这里我将写这篇文章来介绍这一新步骤。

18
00:01:09,420 --> 00:01:17,100
使用bander将它们导入所有数据集并导入此数据集，我们只需编写等于

19
00:01:17,310 --> 00:01:24,300
读取下划线sizzix和括号并带有引号的数据集的PD。

20
00:01:24,300 --> 00:01:29,760
现在点c，我们确保该数据集在您的工作目录文件夹中。

21
00:01:29,940 --> 00:01:33,470
如果是这种情况，让我们选择这一行代码并执行。

22
00:01:33,570 --> 00:01:33,930
大。

23
00:01:33,930 --> 00:01:38,000
现在，我们转到变量资源管理器，以查看数据集的外观。

24
00:01:38,040 --> 00:01:38,790
这里是。

25
00:01:38,940 --> 00:01:42,550
让我们双击它，然后打开小数据集。

26
00:01:42,570 --> 00:01:47,520
好的，让我们重新解释一下这个小型数据集的含义以及我们的任务是什么。

27
00:01:47,550 --> 00:01:53,400
在特定城市中有一个大型购物中心，其中包含客户的信息，订阅的客户

28
00:01:53,400 --> 00:01:58,800
当客户订阅会员卡时，他们会提供会员卡信息，例如会员卡

29
00:01:58,800 --> 00:02:02,020
性别，年龄和年收入。

30
00:02:02,250 --> 00:02:05,880
而且因为他们有这张卡，所以可以用它来购买商场中的各种物品。

31
00:02:06,030 --> 00:02:09,480
因此，购物中心必须购买其每个客户成员的历史记录。

32
00:02:09,600 --> 00:02:13,500
这就是他们在这里获得支出得分的最后一列的方式。

33
00:02:13,500 --> 00:02:18,390
因此提醒您，支出分数是指为每个客户计算的金额

34
00:02:18,660 --> 00:02:24,090
基于几个标准，例如包括他们的收入，每周显示的次数

35
00:02:24,090 --> 00:02:24,980
在商场里。

36
00:02:25,200 --> 00:02:30,180
当然，他们一年中花费的金额，并根据所有这些计算出此指标

37
00:02:30,180 --> 00:02:32,640
取值介于1到100之间。

38
00:02:32,820 --> 00:02:38,820
因此，支出得分越接近2 1，支出下降得越少，支出就越接近

39
00:02:38,820 --> 00:02:41,710
得分达到100时，下降支出越多。

40
00:02:41,970 --> 00:02:48,300
最终，在收集了这些数据集之后，公司雇用了您作为机器赚钱科学家，

41
00:02:48,300 --> 00:02:52,610
根据这两个指标将客户分为两个不同的组。

42
00:02:52,610 --> 00:02:58,140
年收入和支出得分，并且由于购物中心不知道该客户细分的对象

43
00:02:58,140 --> 00:03:02,200
可能甚至不知道会有多少段。

44
00:03:02,310 --> 00:03:06,520
这通常是一个群集问题，因为我们不知道答案。

45
00:03:06,540 --> 00:03:12,330
因此，现在让我们开始我们的任务，并使用Kamins算法找出那些客户群

46
00:03:12,330 --> 00:03:13,500
可能。

47
00:03:13,500 --> 00:03:15,760
因此，这里我们只是导入了数据集。

48
00:03:15,870 --> 00:03:21,480
该数据集已由bandha导入为数据框，现在我们将构建一个包含以下内容的数组

49
00:03:21,480 --> 00:03:26,880
我们对年收入和支出得分感兴趣的两列，为此，我们只需

50
00:03:26,880 --> 00:03:36,580
写X，这是我们给数组的名称，它等于I LRC的数据集，并在方括号中是Collen

51
00:03:36,860 --> 00:03:39,790
指定我们希望所有行都出现。

52
00:03:40,020 --> 00:03:44,100
现在再次在方括号中放入列的两个索引。

53
00:03:44,100 --> 00:03:50,690
因此，让我们再次打开数据集的索引和字节，并从零开始，这样我们就算出0 1 2。

54
00:03:50,820 --> 00:03:54,950
因此，年收入的指数为3，纺纱得分的指数为。

55
00:03:55,140 --> 00:04:00,300
好的，让我们关闭它，回到我们的代码中，我们将我们的两个索引3和4放在这里

56
00:04:00,300 --> 00:04:01,510
感兴趣的列。

57
00:04:01,680 --> 00:04:05,460
最终，我们通过DOT值结束了这一行代码。

58
00:04:05,480 --> 00:04:05,900
好。

59
00:04:05,920 --> 00:04:09,180
就像这行代码一样，完美执行。

60
00:04:09,270 --> 00:04:16,580
它创建了两列的数组x，我们可以通过单击x在此处可视化。

61
00:04:16,680 --> 00:04:22,200
现在，我们已经完成了导入数据的准备工作，可以开始下一步了，那就是

62
00:04:22,200 --> 00:04:27,860
事情开始变得有趣，因为现在我们将开始专门使用Kamins。

63
00:04:27,920 --> 00:04:33,060
好吧，因为我们不知道要寻找什么，所以我们实际上不知道客户集群的数量

64
00:04:33,060 --> 00:04:38,580
寻找并记住当我们在预览部分了解卡明斯直觉时，我们发现

65
00:04:38,580 --> 00:04:43,860
我们使用Kamins，我们必须选择这个数量的集群，而这正是我们要做的

66
00:04:43,860 --> 00:04:44,610
马上。

67
00:04:44,670 --> 00:04:50,720
我们将为我们的问题找出最佳的聚类数，当然这样做

68
00:04:50,730 --> 00:04:52,470
将要使用肘部方法。

69
00:04:52,530 --> 00:04:58,470
因此，让我们用弯头方法在下面的注释中介绍这一新步骤，以找到最佳方法

70
00:04:58,470 --> 00:04:59,680
集群数。

71
00:05:00,490 --> 00:05:03,880
首先，我们从Sikat Learn导入Kamins类。

72
00:05:03,970 --> 00:05:08,860
因此，我们从S-K那里学习到群集导入Kamins。

73
00:05:09,060 --> 00:05:11,620
现在让我们绘制弯头方法图。

74
00:05:11,620 --> 00:05:16,810
因此，要绘制此图，我们将计算10个不同数字的群集内平方和

75
00:05:16,810 --> 00:05:17,650
集群。

76
00:05:17,860 --> 00:05:23,050
因此，由于我们要进行10次迭代，因此我们将编写一个完整的循环来创建列表

77
00:05:23,050 --> 00:05:27,160
簇数的簇平方和内有10个不同。

78
00:05:27,160 --> 00:05:34,430
因此，我们首先初始化此列表，我们将其称为WCA SS WCA SS等于空方括号。

79
00:05:34,570 --> 00:05:39,730
然后，我们在1到11的范围内为我开始循环。

80
00:05:39,850 --> 00:05:45,810
因此，我们选择11而不是10，因为排除了11个界限，而我们想要10个WCOS。

81
00:05:45,820 --> 00:05:48,370
但是，包含第一个绑定。

82
00:05:48,370 --> 00:05:52,880
所以在这里，我将取值1 2 3 4 5 6 7 8 9 10。

83
00:05:52,900 --> 00:05:56,560
现在，在此循环的每次迭代中，我们将做两件事。

84
00:05:56,620 --> 00:05:59,880
首先，我们将Kamins算法拟合到我们的数据x。

85
00:05:59,920 --> 00:06:06,490
其次，我们将计算群集内平方和，并附加到WCA SS列表中。

86
00:06:06,490 --> 00:06:12,700
好吧，让我们首先拟合数据X，我们将创建Kamins类的对象，然后

87
00:06:12,700 --> 00:06:13,940
叫它进来。

88
00:06:14,200 --> 00:06:21,840
因此，我们写k表示对象等于资本为K N的Kamins，即类。

89
00:06:21,970 --> 00:06:27,870
在这个类中，我们将放置几个参数，第一个参数是

90
00:06:27,880 --> 00:06:29,250
集群数。

91
00:06:29,350 --> 00:06:34,480
并且由于我们正在测试多个集群以构建Elbot方法图，因此

92
00:06:34,480 --> 00:06:37,690
集群和集群将成为我们的变量。

93
00:06:37,690 --> 00:06:38,020
一世。

94
00:06:38,130 --> 00:06:44,680
这将采用1到10下一个参数的值作为随机初始化方法

95
00:06:44,680 --> 00:06:45,010
。

96
00:06:45,070 --> 00:06:49,570
如果要完成对初始质心的随机选择，则可以选择“随机”。

97
00:06:49,750 --> 00:06:53,120
但是我们不想陷入随机初始化陷阱。

98
00:06:53,250 --> 00:06:58,330
因此，我们将使用在Kamins直觉部分中看到的非常强大的方法

99
00:06:58,330 --> 00:07:01,420
当然，Kamins plus plus初始化方法。

100
00:07:01,660 --> 00:07:06,830
因此，在这里，我们用等号加上加引号之间的加号。

101
00:07:06,910 --> 00:07:09,450
然后，下一个参数是Max Inter。

102
00:07:09,550 --> 00:07:15,370
这是Kamins算法发现最终簇的最大迭代次数

103
00:07:15,430 --> 00:07:16,300
在跑。

104
00:07:16,450 --> 00:07:19,480
此参数的默认值为300。

105
00:07:19,500 --> 00:07:21,880
这就是我们要选择的价值。

106
00:07:21,880 --> 00:07:27,670
然后下一个参数是其中的一个，它是Kamins算法将运行的次数

107
00:07:27,670 --> 00:07:29,440
不同的初始质心。

108
00:07:29,640 --> 00:07:33,540
此参数的默认值为10，并将其设置为10。

109
00:07:33,700 --> 00:07:38,470
然后，我们可以添加其他参数，例如收敛容差，但我们将不讨论

110
00:07:38,470 --> 00:07:43,000
它们的详细信息，因为我们实际上不添加它们就将它们保留为其默认值

111
00:07:43,000 --> 00:07:44,350
这些括号中。

112
00:07:44,350 --> 00:07:46,170
他们保留其默认值。

113
00:07:46,180 --> 00:07:52,000
但是，我们在这里添加随机状态参数，该参数可修复Kamins进程的所有随机因素

114
00:07:52,260 --> 00:07:57,010
这样，当我们将其一起设置为零时，我们都将获得相同的结果。

115
00:07:57,120 --> 00:08:01,600
但是欢迎您不要看它，甚至删除此随机状态参数以查看会发生什么

116
00:08:01,620 --> 00:08:01,930
。

117
00:08:02,230 --> 00:08:08,260
好的，现在我们准备Kamins算法，但是我们仍然需要将其适合我们的数据X并执行此操作。

118
00:08:08,250 --> 00:08:15,670
非常简单，我们只需编写Kamins，这就是我们刚刚创建的对象，然后适合

119
00:08:15,670 --> 00:08:17,410
括号x。

120
00:08:17,590 --> 00:08:23,620
因此，fit是k类的一种方法，这当然意味着Kamins算法适合您的数据。

121
00:08:23,620 --> 00:08:28,390
现在，我们要做第二件事，即计算群集内平方和的和

122
00:08:28,380 --> 00:08:29,060
到我们的清单。

123
00:08:29,120 --> 00:08:34,950
WCA说，实际上，平方和之内还有另一个名字，叫做惯性

124
00:08:34,960 --> 00:08:35,410
。

125
00:08:35,400 --> 00:08:41,110
还要感谢sikat优秀的库，实际上有一个惯性属性可以计算

126
00:08:41,110 --> 00:08:42,940
用群集平方和做。

127
00:08:43,060 --> 00:08:49,120
因此，为了计算群集内平方和，我们编写代码k表示带有下划线的惯性

128
00:08:49,780 --> 00:08:52,310
并附加到我们的WCA清单中。

129
00:08:52,380 --> 00:09:00,020
我们写的代码WCA表示，追加并在括号中放入惯性计算k表示思想

130
00:09:00,070 --> 00:09:01,140
惯性。

131
00:09:01,140 --> 00:09:02,860
好的，我们完成了循环。

132
00:09:03,120 --> 00:09:06,330
现在，我们将绘制肘形图。

133
00:09:06,340 --> 00:09:13,470
因此，我们编写该图的BLT，然后将其设为父级，首先输入范围为1的x轴值

134
00:09:13,480 --> 00:09:19,330
到11，因为我们想要10个簇数，然后得出，然后我们将y轴的值

135
00:09:19,670 --> 00:09:22,010
当然是WCA SS。

136
00:09:22,210 --> 00:09:25,500
然后，通过键入BLT为我们的图表添加标题。

137
00:09:25,500 --> 00:09:29,080
放置标题时，该标题以括号结尾。

138
00:09:29,080 --> 00:09:30,650
肘法。

139
00:09:30,930 --> 00:09:37,450
然后，通过在X轴上键入p l t并在括号的簇数中添加一个名称到X轴

140
00:09:37,890 --> 00:09:44,180
同样，让我们​​通过输入pl t y标签WCA SS为y标签添加名称。

141
00:09:44,470 --> 00:09:50,080
最后但并非最不重要的一点是，显示带有括号的PLG类型的图表。

142
00:09:50,160 --> 00:09:50,580
好吧。

143
00:09:50,580 --> 00:09:55,830
现在，我很高兴在这里选择此代码部分并执行它以找出是否没有最优的

144
00:09:55,840 --> 00:09:57,020
集群数。

145
00:09:57,250 --> 00:09:59,790
因此，让我们在这里选择我们的代码。

146
00:09:59,800 --> 00:10:03,620
命令或控制加Enter键即可执行而精彩。

147
00:10:03,630 --> 00:10:09,940
我们获得了一个漂亮的Elbot方法图，该图具有非常明显的最佳簇数，从而使

148
00:10:09,930 --> 00:10:12,300
分为五个集群。

149
00:10:12,310 --> 00:10:18,250
的确，我们可以看到肘部在这里，当我们将此点投影到x轴上时，我们得到了x的续集

150
00:10:18,250 --> 00:10:20,310
5完美。

151
00:10:20,350 --> 00:10:25,420
因此，既然我们有了合适的脚轮数量，我们就可以继续进行下一步和下一个步骤

152
00:10:25,420 --> 00:10:31,740
步骤是将Kamins算法应用于我们的数据X。但这一次的簇数正确

153
00:10:31,740 --> 00:10:32,070
。

154
00:10:32,080 --> 00:10:37,880
因此，让我们介绍一个新的代码部分，其中将Kamins应用于mal数据集，这就是

155
00:10:37,900 --> 00:10:43,950
立即用正确数量的聚类5聚类对数据X进行50个Kamins算法。

156
00:10:44,020 --> 00:10:47,950
因此，我们已经知道该怎么做，因为这正是我们在循环中所做的。

157
00:10:48,250 --> 00:10:54,290
因此，我们写Kamins对象等于Kamins类。

158
00:10:54,370 --> 00:10:58,930
在括号中，我们输入了多个聚类，并且聚类等于5。

159
00:10:59,080 --> 00:11:05,890
然后对于随机初始化方法，我们将其等于Kamins加号加上加号，然后等于最大迭代次数

160
00:11:05,890 --> 00:11:05,980
。

161
00:11:05,980 --> 00:11:10,480
三百伦理10和随机状态等于零。

162
00:11:10,480 --> 00:11:12,210
这就是我们准备k均值的方式。

163
00:11:12,220 --> 00:11:17,020
然后仅在这一次我们将不使用fit方法的情况下才必须将其拟合到数据X。

164
00:11:17,020 --> 00:11:23,020
但是我们将使用拟合预测方法，该方法为每个观察返回其所属的簇

165
00:11:23,020 --> 00:11:23,820
至。

166
00:11:23,830 --> 00:11:29,200
因此，这意味着对于数据集的每个客户，拟合预测方法都会告诉我们

167
00:11:29,200 --> 00:11:35,950
下降所属的簇，它将把这个簇号返回到一个向量中

168
00:11:35,960 --> 00:11:44,070
我们将其称为y Kamins，因此在这里我们写下为什么Kamins等于适合预测X的Kamins。

169
00:11:44,080 --> 00:11:44,580
。

170
00:11:44,610 --> 00:11:45,490
好的，完美。

171
00:11:45,490 --> 00:11:50,020
现在，选择此代码部分，然后按Command或Control Enter执行。

172
00:11:50,020 --> 00:11:50,760
做完了

173
00:11:50,800 --> 00:11:56,020
现在，如果我们转到变量浏览器，我们可以看到我们有了一个新的簇数向量。

174
00:11:56,020 --> 00:11:57,580
Y k的意思就在这里。

175
00:11:57,580 --> 00:11:59,610
因此，我们双击它以将其打开。

176
00:11:59,710 --> 00:12:01,920
让我们也打开数据集。

177
00:12:02,200 --> 00:12:07,240
现在我们可以看到第一号客户属于集群号，第二号客户属于

178
00:12:07,240 --> 00:12:12,810
将第三个客户聚类到第三个客户属于第4个客户，依此类推。

179
00:12:12,820 --> 00:12:13,110
好的。

180
00:12:13,120 --> 00:12:16,360
因此，让我们关闭它并继续下一步。

181
00:12:16,510 --> 00:12:18,780
下一步实际上是最后一步。

182
00:12:18,940 --> 00:12:24,220
这就是我们获得乐趣的地方，因为我们已经完成了将Kamins算法构建为我们的工作

183
00:12:24,280 --> 00:12:29,800
数据集，现在我们期待看到结果，我们将确保插入一个漂亮的

184
00:12:29,800 --> 00:12:32,650
五个集群的代表性很好的图表。

185
00:12:32,800 --> 00:12:38,350
好的，让我们通过注释将群集可视化来介绍这一新步骤，并开始绘制

186
00:12:38,350 --> 00:12:39,370
结果。

187
00:12:39,370 --> 00:12:44,140
因此，基本上，我们将对所有观测值作一个散点图，并在其上添加

188
00:12:44,140 --> 00:12:44,970
个世纪。

189
00:12:44,980 --> 00:12:48,220
当然，我们将确保正确突出显示集群。

190
00:12:48,400 --> 00:12:55,150
因此，我们编写了LTE点散布图，让我们从渗入明显的救赎属于簇开始

191
00:12:55,150 --> 00:13:00,490
我们继续前进之前的一个，只是注意到在这个白色Kamins向量中，簇数不是

192
00:13:00,490 --> 00:13:03,030
从一到五，但从零到四。

193
00:13:03,490 --> 00:13:08,470
因此，这意味着我们的第一个集群集群1对应于y Kamins等于零。

194
00:13:08,650 --> 00:13:16,060
因此，在点分散中，我们首先获取数据集X，然后在方括号中指定我们要观察

195
00:13:16,060 --> 00:13:20,510
通过写y k属于簇1的意味着等于0。

196
00:13:20,650 --> 00:13:25,260
然后出现，然后我们指定我们要数据X的第一列。

197
00:13:25,360 --> 00:13:28,680
因此我们键入零，因为Python中的索引从零开始。

198
00:13:28,960 --> 00:13:34,500
通过这样做，我们给出了属于聚类1的所有观察点的x坐标。

199
00:13:34,630 --> 00:13:37,200
现在，我们必须对y坐标执行相同的操作。

200
00:13:37,330 --> 00:13:44,140
所以在这里我们输入come，然后在X和方括号y中Kamins等于0，然后等于1

201
00:13:44,140 --> 00:13:48,900
对应于数据X的第二列，即y坐标。

202
00:13:49,070 --> 00:13:53,580
好，然后我们选择数据点的大小，因为我们没有太多的观察结果。

203
00:13:53,590 --> 00:13:56,000
大小的不错选择是100。

204
00:13:56,020 --> 00:13:58,390
然后，为集群选择一种颜色。

205
00:13:58,390 --> 00:14:03,850
让我们选择红色，然后给集群添加标签，我们现在将其称为集群一

206
00:14:03,860 --> 00:14:04,090
。

207
00:14:04,360 --> 00:14:08,820
现在，让我们复制粘贴此行代码四次，以对其他集群执行相同的操作。

208
00:14:09,100 --> 00:14:13,310
因此，在这里我们将第二个放置一个比第三个放置的两个更靠近。

209
00:14:13,540 --> 00:14:19,750
然后是第一个集群的三个，最后是第五个集群的四个。

210
00:14:19,750 --> 00:14:24,850
好的，我们当然可以更改颜色了。第二个选择蓝色，第三个选择绿色

211
00:14:24,850 --> 00:14:29,010
第四个簇的簇号，第一个簇后的品红色。

212
00:14:29,200 --> 00:14:35,140
当然，最终我们会更改群集标签群集两个群集三个群集四个群集

213
00:14:35,140 --> 00:14:35,720
五。

214
00:14:35,950 --> 00:14:38,300
好的，现在让我们绘制质心。

215
00:14:38,650 --> 00:14:42,770
因此，这一次与观察点相同，这一次我们将使用聚类中心

216
00:14:42,790 --> 00:14:46,960
在此处返回质心坐标的属性。

217
00:14:47,320 --> 00:14:51,770
为了突出它们，我们将选择更大的尺寸作为300。

218
00:14:51,910 --> 00:14:56,500
星形为黄色，当然我们将标签更改为质心。

219
00:14:56,740 --> 00:15:02,630
然后，通过键入客户端的P LCDR标题簇，将标题添加到绘图中。

220
00:15:02,710 --> 00:15:09,550
然后，我们输入x标签年收入K美元并输入p n t来指定x轴的名称。

221
00:15:09,550 --> 00:15:15,540
通过输入y标签支出得分1100的PLG来输入y轴名称。

222
00:15:15,790 --> 00:15:21,250
然后，由于我们指定了所有不同的标签，因此我们想添加图例，因此我们键入P L T

223
00:15:21,910 --> 00:15:28,210
最后但并非最不重要的一点是，我们想显示图表，所以我们输入显示的P L T和现在的关键时刻

224
00:15:28,230 --> 00:15:28,350
。

225
00:15:28,480 --> 00:15:31,400
让我们找出五个集群的样子。

226
00:15:31,450 --> 00:15:38,320
我们在这里选择此代码段，然后使用L'Express指挥官控件并输入执行以下五个命令

227
00:15:38,320 --> 00:15:40,110
最终集群。

228
00:15:40,180 --> 00:15:46,270
因此，让我们一个接一个地看一看他们，一个客户和一个集群有高收入且没有支出

229
00:15:46,270 --> 00:15:46,950
得分。

230
00:15:46,960 --> 00:15:51,280
因此，在这个集群中，客户赚取了高收入，却没有花太多钱。

231
00:15:51,340 --> 00:15:53,350
因此，我们可以称呼这群客户。

232
00:15:53,350 --> 00:16:00,160
小心谨慎的客户群，使集群中的客户获得平均收入和平均支出

233
00:16:00,160 --> 00:16:00,650
得分。

234
00:16:00,790 --> 00:16:07,520
因此，我们将此客户群称为标准群3高收入和高支出得分。

235
00:16:07,570 --> 00:16:12,550
因此，这将是商场营销活动的主要潜在目标客户群

236
00:16:12,550 --> 00:16:12,660
。

237
00:16:12,730 --> 00:16:17,440
因此，对于他们所有人来说，了解他们购买的产品是非常有见地的

238
00:16:17,440 --> 00:16:18,830
此集群中的客户端。

239
00:16:18,850 --> 00:16:26,320
因此，最终我们讨论了以下针对低收入但高支出得分的名称目标群体

240
00:16:26,320 --> 00:16:26,570
。

241
00:16:26,650 --> 00:16:30,870
因此，该集群中的客户收入较低，但不在乎并花费很多。

242
00:16:30,880 --> 00:16:37,570
因此，我们称这个客户群为粗心大意，最终接近五个低收入和低支出

243
00:16:37,570 --> 00:16:38,240
得分。

244
00:16:38,260 --> 00:16:43,140
因此，与收入较低且支出较高的Carolis客户相反，我们将其称为

245
00:16:43,160 --> 00:16:45,380
明智的客户。

246
00:16:45,400 --> 00:16:51,400
现在，让我们选择并执行带有正确集群标签的代码部分，我们将获得最终的

247
00:16:51,400 --> 00:16:55,280
客户群图表。

248
00:16:55,340 --> 00:16:55,840
好吧。

249
00:16:55,840 --> 00:16:58,510
我们已经完成了Python中的Kamins算法。

250
00:16:58,510 --> 00:16:59,380
看一下我们的代码。

251
00:16:59,410 --> 00:17:05,110
它结构简单，可以很好地完成工作，您可以随时使用此代码

252
00:17:05,110 --> 00:17:05,740
为了你的工作。

253
00:17:05,740 --> 00:17:08,300
您只需要替换数据集的名称。

254
00:17:08,350 --> 00:17:13,570
更改感兴趣的列的索引，然后只需执行此代码以找到一些

255
00:17:13,570 --> 00:17:15,200
您的业​​务问题的答案。

256
00:17:15,280 --> 00:17:20,050
而且，如果要在两个以上的维度上进行集群，则不要执行最后的代码部分

257
00:17:20,050 --> 00:17:24,350
可视化群集，因为它仅用于二维群集。

258
00:17:24,370 --> 00:17:28,810
但是，在本课程的稍后部分，我们将学习一种技术，可以使我们减小尺寸

259
00:17:28,810 --> 00:17:29,650
数据。

260
00:17:29,650 --> 00:17:35,170
因此，如果您将数据集缩小为二维，则可以使用最后一个代码部分来绘制

261
00:17:35,170 --> 00:17:36,340
集群。

262
00:17:36,340 --> 00:17:41,710
现在，完成本教程，让我们清除所有内容并通过在此处执行此行代码来重置

263
00:17:41,710 --> 00:17:42,850
没有评论。

264
00:17:42,850 --> 00:17:46,300
让我们也按一下控制键L来清除控制台。

265
00:17:46,300 --> 00:17:51,190
我们选择整个代码执行它，并确保一切正常。

266
00:17:51,550 --> 00:17:55,710
感谢您观看此视频，我期待在下一个教程中与您相见。

