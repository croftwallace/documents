1
00:00:00,510 --> 00:00:05,250
您好，欢迎回到Bruce教程中的机器学习课程，我们学到了很多东西

2
00:00:05,250 --> 00:00:10,290
关于Kamins算法，我们讨论了它在实际执行的后台如何工作。

3
00:00:10,290 --> 00:00:13,410
Emmanuel Kamins算法非常有趣。

4
00:00:13,470 --> 00:00:20,730
然后我们讨论了随机安装陷阱，Kamins plus plus是什么以及所有场景

5
00:00:20,760 --> 00:00:26,150
我们与预定数量的分类器一起工作，其中两个集群中的三个集群

6
00:00:26,670 --> 00:00:34,400
我们讨论了以某种方式找出给定数据大小问题的正确簇数

7
00:00:34,400 --> 00:00:34,670
。

8
00:00:34,920 --> 00:00:41,190
在今天的教程中，实际上将讨论找出正确数目的算法背后的算法。

9
00:00:41,280 --> 00:00:42,060
集群。

10
00:00:42,060 --> 00:00:48,750
因此，我们将学习如何确定要输入到Kamins算法中的簇数。

11
00:00:48,780 --> 00:00:50,550
因此，让我们直接了解它。

12
00:00:50,880 --> 00:00:54,650
在这里，我们遇到了挑战或设计问题。

13
00:00:54,660 --> 00:00:58,320
同样，我们只有两个变量x和y坐标。

14
00:00:58,320 --> 00:01:04,770
为了简单起见，不真实性可以是任意数量的列或变量，并且您已经

15
00:01:04,770 --> 00:01:07,130
介绍我们女儿的散点图。

16
00:01:07,170 --> 00:01:15,690
现在，如果我们是伊朗，则在该数据集中具有三个聚类或具有K个预定项的K均值聚类算法

17
00:01:15,690 --> 00:01:19,480
变为三，则结果将如下所示。

18
00:01:19,650 --> 00:01:24,840
不仅如此，而且完全如此，我们已经确定了三个集群

19
00:01:24,870 --> 00:01:30,600
而且我们已经知道我们需要运行Kamins plus plus算法以避免随机

20
00:01:30,600 --> 00:01:31,560
选择陷阱。

21
00:01:31,560 --> 00:01:35,390
但是为了简单起见，再次将其称为Kamins算法。

22
00:01:35,490 --> 00:01:38,420
因此，我们有了三个集群。

23
00:01:38,440 --> 00:01:39,020
没有。

24
00:01:39,060 --> 00:01:44,340
为了了解例如在这种情况下两个群集是否会更好，或者

25
00:01:44,340 --> 00:01:46,320
10个群集会更好。

26
00:01:46,320 --> 00:01:54,300
我们需要一个特定的指标，我们需要一种方法来理解或评估一定数量的集群的性能

27
00:01:54,540 --> 00:02:00,220
与不同数量的集群相比，该指标最好是可量化的。

28
00:02:00,330 --> 00:02:06,690
那么我们可以对集群算法施加什么样的度量标准，这将告诉我们一些有关

29
00:02:06,750 --> 00:02:07,800
最终结果。

30
00:02:08,070 --> 00:02:12,510
并且有一个这样的度量称为簇内平方和。

31
00:02:12,660 --> 00:02:17,700
因此，WCR在左手边说的是公式如何计算。

32
00:02:17,700 --> 00:02:19,980
这是三个群集的示例。

33
00:02:20,010 --> 00:02:20,590
没有。

34
00:02:20,610 --> 00:02:27,320
乍看之下，这个公式可能看起来有些让人不知所措或复杂，但实际上它非常简单

35
00:02:27,330 --> 00:02:33,720
因此，按照我们使复杂的过程变得简单的使命，让我们将其分解为以下内容

36
00:02:33,740 --> 00:02:33,890
。

37
00:02:34,020 --> 00:02:40,620
好了，我们已经有了三个元素，每个元素都有一些，所以这个符号代表一些，每个总和都是经过计算的

38
00:02:40,620 --> 00:02:45,980
实际上，对于每个群集，它是在该群集内计算的，因此从一开始就为W。

39
00:02:45,990 --> 00:02:47,880
因此，让我们看看其中之一。

40
00:02:47,880 --> 00:02:49,670
让我们看一下中心的例子。

41
00:02:49,710 --> 00:02:53,140
在这里，我们要研究群集2中的每个点。

42
00:02:53,290 --> 00:03:01,290
那正是在这里写的，这显然不是写的有效方法

43
00:03:01,790 --> 00:03:08,370
用食指和一两个骑自行车的人将P抬高，然后我们就在这些点上度过了一个夏天

44
00:03:08,370 --> 00:03:16,080
我们求和的是距离更近的每个点与簇2的质心之间的距离，然后

45
00:03:16,080 --> 00:03:17,590
我们平方距离。

46
00:03:17,700 --> 00:03:21,110
因此，我们采用了一些平方距离。

47
00:03:21,120 --> 00:03:25,920
因此，现在看一下图表，我将使WCR保持在左侧。

48
00:03:25,920 --> 00:03:30,690
举例来说，我们离那里很近，我们在取质心，然后计算距离

49
00:03:30,690 --> 00:03:35,270
到每个点，所以到那个点，我们正平方到那个点，然后冒着磨损的危险

50
00:03:35,270 --> 00:03:38,810
它到那个点，然后我们将其平方。

51
00:03:38,820 --> 00:03:40,230
等等。

52
00:03:40,230 --> 00:03:47,580
因此，我们将所有这些距离的所有平方之和作为平方，然后求和。

53
00:03:47,700 --> 00:03:48,810
然后，我们正在这样做。

54
00:03:48,810 --> 00:03:50,520
因此，我们正在为第一个集群执行此操作。

55
00:03:50,580 --> 00:03:55,860
我们正在做第二个更近的事情，我们也在第三个集群上做这件事。

56
00:03:55,860 --> 00:03:59,510
结果，我们得到了一些总数。

57
00:03:59,520 --> 00:04:04,280
因此，总和就是我们的度量标准。

58
00:04:04,290 --> 00:04:11,520
实际上，就理解或比较两者之间的拟合优度而言，这是一个很好的指标

59
00:04:11,700 --> 00:04:14,970
两个不同的卡明斯星团环，我们怎么知道。

60
00:04:14,970 --> 00:04:21,600
好吧，让我们回顾一下距离近一点时的情况，让我们看看WCA指标如何

61
00:04:21,600 --> 00:04:25,950
随着群集数量的增加，它将会改变。

62
00:04:25,950 --> 00:04:26,220
好吧。

63
00:04:26,220 --> 00:04:31,800
因此，我们的图表仅包含一个群集，您可以看到这是我们的质心。

64
00:04:31,800 --> 00:04:36,300
对于每个点，我们必须测量该点与质心之间的距离，然后

65
00:04:36,300 --> 00:04:42,090
您必须将该距离平方，然后我们必须将所有这些距离相加，如您所见

66
00:04:42,180 --> 00:04:48,780
将获得相当大的价值，因为此质心已经远离它们都具有的点

67
00:04:48,780 --> 00:04:50,640
达到它。

68
00:04:50,670 --> 00:04:57,060
因此，让我们从视觉上记住它的外观，这将有助于我们记住

69
00:04:57,060 --> 00:05:01,220
距离不是绝对值，而是感觉。

70
00:05:01,220 --> 00:05:05,430
现在距离已经很大，所以我将群集数量增加到两个，让我们

71
00:05:05,430 --> 00:05:07,200
看看一切如何变化。

72
00:05:07,230 --> 00:05:08,730
所以我们去了两个集群。

73
00:05:08,730 --> 00:05:12,390
正如您现在所看到的，在中间有一些介绍，我们必须重心。

74
00:05:12,390 --> 00:05:17,850
因此，这些点中的每一个都不再必须一直到达中间，也不需要距离

75
00:05:17,850 --> 00:05:17,910
。

76
00:05:17,910 --> 00:05:19,100
那不是很好。

77
00:05:19,110 --> 00:05:24,540
您所要做的就是只是计算出距该质心的距离，然后减小它的距离。

78
00:05:24,540 --> 00:05:29,970
对于这里的所有人来说，到此质心的距离也更短他们不必到达所有

79
00:05:29,970 --> 00:05:33,300
计算距离时的中间位置。

80
00:05:33,300 --> 00:05:34,110
所以我们走了。

81
00:05:34,110 --> 00:05:41,790
这意味着总距离或总WCA表示我们在这里看到的距离将小于

82
00:05:41,790 --> 00:05:43,030
我们只有一个中央。

83
00:05:43,050 --> 00:05:46,290
现在，我们再次将集群的数量增加到三个。

84
00:05:46,290 --> 00:05:50,290
因此，只需直观地记住两个群集的外观即可。

85
00:05:50,520 --> 00:05:53,300
然后，我们将与下一张图片进行比较。

86
00:05:53,310 --> 00:05:54,060
所以我们走了。

87
00:05:54,090 --> 00:05:56,550
现在我们有三个集群。

88
00:05:56,790 --> 00:06:02,170
正如您所看到的，在近距离中什么都没有改变，所以这样做确实有些相同。

89
00:06:02,220 --> 00:06:06,400
这两个总和已更改，因此现在有点像一个集群。

90
00:06:06,450 --> 00:06:11,620
这两组点被识别为单独的群集，因此它们有自己的质心

91
00:06:11,670 --> 00:06:17,220
距离又减小了，因为您现在可以看到所有这些点都更接近它们自己的点

92
00:06:17,220 --> 00:06:20,020
质心比他们到了世纪中叶更重要。

93
00:06:20,010 --> 00:06:25,560
再说一次，这些点总体上比这个质心更接近于这个质心。

94
00:06:25,560 --> 00:06:26,100
中间。

95
00:06:26,250 --> 00:06:30,240
因此，如您所见，WCA表示距离在减小。

96
00:06:30,450 --> 00:06:32,080
那是什么限制。

97
00:06:32,100 --> 00:06:34,870
减少幅度将保持多远。

98
00:06:35,060 --> 00:06:40,010
好吧，让我们考虑一下，假设我们将集群的数量增加到4 5 6，依此类推。

99
00:06:40,050 --> 00:06:43,340
最多可以有多少个群集。

100
00:06:43,560 --> 00:06:48,840
好吧，我们可以拥有与数据集中的点或元素一样多的聚类。

101
00:06:48,840 --> 00:06:53,400
因此，我们在图表上看到的点数就是我们拥有的集群数量，如果我们是50

102
00:06:53,400 --> 00:06:59,610
点最多可以有50个聚类，因为毕竟我们是50个或在您超过点数之后

103
00:07:00,030 --> 00:07:04,690
没有更多的点可以实际聚类，每个点都有自己的聚类。

104
00:07:04,890 --> 00:07:09,090
因此，在这种情况下，WC评估将等同于此。

105
00:07:09,270 --> 00:07:10,930
如果您愿意，我会再给您一点。

106
00:07:10,920 --> 00:07:16,560
如果我们已经达到Kloster的人数，则可以摆出这段视频来思考一下

107
00:07:16,890 --> 00:07:22,560
等同于我们图表中的点数，或者该点数与数字相同

108
00:07:22,560 --> 00:07:26,830
元素，然后我们的女儿说，WCA说的是什么。

109
00:07:27,210 --> 00:07:28,680
完全正确。

110
00:07:28,680 --> 00:07:35,040
评估的WC等于零，因为每个点都有自己的簇，因此具有

111
00:07:35,040 --> 00:07:40,470
它自己的质心，该质心将恰好位于该点所在的位置，因此距离

112
00:07:40,470 --> 00:07:42,450
点和质心之间的距离将为零。

113
00:07:42,520 --> 00:07:46,910
如果平方将为零，并且相加后所有平方仍将为0。

114
00:07:47,040 --> 00:07:54,690
因此，我们可以看到，当我们一直靠近时，WC SS将从一个可观的值下降

115
00:07:54,690 --> 00:07:57,300
减少到零，因为我们增加了簇的数量。

116
00:07:57,330 --> 00:07:59,120
因此，这是一个很好的指标。

117
00:07:59,130 --> 00:08:04,530
但与此同时，它在不断减少，因此它在不断变得越来越好，

118
00:08:04,530 --> 00:08:04,850
更好。

119
00:08:04,870 --> 00:08:10,390
这是因为如您所见，WCR说的越少或收盘次数越多越好

120
00:08:10,380 --> 00:08:16,140
拟合优度，我们越来越适合我们的数据，因此越少

121
00:08:16,140 --> 00:08:18,000
WCR说更好。

122
00:08:18,030 --> 00:08:20,530
拟合优度被认为是。

123
00:08:20,670 --> 00:08:23,000
但是，我们如何找到最佳的拟合优度。

124
00:08:23,010 --> 00:08:24,650
是的，它一直在进步。

125
00:08:24,840 --> 00:08:29,970
但是，这种改进会带来牺牲吗，事实就是如此。

126
00:08:29,970 --> 00:08:31,930
让我们看一下这个可视化图表。

127
00:08:32,220 --> 00:08:36,330
本章程介绍了随着我们增加集群数量，WC如何评估变化。

128
00:08:36,390 --> 00:08:40,570
正如您在开始时所看到的那样，WCA说起的数量很多。

129
00:08:40,620 --> 00:08:46,470
用绝对值和类似的东西来衡量这个数字并不重要

130
00:08:46,470 --> 00:08:46,870
那。

131
00:08:46,950 --> 00:08:52,980
重要的是它如何变化，因此不同k之间的相对比较意味着聚类方法

132
00:08:52,990 --> 00:08:55,100
具有不同数量的群集。

133
00:08:55,140 --> 00:09:01,980
因此，您可以看到它从8000下降到3000，这是5000的巨大变化，我们称之为

134
00:09:01,990 --> 00:09:07,200
他们将单位从5000个单位增加到3000个单位

135
00:09:07,240 --> 00:09:08,930
从3000到1000。

136
00:09:09,000 --> 00:09:11,080
再次下降很大。

137
00:09:11,350 --> 00:09:16,500
然后从三到四发生的事情将从1000跳到八百

138
00:09:16,500 --> 00:09:24,270
从800到600600到500等，这样您就可以看到前两个改进或前两个更改

139
00:09:24,270 --> 00:09:32,440
从一个集群到两个，从两个集群到三个集群，在未来的WTS中造成了巨大的跳跃或大幅下降

140
00:09:32,430 --> 00:09:32,480
。

141
00:09:32,490 --> 00:09:35,530
WCR说下降幅度不大。

142
00:09:35,670 --> 00:09:40,990
这是我们选择最佳的最佳簇数和我们要采用的方法的提示

143
00:09:40,980 --> 00:09:44,690
使用的是肘部方法，实际上非常直观。

144
00:09:44,830 --> 00:09:50,260
您所要做的就是查看图表并查找该更改，或者看起来确实像

145
00:09:50,250 --> 00:09:50,940
像肘一样

146
00:09:50,940 --> 00:09:58,540
在图表中寻找弯头，下降幅度从相当大到不那么大

147
00:09:58,530 --> 00:10:05,160
没有被证明的那么差，因此图表中的那个点将是最佳数

148
00:10:05,160 --> 00:10:06,210
集群。

149
00:10:06,340 --> 00:10:09,400
在这种情况下，确实是三个集群。

150
00:10:09,390 --> 00:10:11,320
那是最佳数目。

151
00:10:11,520 --> 00:10:14,140
如您所见，此方法相当随意。

152
00:10:14,130 --> 00:10:21,870
因此，有时情况不那么明显，有时肘部可能不像现在这样明显

153
00:10:21,880 --> 00:10:27,330
情况，因此有人可能会选择一些集群，而其他人可能会过来选择

154
00:10:27,340 --> 00:10:27,720
一个号码。

155
00:10:27,720 --> 00:10:28,940
另一个集群。

156
00:10:29,040 --> 00:10:33,840
但这是您作为数据科学家需要做出的判断。

157
00:10:33,880 --> 00:10:37,700
有时，您需要决定Narses的结构。

158
00:10:37,710 --> 00:10:44,040
这是其中一种情况，因为您正在确定哪种类型的k表示

159
00:10:44,040 --> 00:10:46,960
运行您输入的k值。

160
00:10:47,160 --> 00:10:54,210
是的，它可以是任意的，但是如果您不确定，则只需要运行Kamins

161
00:10:54,390 --> 00:10:59,200
例如，先三看它，再看它指的是什么，看看有什么区别，使

162
00:10:59,190 --> 00:11:06,570
该判断要求您认为最适合您的分析的k，因为最终您是

163
00:11:06,580 --> 00:11:13,350
创建此分析的人员，您需要确定最佳的集群数目，以便采用Elbel方法

164
00:11:13,360 --> 00:11:17,620
只是可以帮助您做出决定的一种方法。

165
00:11:17,620 --> 00:11:20,430
但归根结底，这是您的决定。

166
00:11:20,430 --> 00:11:21,330
所以我们走了。

167
00:11:21,340 --> 00:11:30,270
希望您喜欢本教程，现在您的k知识库意味着集群非常广泛。

168
00:11:30,270 --> 00:11:35,800
您那里有很多工具，我可以等您跳到实际应用中

169
00:11:35,790 --> 00:11:43,500
如果精益方法为您准备了一些非常有趣的代码挑战，那么您将继续工作

170
00:11:43,530 --> 00:11:47,370
使用BAHFEN这种方法，我们的Python将非常令人兴奋。

171
00:11:47,380 --> 00:11:48,290
祝你好运。

172
00:11:48,340 --> 00:11:49,420
下次见。

173
00:11:49,410 --> 00:11:51,330
直到那时在德国学习

