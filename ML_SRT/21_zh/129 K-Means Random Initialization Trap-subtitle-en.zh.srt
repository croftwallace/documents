1
00:00:00,600 --> 00:00:03,150
您好，欢迎回到机器学习课程。

2
00:00:03,150 --> 00:00:10,500
今天我们将讨论Kamins算法的特定方面，即随机绝缘

3
00:00:10,590 --> 00:00:11,350
陷阱。

4
00:00:11,550 --> 00:00:15,550
因此，让我们看一下这种现象并了解其全部含义。

5
00:00:15,870 --> 00:00:17,650
因此随机设置绝缘陷阱。

6
00:00:17,700 --> 00:00:20,430
在这里，我们有一个散点图。

7
00:00:20,430 --> 00:00:24,380
同样，我们有两个Berbel，所以我们有了x和y坐标。

8
00:00:24,540 --> 00:00:28,320
在这种情况下，假设我们要选择三个集群。

9
00:00:28,320 --> 00:00:33,450
因此，您马上就无法确定最终结果是什么，父亲将要看什么

10
00:00:33,450 --> 00:00:35,160
就像我们选择三个集群一样

11
00:00:35,250 --> 00:00:39,280
看起来您可以很容易地在这里发现它们。

12
00:00:39,300 --> 00:00:42,510
但是让我们以较少的形式使用此算法。

13
00:00:42,630 --> 00:00:49,350
如果我们像这样初始化质心，那么我们得到的是因为我们已经可以

14
00:00:49,350 --> 00:00:52,730
告诉我们这可能是经典资产类别，而且距离更近。

15
00:00:52,730 --> 00:00:57,630
所以只是使算法更快一点，所以我们不必做太多简单的步骤和方向

16
00:00:57,630 --> 00:01:00,630
我们将选择所有这样的质心。

17
00:01:00,860 --> 00:01:05,170
如果执行算法，这是正确的选择。我们将进入这些集群。

18
00:01:05,400 --> 00:01:12,560
接下来就是即使我们绕着质心移动，所以我们发现每个此类分类器的质心都没有

19
00:01:12,570 --> 00:01:13,190
要改变。

20
00:01:13,190 --> 00:01:18,930
因此，您可以在自己的时间内执行我们在镜像教程中了解到的步骤，然后

21
00:01:18,930 --> 00:01:23,340
看到由于我们选择质心的方式，一切都不会改变。

22
00:01:23,340 --> 00:01:25,310
这已经是最终结果。

23
00:01:25,320 --> 00:01:28,700
因此，这些将成为最终的集群。

24
00:01:28,710 --> 00:01:35,770
这就是我们自己的Kamins的最终结果，因为我们选择了质心的簇

25
00:01:35,770 --> 00:01:37,550
在我们做过的地方。

26
00:01:37,560 --> 00:01:43,440
现在的问题是，如果我们在不同的位置选择质心，我们将能够更改

27
00:01:43,440 --> 00:01:45,900
结果将有所不同。

28
00:01:45,900 --> 00:01:51,420
当然，必须使用一种确定性算法，该算法是我们想要的

29
00:01:51,420 --> 00:01:56,520
结果，因为我们可以随机选择质心，因此我们不希望选择质心

30
00:01:56,550 --> 00:02:00,380
影响群集的发生方式。

31
00:02:00,390 --> 00:02:02,100
但是，让我们看一下会发生什么。

32
00:02:02,340 --> 00:02:09,390
因此，如果我们有一个不好的随机初始化，那么会发生什么，就像我们将要使用的术语一样

33
00:02:09,390 --> 00:02:13,920
暂时松散，但您将了解为什么我们现在使用的随机绝缘不良。

34
00:02:14,220 --> 00:02:17,610
因此，我们将再次进行布鲁斯教程中讨论的步骤。

35
00:02:17,610 --> 00:02:21,750
我们将选择一些集群，即三个都是随机选择的三个男孩

36
00:02:21,750 --> 00:02:27,510
是我们，特洛伊将分配给最近的Android一个点，该点将形成K个群集来计算

37
00:02:27,750 --> 00:02:32,880
并根据质心或重心为每个类别的思维放置新的质心

38
00:02:33,180 --> 00:02:36,850
生存重新分配是否有指向新的更接近的质心的指示。

39
00:02:37,050 --> 00:02:40,260
如果对位置有任何评估，我们将返回到第四步。

40
00:02:40,320 --> 00:02:43,280
由于模型已经收敛，其他人将走到尽头。

41
00:02:43,290 --> 00:02:47,700
因此，我们之前讨论过的这些步骤让我们来看看它们的实际作用。

42
00:02:47,700 --> 00:02:48,080
好吧。

43
00:02:48,110 --> 00:02:53,870
因此，这三个簇此时是在此处和此处选择质心的一种方式。

44
00:02:53,910 --> 00:02:58,590
我们要做的是，我们将以不同的方式思考，我们将选择质心，例如

45
00:02:58,590 --> 00:02:58,980
这个。

46
00:02:58,980 --> 00:03:02,730
因此，一旦它在此处，我们将在此侧放置一个质心。

47
00:03:02,730 --> 00:03:04,260
这里有趣的是。

48
00:03:04,320 --> 00:03:05,880
现在让我们看看现在会发生什么。

49
00:03:06,180 --> 00:03:09,850
如果我们画一条线，那么我们就有3个簇两个质心。

50
00:03:09,870 --> 00:03:12,340
但是原理是一样的。

51
00:03:12,390 --> 00:03:17,190
我们仍然有一个与所有三个等距的点，因此这里的点是相同的距离

52
00:03:17,190 --> 00:03:18,230
从所有三个。

53
00:03:18,300 --> 00:03:21,570
然后这条线与这两条线等距。

54
00:03:21,570 --> 00:03:24,900
这条线与这两个等距，而尺寸与这两个等距。

55
00:03:24,900 --> 00:03:29,970
同样，这不是算法的一部分，因为您只是获取每个单独的点就成为算法的一部分

56
00:03:29,970 --> 00:03:35,400
您会看到这一点，然后看到哪个质心最接近Semmes绿色（绿色）。

57
00:03:35,400 --> 00:03:39,790
您再次用绿色检查此项目此您再次用绿色检查项目，依此类推。

58
00:03:39,940 --> 00:03:45,270
然后这是最接近红色的颜色，您会把颜色设置为红色，以此类推，只是为了使操作更容易

59
00:03:45,270 --> 00:03:46,760
自己，我们将使用这个小技巧。

60
00:03:46,930 --> 00:03:53,400
我们将使用这些行来表示图表这一部分中的任何内容都将最接近阅读

61
00:03:53,400 --> 00:03:53,430
。

62
00:03:53,460 --> 00:03:58,250
仅仅因为这些是等距的线，而您认为这部分费用将变为绿色

63
00:03:58,260 --> 00:04:00,010
任何部分都是蓝色。

64
00:04:00,030 --> 00:04:01,210
这样只会节省我们的时间。

65
00:04:01,380 --> 00:04:07,230
因此，基于此方法，我们可以立即判断出这是红色簇，而现在蓝色是

66
00:04:07,230 --> 00:04:07,840
绿色的。

67
00:04:08,160 --> 00:04:11,190
因此，现在我们将每个数据点分配给最接近的质心。

68
00:04:11,190 --> 00:04:12,000
太棒了。

69
00:04:12,000 --> 00:04:17,500
现在，我们要进行第四步，并删除这些集群。

70
00:04:17,520 --> 00:04:22,650
因此，我们将重新计算每个群集的计算和放置以及新质心，以便可以看到

71
00:04:22,650 --> 00:04:26,110
那可能是红点的重心。

72
00:04:26,110 --> 00:04:29,010
那是Bluepoint的一项，那是绿点的一项。

73
00:04:29,070 --> 00:04:32,450
因此，我们将质心移至新位置。

74
00:04:32,730 --> 00:04:37,970
现在我们要执行第五步，我们将重新分配一点到新的接近质心

75
00:04:37,970 --> 00:04:38,300
。

76
00:04:38,310 --> 00:04:42,600
再次，我们将对行使用快速hack，以查看行的外观

77
00:04:42,600 --> 00:04:43,370
时间。

78
00:04:43,680 --> 00:04:48,300
有一个新的等距点，这些是等距线。

79
00:04:48,330 --> 00:04:55,220
因此，这次您可以看到没有任何改变，红色点已经在蓝色的红色角落

80
00:04:55,220 --> 00:04:59,630
点或在蓝色角落，绿色点在绿色角落，因此一切都不会改变。

81
00:04:59,640 --> 00:05:01,100
不会有任何重新分配。

82
00:05:01,110 --> 00:05:06,970
因此，由于算法已经收敛，因此我们不会继续前进，而要最终确定算法。

83
00:05:07,080 --> 00:05:08,010
所以我们走了。

84
00:05:08,040 --> 00:05:09,090
那就是我们的模型。

85
00:05:09,090 --> 00:05:09,850
准备好了

86
00:05:10,050 --> 00:05:16,530
结果，我们有了这三个集群现在，这些集群与我们在

87
00:05:16,530 --> 00:05:18,050
开始，让我们看一下。

88
00:05:18,120 --> 00:05:19,890
这就是我们一开始看到的。

89
00:05:19,890 --> 00:05:24,330
我们将其称为真相3类，因为您可以从收费中看出

90
00:05:24,330 --> 00:05:29,010
这些点最有可能形成集群。

91
00:05:29,010 --> 00:05:33,690
这些将组成一个类，而这些将仅通过观察就可以形成封闭，您可以直观地看出

92
00:05:33,930 --> 00:05:34,840
就是这种情况。

93
00:05:34,890 --> 00:05:36,210
这是我们首先得到的。

94
00:05:36,210 --> 00:05:39,380
在本教程的开始，这就是我们现在所获得的。

95
00:05:39,450 --> 00:05:46,080
因此，您可以看到三个集群是不同的，因此我们所处的是一种情况或现象

96
00:05:46,380 --> 00:05:52,140
在算法最开始的地方选择Central可能会决定

97
00:05:52,200 --> 00:05:53,510
算法的结果。

98
00:05:53,580 --> 00:05:58,040
这不是一件好事，因为质心是随机选择的。

99
00:05:58,050 --> 00:06:00,090
那么，您如何应对呢？

100
00:06:00,090 --> 00:06:01,550
您如何与之抗争。

101
00:06:01,650 --> 00:06:06,370
那么答案实际上并不是那么简单。

102
00:06:06,390 --> 00:06:14,070
Kamins算法有新增或修改的功能，可让您正确选择

103
00:06:14,070 --> 00:06:19,620
重心，这里的解决方案是Kamins plus plus算法。

104
00:06:19,620 --> 00:06:25,920
现在，我同时想提一下，我们实际上并不会深入研究K均值

105
00:06:26,280 --> 00:06:29,370
加上加号算法的结构。

106
00:06:29,430 --> 00:06:33,930
您绝对可以在Wikipedia或其他来源上阅读有关它的更多信息。

107
00:06:33,960 --> 00:06:39,300
选择的发生方式相当复杂。

108
00:06:39,450 --> 00:06:46,050
但是好消息是，所有这些都在后台发生，因此Kamins plus plus要么发生

109
00:06:46,050 --> 00:06:48,380
在我们或Python或您使用的任何工具中。

110
00:06:48,450 --> 00:06:50,990
您不需要实际实现它。

111
00:06:51,090 --> 00:06:59,400
因此，意识到此问题是您追求的一个真正的集群结果，这是一个好主意

112
00:06:59,400 --> 00:06:59,530
。

113
00:06:59,610 --> 00:07:06,660
Kamin的聚类结果可能存在一些错误或不理想的聚类结果

114
00:07:06,660 --> 00:07:08,370
聚类算法。

115
00:07:08,580 --> 00:07:14,910
知道该问题是件好事，知道您使用的工具将是或

116
00:07:14,970 --> 00:07:21,180
确保您使用的工具将实现对随机变量的特定选择

117
00:07:21,180 --> 00:07:21,720
重心。

118
00:07:21,720 --> 00:07:24,510
从一开始就使您获得良好的结果。

119
00:07:24,540 --> 00:07:28,860
因此，如果您对有趣的事情感兴趣，可以肯定地了解有关Kamins plus plus Algren的更多信息

120
00:07:29,250 --> 00:07:32,850
一定要读懂它，否则您不必担心它

121
00:07:32,850 --> 00:07:38,610
只是您需要牢记的一点，以确保或确信所使用的工具

122
00:07:38,910 --> 00:07:42,500
正在绕过这个绝缘陷阱。

123
00:07:42,590 --> 00:07:46,330
因此，祝您今天的工作愉快，我期待下次与您见面。

124
00:07:46,350 --> 00:07:48,190
在那之前在德国学习

