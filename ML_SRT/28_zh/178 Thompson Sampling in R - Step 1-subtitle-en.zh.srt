1
00:00:00,330 --> 00:00:02,600
您好，欢迎来到本美术教程。

2
00:00:02,700 --> 00:00:08,400
因此，在美国，我们针对此广告的点击率优化引入了多武装福利计划

3
00:00:08,400 --> 00:00:09,130
问题。

4
00:00:09,330 --> 00:00:16,230
而且我们已经尝试过使用算法，第一个算法是简单的随机选择算法，

5
00:00:16,230 --> 00:00:21,180
包括纯随机选择和每轮AD。

6
00:00:21,330 --> 00:00:27,990
这个算法平均给我们提供了1200个病房，因为您知道存在这个随机因素

7
00:00:28,140 --> 00:00:31,550
平均而言，我们可以获得1200的总奖励。

8
00:00:31,650 --> 00:00:37,520
当然，当我们绘制直方图时，每个广告的选择次数几乎相同。

9
00:00:37,740 --> 00:00:44,700
然后我们尝试了另一种算法，这是节奏上的上限，在那里我们得到了更好的结果

10
00:00:44,700 --> 00:00:51,130
结果，因为我们不仅获得了几乎所希望的总回报，而且几乎使总奖励翻了一番

11
00:00:51,130 --> 00:00:53,420
之2170 8。

12
00:00:53,520 --> 00:01:00,030
因此，几乎是我们从随机选择中获得的收益的两倍，更妙的是，我们设法

13
00:01:00,030 --> 00:01:06,780
找出哪个版本最能向用户显示哪个广告的最高

14
00:01:06,900 --> 00:01:11,210
转换率最高的ETR，即最高的点击率。

15
00:01:11,460 --> 00:01:17,940
现在，在本节中，我们将尝试一种称为Thomsons采样的新算法。

16
00:01:17,940 --> 00:01:20,910
因此，在本节中，我们将看两件事。

17
00:01:20,910 --> 00:01:27,720
首先是肯·汤普森（Ken Thompson）简单地打破了非洲鳍的界限，是肯·汤普森（Ken Thompson）简单地给了我们

18
00:01:27,720 --> 00:01:31,880
工具奖励甚至高于2170 8。

19
00:01:31,920 --> 00:01:35,290
您知道我们几乎将随机选择的总奖励提高了一倍。

20
00:01:35,310 --> 00:01:37,600
让我们看看是否可以再次击败它。

21
00:01:37,770 --> 00:01:40,710
就像是两倍甚至三倍以上。

22
00:01:40,710 --> 00:01:41,130
我不知道。

23
00:01:41,130 --> 00:01:41,780
让我们来看看。

24
00:01:41,910 --> 00:01:47,340
我们要看的第二件事是，如果我们获得最高的广告

25
00:01:47,340 --> 00:01:48,240
兑换率。

26
00:01:48,300 --> 00:01:54,630
让我们看看是否获得广告编号5，该广告编号是通过有关该算法找到的最高可信度找到的

27
00:01:54,720 --> 00:01:56,000
广告五号。

28
00:01:56,010 --> 00:01:59,540
因此，希望我们也能获得第五版。

29
00:01:59,550 --> 00:02:05,270
如果我们设法以想要的总数击败高置信度，那么在逻辑上应该是这种情况。

30
00:02:05,340 --> 00:02:10,650
因此，让我们执行此操作，在本节中实现Tomsen采样，我们实际上将在

31
00:02:10,650 --> 00:02:17,340
一步，因为当您考虑它时，我们只需为此更改策略

32
00:02:17,340 --> 00:02:22,740
循环，然后保持不变以实现Thompson，因为您知道我们将保留这些参数

33
00:02:22,740 --> 00:02:24,800
这就是这个回合数。

34
00:02:24,870 --> 00:02:30,980
此数字会将“选择时”添加到包含每个回合中选择的所有不同广告的向量中。

35
00:02:30,990 --> 00:02:35,710
这将需要更改，因为这些是Opera对算法的信心的参数

36
00:02:35,760 --> 00:02:37,000
因此我们需要进行更改。

37
00:02:37,170 --> 00:02:43,440
当然，我们将保留此总奖励，因为我们希望获得通过累积的总奖励

38
00:02:43,440 --> 00:02:47,060
汤普森采样算法的执行。

39
00:02:47,070 --> 00:02:55,560
所以我们现在要做的就是简单地将所有内容从这里复制到这里，然后粘贴到这里

40
00:02:55,650 --> 00:02:58,100
我们只会改变我们需要改变的东西。

41
00:02:58,110 --> 00:03:02,330
这是为汤普森采样算法运行击球手的权利。

42
00:03:02,640 --> 00:03:04,190
好吧，让我们开始吧。

43
00:03:04,260 --> 00:03:14,100
我们已经可以用汤姆森·塞姆林（Thomson Semlin）取代UCAP，现在让我们改变策略。

44
00:03:14,340 --> 00:03:15,660
让我们从基础开始。

45
00:03:15,660 --> 00:03:22,380
让我们在其中设置正确的目录作为工作目录，然后转到任务文件夹，然后指向六个加固点

46
00:03:22,380 --> 00:03:28,660
学习汤普森跌跌撞撞，然后确保您已将其作为一座城市进行了优化。

47
00:03:28,680 --> 00:03:33,740
当然，该文件与我们在Opera Company信任中找到的文件相同。

48
00:03:33,930 --> 00:03:38,520
因此，如果您有此数据集，现在可以单击此处的更多按钮，然后将其设置为工作

49
00:03:38,520 --> 00:03:39,500
目录。

50
00:03:40,020 --> 00:03:44,280
好的，现在让我们实现我们的Thomson采样算法。

51
00:03:44,490 --> 00:03:49,600
因此，让我们直接跳到汤普森某种算法的幻灯片上。

52
00:03:49,730 --> 00:03:51,700
好的，所以我们在这里看到什么。

53
00:03:51,710 --> 00:03:54,560
汤普森某种算法需要三个步骤。

54
00:03:54,560 --> 00:03:59,800
第一步是每一轮，我们需要为每个加法考虑两个数字。

55
00:04:00,200 --> 00:04:05,000
第一个数字是他和我得到我们相处的次数。

56
00:04:05,240 --> 00:04:08,400
第二个数字是我得到的次数。

57
00:04:08,420 --> 00:04:10,130
我们到零为止。

58
00:04:10,140 --> 00:04:13,500
这就是我们在这里要做的第一件事。

59
00:04:13,550 --> 00:04:20,480
我们将考虑这些参数并声明与这些参数对应的变量，然后

60
00:04:20,480 --> 00:04:25,940
可以注意到，如果我们将此汤普森算法与UCB算法进行比较。

61
00:04:26,150 --> 00:04:32,330
好吧，这是具有不同参数的同一第一步，因为您在第一步中会注意到

62
00:04:32,330 --> 00:04:38,540
关于算法的最高置信度，我们还考虑了两个数字，这两个数字是

63
00:04:38,540 --> 00:04:44,500
他和我被选中的次数最多，大约相加之和。

64
00:04:44,500 --> 00:04:50,300
因此，如果我们在这里查看此代码部分，则上述代码部分来自

65
00:04:50,300 --> 00:04:51,400
拼数对数。

66
00:04:51,530 --> 00:04:58,610
好，我们可以看到这两个参数在这里，而这些参数不再是参数

67
00:04:58,610 --> 00:05:04,760
对于Tomson采样，我们在UCB算法的第1步中考虑的这两个参数实际上是

68
00:05:04,760 --> 00:05:09,410
在汤普森采样算法中被两个新参数取代。

69
00:05:09,410 --> 00:05:15,170
所以我们现在要做的只是删除这两个参数

70
00:05:15,170 --> 00:05:21,410
以及使用算法的第一步，并用我们需要的这两个新参数替换它们

71
00:05:21,410 --> 00:05:23,750
考虑使用汤普森采样算法。

72
00:05:23,780 --> 00:05:25,740
因此，让我们立即更换它们。

73
00:05:25,820 --> 00:05:28,820
因此，让我们声明两个新的弹珠。

74
00:05:28,880 --> 00:05:32,240
因此，首先要增加我获得的ADD的次数。

75
00:05:32,240 --> 00:05:41,180
我们到处都是，所以我们称这个数字为单词数，然后加下划线和一个

76
00:05:41,410 --> 00:05:48,260
指定这是广告获得关键字一个的次数，然后第二个是关键字

77
00:05:48,260 --> 00:05:51,370
有几次我得到的广告都是0。

78
00:05:51,420 --> 00:05:57,140
因此，我们将创建可变数量的奖励零。

79
00:05:57,170 --> 00:05:59,570
现在我们将要成为这两个变量。

80
00:05:59,570 --> 00:06:05,120
这些就是汤普森采样的参数，这是我们将要采取的未来策略的本质

81
00:06:05,120 --> 00:06:06,160
在这里。

82
00:06:06,170 --> 00:06:12,280
因此，这两个变量将成为具有十个元素的元素的某些向量。

83
00:06:12,470 --> 00:06:17,950
正如您可能已经猜到的那样，每增加一个，它们将包含我们工作的次数

84
00:06:18,050 --> 00:06:21,260
一到周围，零到周围。

85
00:06:21,270 --> 00:06:27,550
因此，我们将采用与歌剧置信度相同的方式初始化这些向量

86
00:06:27,550 --> 00:06:35,570
我们将采用这个整数D来创建d个元素的向量，而这些元素为零。

87
00:06:35,600 --> 00:06:43,110
因此，这就是我们将如何通过10个零的向量初始化这两个变量的方式。

88
00:06:43,250 --> 00:06:48,440
因为当然在开始时，每个加法的单词数当然为零。

89
00:06:48,620 --> 00:06:50,960
因为只是没有选择每个添加项。

90
00:06:51,260 --> 00:06:51,620
好吧。

91
00:06:51,650 --> 00:06:53,680
因此，我们有两个论点。

92
00:06:53,720 --> 00:06:57,070
这意味着步骤1已经完成，我们可以继续进行步骤2。

93
00:06:57,290 --> 00:06:59,940
所以第二步是每个添加。

94
00:06:59,980 --> 00:07:05,670
我从这个分布中随机抽取一个贝塔分布。

95
00:07:05,810 --> 00:07:06,720
为什么是这样。

96
00:07:06,740 --> 00:07:11,680
这是因为我们这里有两个与贝叶斯推断有关的重要假设。

97
00:07:11,720 --> 00:07:17,940
所以第一个假设是这里的第一行，我们假设每个人和我都从伯努利那里得到回报

98
00:07:17,960 --> 00:07:24,230
参数Theta I的分布，它是成功的概率，您可以描述该概率

99
00:07:24,230 --> 00:07:30,470
通过向大量用户（例如一百万用户）展示广告来获得成功

100
00:07:30,470 --> 00:07:33,830
解释为结果为1的次数。

101
00:07:33,890 --> 00:07:39,500
那就是成功次数除以我们选择ADD的总次数，即一百万。

102
00:07:39,620 --> 00:07:45,650
因此，基本上theta是成功的概率，即当我们选择时获得成功的概率

103
00:07:45,670 --> 00:07:46,390
添加。

104
00:07:46,640 --> 00:07:53,600
因此，假设我从该Vernou中获得的每个广告都会获得零奖励和一个奖励

105
00:07:53,600 --> 00:08:00,170
参数theta是成功的概率，然后第二个假设是次要假设

106
00:08:00,170 --> 00:08:03,310
比第一个假设最强。

107
00:08:03,310 --> 00:08:08,660
第二个假设是这里的第二行，即我们假设theta具有一致的

108
00:08:08,660 --> 00:08:14,260
具有先验分布的分布，然后我们使用贝叶斯规则得出特定的

109
00:08:14,270 --> 00:08:19,090
BTG的分配给了我们直到最后的回报。

110
00:08:19,210 --> 00:08:25,130
因此，通过使用基本规则，我们将在这里的步骤2中获得更好的分布。

111
00:08:25,190 --> 00:08:29,310
因此，通过在每个回合中随机抽取这些beta分布。

112
00:08:29,480 --> 00:08:34,760
好吧，既然这些随机抽奖别无其他，成功的可能性就得到了

113
00:08:34,790 --> 00:08:40,940
在这里，这将采取这些无人机的最大值，因为这些随机落差的最大值接近

114
00:08:41,180 --> 00:08:43,730
成功的可能性最高。

115
00:08:43,910 --> 00:08:49,860
这就是汤普森（Tompson）背后的整个想法，我们正在尝试估算这些参数的特征

116
00:08:50,070 --> 00:08:53,000
这是这10个中的每一个成功的概率。

117
00:08:53,010 --> 00:08:59,030
然后，通过进行这些随机抽签并采取其中的最高抽签，我们可以估算出最高的概率

118
00:08:59,030 --> 00:09:05,020
成功率和最高成功率分别对应一个特定的广告和每一轮。

119
00:09:05,180 --> 00:09:08,960
因此，当我们进行这些特定轮次的随机抽奖时，我们可能是错的。

120
00:09:09,110 --> 00:09:14,990
但是，当我们进行数千轮随机抽奖时，我们将仅基于概率的本质

121
00:09:15,320 --> 00:09:21,300
我们获取与成功可能性最高的广告对应的所有数据。

122
00:09:21,440 --> 00:09:24,180
这是获得奖励电话的最高概率1。

123
00:09:24,410 --> 00:09:26,620
这就是Thomsons采样背后的想法。

124
00:09:26,690 --> 00:09:31,730
顺便说一下，这些随机抽取的最大值就是这些估计的最大值

125
00:09:31,730 --> 00:09:34,020
获得奖励原因的可能性1。

126
00:09:34,160 --> 00:09:36,580
好吧，这只是第三步。

127
00:09:36,680 --> 00:09:43,030
因此，现在我们要做的是实施由第二步和第三步组成的策略

128
00:09:43,040 --> 00:09:44,360
此代码部分在这里。

129
00:09:44,420 --> 00:09:47,970
取代获得较高置信度的旧策略。

130
00:09:48,320 --> 00:09:54,380
好，让我们高效地进行操作让我们将逻辑保留在此代码节的后面，不要删除所有内容

131
00:09:54,380 --> 00:09:55,120
太快了。

132
00:09:55,250 --> 00:09:58,710
您知道，因为我们将在每个回合中对每个添加项进行不同的随机抽奖。

133
00:09:58,880 --> 00:10:04,730
并且由于我们需要很好地进行这个最高随机抽取，因此我们应该在这里保持这种编码策略，

134
00:10:05,030 --> 00:10:07,840
获得某物的最大值。

135
00:10:08,000 --> 00:10:16,310
因此，我们将此处的“最大”替换为“最大随机数”，因为您知道在美国算法中需要

136
00:10:16,310 --> 00:10:19,030
采取最大上限。

137
00:10:19,190 --> 00:10:22,750
对于汤普森，这里我们需要进行最大随机抽奖。

138
00:10:22,760 --> 00:10:26,640
因此，我们将此最大随机抽取称为最大随机抽取。

139
00:10:26,690 --> 00:10:27,230
好吧。

140
00:10:27,230 --> 00:10:33,080
然后我们当然将其保持为零，因为否仅是为了初始化将

141
00:10:33,200 --> 00:10:39,380
选择特定的回合，因为当然要进行汤普森采样，我们将选择您而不显示

142
00:10:39,370 --> 00:10:40,050
用户。

143
00:10:40,160 --> 00:10:41,910
因此，我们将使本文保持零。

144
00:10:41,930 --> 00:10:43,730
这则广告等于我听到了。

145
00:10:43,880 --> 00:10:51,440
但是，我们绝对需要在此处更改的是其他情况，因为其他情况是直接特定的

146
00:10:51,560 --> 00:10:53,610
对策略充满信心。

147
00:10:53,660 --> 00:10:59,330
因此，我们将删除它，现在将实施汤普森采样策略。

148
00:10:59,390 --> 00:11:05,430
因此，我们要做的第一件事是生成10个广告中每个广告的随机抽奖。

149
00:11:05,510 --> 00:11:10,140
因此，我们将其保留一天，因为我们将需要该组来展示不同的广告。

150
00:11:10,280 --> 00:11:12,340
因此，现在我们需要进行随机抽奖。

151
00:11:12,470 --> 00:11:19,010
因此，我们将在此处声明一个新变量，该变量将在得分数据和

152
00:11:19,010 --> 00:11:23,510
路线将对应于不同的奔跑和平局，因为这些是从

153
00:11:23,580 --> 00:11:25,120
数据分发。

154
00:11:25,490 --> 00:11:26,660
因此等于。

155
00:11:26,660 --> 00:11:34,850
现在我们将使用r的函数，这是我们的beta函数，它将为我们提供确切的信息

156
00:11:34,850 --> 00:11:35,290
我们想要。

157
00:11:35,300 --> 00:11:40,730
就是说，它将随机抽取我们选择的参数的beta分布。

158
00:11:41,000 --> 00:11:46,180
正如我们在幻灯片上看到的那样，第一个参数是平均值的倍数

159
00:11:46,180 --> 00:11:52,670
我们是一加一，第二个参数是我得到的加数加上零的次数

160
00:11:52,670 --> 00:11:53,110
1。

161
00:11:53,300 --> 00:11:57,250
因此，让我们按一下此处以获取有关此信息。

162
00:11:57,260 --> 00:11:58,580
我们的beta功能。

163
00:11:58,820 --> 00:12:01,370
因此，这里我们只需要其中三个参数。

164
00:12:01,370 --> 00:12:07,340
我们需要的第一个参数是观察值的数量，因此这里等于一个，因为我们只想要

165
00:12:07,340 --> 00:12:13,430
进行一次随机抽奖，然后对我们的Beta分布进行一次成型，再对另外两个参数进行成型

166
00:12:13,580 --> 00:12:19,700
形状一是我们被阿赫特人一加一的次数，二是我们的次数

167
00:12:19,700 --> 00:12:21,660
我们为零加1的几率。

168
00:12:21,770 --> 00:12:28,650
因此，在这里，对于形状一，我们输入形状一等于奖励数一。

169
00:12:28,730 --> 00:12:35,050
当然，由于这与特定广告相对应，因此我将在此处添加一些括号并进行广告。

170
00:12:35,050 --> 00:12:39,950
我这是我们在这四个岛的特定时间处理的，这是与

171
00:12:39,950 --> 00:12:41,180
具体添加。

172
00:12:41,390 --> 00:12:46,810
并且不要忘了这里加号，然后出来放置第二个参数。

173
00:12:46,820 --> 00:12:53,590
当然，如果我们想要零向量，则第二个参数将是这些数字的IFE索引。

174
00:12:53,810 --> 00:13:01,520
然后让我们不要忘记加号1，这是来自

175
00:13:01,520 --> 00:13:03,470
我们正在随机抽奖。

176
00:13:03,880 --> 00:13:06,200
好的，所以我们有需要的一切。

177
00:13:06,230 --> 00:13:12,140
现在，我们当然需要在这里使用if条件来获得最大的随机性

178
00:13:12,140 --> 00:13:12,760
绘制。

179
00:13:12,920 --> 00:13:18,970
因此，对您来说，一个很好的练习是传递此视频并尝试在此处完成此代码部分，以

180
00:13:18,980 --> 00:13:21,480
在这里猜测该代码的最后一个元素。

181
00:13:21,590 --> 00:13:23,370
所以我现在要告诉你。

182
00:13:23,600 --> 00:13:26,730
现在，我们需要最大程度地利用这些随机抽奖。

183
00:13:26,810 --> 00:13:33,220
我们已经在此声明了最大随机数可行，这将是这些随机抽取的最大数，

184
00:13:33,230 --> 00:13:34,880
很好，你猜对了。

185
00:13:34,880 --> 00:13:42,980
现在我们需要用Max random替换这里的Max，当然这里我们需要替换

186
00:13:43,130 --> 00:13:46,480
上限为随机数据。

187
00:13:46,610 --> 00:13:47,240
好。

188
00:13:47,390 --> 00:13:55,550
然后同样在这里，我们用“最大随机数”替换了“在此处占上风的最大数”，并用“随机数”替换了“在这里平均数下”

189
00:13:56,330 --> 00:13:57,040
数据。

190
00:13:57,530 --> 00:14:00,970
最终，我们当然当然要在这里保持平等。

191
00:14:01,190 --> 00:14:01,460
好。

192
00:14:01,490 --> 00:14:04,000
因此，让我们快速地重新解释这里发生的事情。

193
00:14:04,070 --> 00:14:06,530
对于这里的每个AM我都在这里循环。

194
00:14:06,740 --> 00:14:10,880
好吧，我们从失败的参数分布中随机抽取了一个。

195
00:14:10,910 --> 00:14:16,340
我们想要1 +1的Akhet的次数，以及我们0 +1所得到的广告的次数

196
00:14:16,340 --> 00:14:19,690
然后每次我们从该分布中随机抽取一个。

197
00:14:19,820 --> 00:14:24,770
好了，我们在这里检查了这个随机抽签是否高于这个最大随机抽签。

198
00:14:24,770 --> 00:14:30,190
所以当然是第一次，因为最大随机数被初始化为零，所以会这样。

199
00:14:30,290 --> 00:14:35,450
因此，此条件适用于第一个广告，因此“最大随机数”将等于第一个广告

200
00:14:35,630 --> 00:14:36,800
在这里随机抽奖。

201
00:14:36,980 --> 00:14:38,710
因此，我们将其保留在此处。

202
00:14:38,870 --> 00:14:44,000
然后，当我们移至下一个时，发生的是，我们从中再次抽出

203
00:14:44,210 --> 00:14:48,850
这些参数的beta分布在此对应于您和我。

204
00:14:49,010 --> 00:14:54,140
然后，如果此新随机抽奖高于此最大值，则等于前一次随机抽奖

205
00:14:54,140 --> 00:14:54,640
画。

206
00:14:54,770 --> 00:15:00,020
好吧，这意味着该条件为真，因此“最大随机数”采用该新随机数的值

207
00:15:00,020 --> 00:15:03,230
抽奖，因此我们选择此新广告。

208
00:15:03,260 --> 00:15:08,150
我听说随机抽奖次数最多，而我们忘记了之前选择的广告，因为

209
00:15:08,150 --> 00:15:10,300
只是它的随机抽奖较低。

210
00:15:10,310 --> 00:15:15,560
好的，这就是我们正在实施的Tomsen采样的想法和策略。

211
00:15:15,620 --> 00:15:17,060
每轮。

212
00:15:17,060 --> 00:15:17,870
大。

213
00:15:17,870 --> 00:15:19,860
因此，现在我们几乎拥有了所需的一切。

214
00:15:19,910 --> 00:15:26,690
我们现在需要更新的是这里发生的事情，因为这来自于上层信任

215
00:15:26,690 --> 00:15:27,880
绑定算法。

216
00:15:27,890 --> 00:15:32,540
这就是您知道UCB算法中步骤1的参数。

217
00:15:32,540 --> 00:15:34,670
因此，我们将需要删除此行。

218
00:15:34,670 --> 00:15:39,900
我们不需要这个，我们必须保留它，因为这是获得真正的回报。

219
00:15:40,070 --> 00:15:45,280
正如我们解释的那样，UCB算法知道这实际上是我们继续获得奖励的方式。

220
00:15:45,320 --> 00:15:51,250
在此模拟数据集中，然后得到的是包含单词和的这一行。

221
00:15:51,290 --> 00:15:56,990
当然，奖励的总和是UCAP算法的一个参数，因此我们需要将其删除

222
00:15:56,990 --> 00:15:58,060
好。

223
00:15:58,160 --> 00:16:03,820
现在我们已经准备好为汤普森某种算法更新我们需要更新的内容。

224
00:16:03,830 --> 00:16:08,090
好吧，然后我们有了总不存在的所有人员，当然，必须保留这些人员，因为这令人兴奋

225
00:16:08,090 --> 00:16:08,830
结果。

226
00:16:09,020 --> 00:16:12,010
这是一种绩效评估者。

227
00:16:12,050 --> 00:16:14,450
现在，根据您的需要，我们需要更新什么。

228
00:16:14,600 --> 00:16:18,310
当然，到目前为止，我们需要的是这两个向量。

229
00:16:18,320 --> 00:16:21,250
单词1的数量和如果我们想要0的数字。

230
00:16:21,350 --> 00:16:26,720
因为您在这里知道这种策略，所以我们正在导入这两个向量的索引。

231
00:16:26,930 --> 00:16:31,570
但是您知道我们需要根据趋势更新它们，否则它们将始终等于零

232
00:16:31,820 --> 00:16:33,990
因为它们被初始化为0。

233
00:16:34,250 --> 00:16:35,570
所以现在我们需要做什么。

234
00:16:35,570 --> 00:16:39,870
获得奖励后，我们需要增加其价值。

235
00:16:40,040 --> 00:16:43,370
因此，让我们看看我们需要为该变量增加多少。

236
00:16:43,370 --> 00:16:44,980
如果需要的话，这里是数字。

237
00:16:45,080 --> 00:16:48,370
好吧，这对应于每个加法得到的不同次数。

238
00:16:48,380 --> 00:16:49,700
我们赢了一轮。

239
00:16:49,700 --> 00:16:53,890
因此，只有在ADD得到我们想要的值时，我们才需要增加它。

240
00:16:53,900 --> 00:16:55,160
那这个向量呢。

241
00:16:55,280 --> 00:16:56,160
嗯，是一样的。

242
00:16:56,170 --> 00:17:01,480
那是包含每次加法得到的不同次数的向量，我们分别是0和

243
00:17:01,490 --> 00:17:07,080
因此，只有当我们选择的成年人为0时，我们才需要递增此向量。

244
00:17:07,310 --> 00:17:13,500
因此，由于这取决于我们选择加号时所获得的报酬，因此我们需要一个if条件。

245
00:17:13,700 --> 00:17:20,750
因此，我们将在此处将if条件写为if if，因此条件就是Ward等于

246
00:17:20,750 --> 00:17:22,210
等于1。

247
00:17:22,460 --> 00:17:29,540
因此，如果此奖励是在此特定回合时获得的，则当此奖励为

248
00:17:29,540 --> 00:17:34,070
1然后我们需要做些什么，我们需要增加这个单词数。

249
00:17:34,080 --> 00:17:41,300
1，但仅适用于索引，因为此处的索引对应于所选广告的索引。

250
00:17:41,330 --> 00:17:49,130
因此，让我们来做吧，让我们增加这一奖励数量，让我们复制一下，在这里面对它，

251
00:17:49,130 --> 00:17:56,270
现在，我们获取与所选广告索引相对应的广告索引，然后在此处

252
00:17:56,270 --> 00:17:57,460
我们需要增加它。

253
00:17:57,560 --> 00:18:04,610
因此，我将复制此内容并将其粘贴到此处并添加一个加号。

254
00:18:04,610 --> 00:18:05,090
好吧。

255
00:18:05,150 --> 00:18:10,400
因此，当我们说出一口井字眼时，我们需要做的就是在次数上加一

256
00:18:10,400 --> 00:18:13,180
这个添加在这里得到一个词。

257
00:18:13,200 --> 00:18:13,550
好吧。

258
00:18:13,550 --> 00:18:20,840
然后我们有了其他，这对应于我们在这里所说的等于

259
00:18:20,840 --> 00:18:21,520
零。

260
00:18:21,560 --> 00:18:26,010
就是说当他添加时，我们选择将和周围的特定单词设为零。

261
00:18:26,240 --> 00:18:31,820
因此，当发生这种情况时，我们这次需要将单词的数量增加零。

262
00:18:31,820 --> 00:18:41,710
所以我要复制此行并将其在此处面对，然后替换下一个我购买的行，因为我们需要

263
00:18:41,710 --> 00:18:48,890
将字数增加零，但只增加与该添加索引相对应的值。

264
00:18:48,900 --> 00:18:49,330
好吧。

265
00:18:49,360 --> 00:18:50,530
现在我们完成了。

266
00:18:50,530 --> 00:18:53,430
汤普森实际上已经完全实施了某些措施。

267
00:18:53,840 --> 00:18:57,760
因此，现在该是将结果可视化的激动人心的一步了。

268
00:18:57,910 --> 00:19:01,720
因此，我们将在下一个教程中做到这一点，直到享受机器学习。

