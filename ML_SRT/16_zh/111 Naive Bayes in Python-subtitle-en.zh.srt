1
00:00:00,450 --> 00:00:03,010
您好，欢迎来到本Python教程。

2
00:00:03,150 --> 00:00:07,320
今天，我们将在Python上实现基本模型。

3
00:00:07,350 --> 00:00:11,200
因此，让我们立即开始，并找出结果。

4
00:00:11,340 --> 00:00:16,500
因此，我们将在这里转到文件资源管理器以设置我们可以建立目录的文件夹，以便我们进行机械加工

5
00:00:16,500 --> 00:00:19,720
任何是一个文件夹或三个分类。

6
00:00:19,930 --> 00:00:25,440
现在是低音部分，在这里，我们确保您将社交网络作为文件。

7
00:00:25,500 --> 00:00:30,330
如果是这种情况，请单击此按钮将该文件夹设置为工作目录。

8
00:00:30,330 --> 00:00:38,910
现在，我们将使用分类模板来提高效率，并更快地获得最终结果

9
00:00:38,910 --> 00:00:39,270
。

10
00:00:39,420 --> 00:00:48,690
因此，将其复制并粘贴到此处，现在我们要做的就是更改一些内容。

11
00:00:48,690 --> 00:00:54,780
首先，我们需要在此处创建或分类，然后我们需要在此处更改分类器的名称，因此

12
00:00:55,140 --> 00:00:55,700
这里。

13
00:00:55,800 --> 00:01:02,030
现在他买了，和这里一样。

14
00:01:02,250 --> 00:01:05,530
是的，我现在正在这样做，这样我们就不会忘记。

15
00:01:05,820 --> 00:01:11,130
现在我们准备更改最后一个要创建分类器的内容，您将

16
00:01:11,130 --> 00:01:13,970
看看它会变得如此简单。

17
00:01:14,130 --> 00:01:16,870
我们都只需要写三行。

18
00:01:16,900 --> 00:01:20,260
和往常一样，这是我们到目前为止进行的所有转移的结果。

19
00:01:20,430 --> 00:01:23,480
但是您会看到我们没有要包含的任何参数。

20
00:01:23,490 --> 00:01:24,350
我给你看。

21
00:01:24,690 --> 00:01:32,020
因此，删除它，然后让我们导入作业的类。

22
00:01:32,160 --> 00:01:38,410
因此，这项工作的成本是我们要作为一个类导入的高斯和B。

23
00:01:38,430 --> 00:01:43,300
因此，让我们执行此操作实际上是从sikat转Naved基础库中进行的。

24
00:01:43,380 --> 00:01:56,300
因此，我们将基于基于缩放器点网的导入高斯和B进行编写，就是这样。

25
00:01:56,310 --> 00:01:59,850
那就是我们要从该库导入的类。

26
00:02:00,090 --> 00:02:00,650
好吧。

27
00:02:00,750 --> 00:02:02,680
现在让我们创建对象。

28
00:02:02,840 --> 00:02:09,010
所以我们的对象很好，我们称我们的对象为分类器气化器等于。

29
00:02:09,090 --> 00:02:11,350
然后，我们当然要在这里调用该类。

30
00:02:11,640 --> 00:02:13,370
Galchen和B.

31
00:02:13,380 --> 00:02:19,370
现在，如果您按命令来检查Galchen和B类，请查看参数是什么。

32
00:02:19,530 --> 00:02:24,580
好吧，实际上没有参数也没有参数，所以这就是为什么它这么简单的原因。

33
00:02:24,600 --> 00:02:28,170
如您所见，我们有一个示例，我们只需要调用该类。

34
00:02:28,170 --> 00:02:30,040
我们没有输入任何参数。

35
00:02:30,050 --> 00:02:31,280
所以这很酷。

36
00:02:31,280 --> 00:02:33,000
我们在这里没有任何事情。

37
00:02:33,390 --> 00:02:38,650
因此，现在适合我们的Naved购买将对象分类到我们的训练集中。

38
00:02:38,760 --> 00:02:47,970
因此，要照常执行此操作，我们首先获取分类器对象，然后使用fit方法拟合

39
00:02:47,970 --> 00:02:51,110
海军基础分类器到我们的训练集。

40
00:02:51,330 --> 00:02:58,400
因此，这里还有其他内容，以及为什么像往常一样训练没有改变。

41
00:02:58,440 --> 00:03:03,480
现在准备就绪，我们可以执行代码的不同部分了。

42
00:03:03,720 --> 00:03:04,820
因此，让我们这样做。

43
00:03:04,860 --> 00:03:08,650
我们将从所有处理步骤开始。

44
00:03:08,790 --> 00:03:11,390
所以它是从这里到顶部。

45
00:03:11,390 --> 00:03:11,960
好吧。

46
00:03:12,000 --> 00:03:18,720
现在失去控制，要正确执行并完善所有操作，您就开始摇摇欲坠

47
00:03:18,760 --> 00:03:22,450
专家，我们拥有所有权利集。

48
00:03:22,470 --> 00:03:23,940
我们在这里设置了数据。

49
00:03:24,000 --> 00:03:30,230
我们用X训练的训练集，以及为什么用X测试和Y测试训练我们的测试集。

50
00:03:30,390 --> 00:03:31,990
因此，一切看起来都很不错。

51
00:03:32,010 --> 00:03:38,100
我们甚至可以检查多余的比例，可能是的，我们可以看到它的比例非常合适，所以这里

52
00:03:38,100 --> 00:03:41,820
是“年龄”列，这是估算工资。

53
00:03:41,880 --> 00:03:42,260
好。

54
00:03:42,270 --> 00:03:46,620
现在是选择人员来创建我们的分类器。

55
00:03:46,660 --> 00:03:51,900
这是一个命令和控件，再加上Enter键即可执行，现在我们的分类器已创建。

56
00:03:52,110 --> 00:03:53,540
就像您看到的一样完美。

57
00:03:53,540 --> 00:03:58,200
请记住，如果其他分类器默认情况下我们选择了所有参数。

58
00:03:58,200 --> 00:04:03,930
因为没有参数，所以这里只有Galchen，并且在输出中。

59
00:04:03,930 --> 00:04:07,150
因此，一切看起来都很美好，一切都很容易。

60
00:04:07,170 --> 00:04:07,770
太棒了

61
00:04:07,770 --> 00:04:12,470
现在让我们选择只是获取我们的预测向量。

62
00:04:12,480 --> 00:04:13,250
开始了。

63
00:04:13,260 --> 00:04:14,440
创建了白面包。

64
00:04:14,490 --> 00:04:18,360
让我们看看白面包，也让我们打开。

65
00:04:18,360 --> 00:04:22,550
为什么进行测试，以便我们可以比较两者。

66
00:04:22,560 --> 00:04:28,860
到目前为止看起来不错，我们可以看到六个最初的预测是正确的预测，因为在这里

67
00:04:28,860 --> 00:04:31,650
是真实观察的真实结果。

68
00:04:31,650 --> 00:04:38,970
用户实际上并没有购买SUV，这里0 0 0的预测是我们的Plus非常预测的，

69
00:04:38,970 --> 00:04:40,790
该用户没有购买乐器。

70
00:04:40,840 --> 00:04:42,250
那是正确的预测。

71
00:04:42,270 --> 00:04:43,280
70年代也一样。

72
00:04:43,290 --> 00:04:48,430
实际上是70年代购买的SUV，而且预测也是如此。

73
00:04:48,750 --> 00:04:49,050
好。

74
00:04:49,050 --> 00:04:50,160
因此，X是正确的。

75
00:04:50,160 --> 00:04:56,640
但是，“九头蛇”是不正确的，因为实际上用户并未购买SUV，但预计免税

76
00:04:56,640 --> 00:04:59,160
就是这种特殊使用的SUV。

77
00:04:59,600 --> 00:05:05,790
好的，所以像往常一样，这不是查看错误预测的最佳方法，最好的方法是采用我们的

78
00:05:05,790 --> 00:05:08,540
混淆矩阵，看看里面。

79
00:05:08,550 --> 00:05:13,410
所以这就是我们现在正在做的，我们在这里选择此代码段，从而产生混乱

80
00:05:13,410 --> 00:05:14,420
矩阵。

81
00:05:14,430 --> 00:05:15,230
开始了。

82
00:05:15,360 --> 00:05:16,820
创建混乱矩阵。

83
00:05:17,010 --> 00:05:18,100
我们来看一下。

84
00:05:18,720 --> 00:05:24,830
在手电筒中，我们可以看到错误预测的数量为七个加三个等于十。

85
00:05:24,900 --> 00:05:28,910
一百个不正确的加法中不正确的预测。

86
00:05:28,950 --> 00:05:34,030
因此，我们可以做得更好，也可以做得更好。

87
00:05:34,290 --> 00:05:41,670
因此，让我们按OK，现在我们直接进入最有趣的部分，即所有内容的可视化

88
00:05:41,670 --> 00:05:42,840
结果。

89
00:05:42,840 --> 00:05:47,970
因此，让我们选择所有这些，然后按命令控制并按Enter键执行。

90
00:05:48,240 --> 00:05:50,900
现在我们开始。

91
00:05:51,050 --> 00:05:53,350
哇，那实际上是一条美丽的曲线。

92
00:05:53,370 --> 00:05:54,560
那就是我告诉你的。

93
00:05:54,630 --> 00:05:59,220
我之前曾告诉过您，您知道我们对逻辑回归有一条直线，然后

94
00:05:59,220 --> 00:06:05,650
我们有这个K和预测边界，其中包含很多不规则性，使它不那么漂亮

95
00:06:05,910 --> 00:06:12,070
但是这里有一条漂亮的曲线，实际上让我们放大一下以查看结果。

96
00:06:12,150 --> 00:06:18,360
是的，我们说的是一条漂亮的曲线，您知道一条非常平滑的曲线，没有任何不规则性。

97
00:06:18,360 --> 00:06:21,480
好吧，这对于海军基地模型是合适的。

98
00:06:21,480 --> 00:06:24,770
那是因为海军基础模型的工作方式。

99
00:06:25,170 --> 00:06:31,680
因此，这不仅是一条优美的曲线，而且还可以很好地抓住这些年长的用户

100
00:06:31,680 --> 00:06:38,880
实际购买了Logistic回归和SVM无法提供的SUV的预估工资低

101
00:06:38,880 --> 00:06:44,130
正确分类是因为对Lenya进行了分类，因此将分隔符作为预测

102
00:06:44,130 --> 00:06:45,450
大约是一条直线。

103
00:06:45,740 --> 00:06:47,150
但是在这里它正在弯曲。

104
00:06:47,190 --> 00:06:53,730
因此，它设法抓住了大多数人，但我们仍然有一些人最叛逆，

105
00:06:53,730 --> 00:06:55,860
击败本地基本分类器。

106
00:06:55,860 --> 00:06:58,880
但是无论如何，它在这里做得很好。

107
00:06:59,190 --> 00:07:07,230
现在，对您而言，一个不错的练习是尝试了解Bismo如何对我们所有的数据点进行分类

108
00:07:07,260 --> 00:07:11,660
它们在离散区域的红色区域是非线性可分离的。

109
00:07:11,670 --> 00:07:19,170
这是基于您从curl和直觉教程中学到的内容，试图了解它们的工作方式

110
00:07:19,170 --> 00:07:25,920
通过将您在Kirill身上学到的理论应用到这组特定的数据点上，

111
00:07:25,920 --> 00:07:27,220
特殊的问题。

112
00:07:27,270 --> 00:07:33,120
这是一个很好的练习，即使以更好的方式，也会影响您对本机基础的直觉

113
00:07:33,120 --> 00:07:36,400
将会成为更多的机器学习专家。

114
00:07:36,510 --> 00:07:41,050
好，那就是训练集的结果，让我们快速看一下测试结果。

115
00:07:41,310 --> 00:07:43,650
测试结果就在这里。

116
00:07:43,650 --> 00:07:47,410
因此，让我们从这里看起来像这样。

117
00:07:47,430 --> 00:07:51,550
并按命令控制并执行就可以了。

118
00:07:51,590 --> 00:07:51,880
我们。

119
00:07:51,930 --> 00:07:53,580
好吧，让我们看看它们。

120
00:07:54,060 --> 00:07:55,930
好的，这就是测试结果。

121
00:07:56,100 --> 00:07:58,440
我们可以看到最多的红色用户。

122
00:07:58,440 --> 00:08:03,630
那就是基于需求的转移正确地预测了未购买SUV的用户，因为

123
00:08:03,630 --> 00:08:11,460
他们最终进入红色区域，与绿色用户或其他购买了SUV并

124
00:08:11,460 --> 00:08:16,800
正确预测，因为它们落入了绿色区域当然我们有一些错误的预测

125
00:08:16,800 --> 00:08:17,070
。

126
00:08:17,070 --> 00:08:21,960
如果需要，您可以计算不正确方向的数量，即

127
00:08:21,960 --> 00:08:26,520
绿色区域和红色区域中的绿色点的数量，您会发现不正确的数量

128
00:08:26,520 --> 00:08:32,030
我们在混淆矩阵中发现了10个错误的预测。

129
00:08:32,500 --> 00:08:39,250
好的，所以此练习尝试了解基于Naved的方式如何获得这种结果。

130
00:08:39,570 --> 00:08:46,080
所以您知道这是通过了解理论如何将理论与实践相结合的练习

131
00:08:46,080 --> 00:08:46,720
作品。

132
00:08:46,830 --> 00:08:49,590
关于这个特殊的实际问题。

133
00:08:49,860 --> 00:08:51,890
非常感谢您观看本教程。

134
00:08:51,930 --> 00:08:53,370
希望您喜欢这个新曲线。

135
00:08:53,370 --> 00:08:58,500
这是我们到达这里的一种新结果，我们并没有为您带来惊喜，因为您在

136
00:08:58,500 --> 00:09:05,760
将会看到，我们将获得更多不同形状的预测轮廓

137
00:09:05,760 --> 00:09:06,460
边界在这里。

138
00:09:06,470 --> 00:09:11,880
您将看到决策树和随机森林，我迫不及待地向您展示

139
00:09:11,880 --> 00:09:12,410
。

140
00:09:12,420 --> 00:09:14,240
在此之前，请享受机器学习。

