1
00:00:00,690 --> 00:00:05,730
您好，欢迎回到媒体上的深度学习课程Tauriel，我们发现了卷积

2
00:00:05,810 --> 00:00:07,290
神经网络的一切。

3
00:00:07,350 --> 00:00:11,050
今天，我们将深入探讨第一步。

4
00:00:11,100 --> 00:00:18,530
因此，这是卷积函数，我们尝试远离数学并保持直观。

5
00:00:18,540 --> 00:00:25,110
但是我不禁为您分享这个公式，因为它是如此简单，卷积基本上是

6
00:00:25,110 --> 00:00:31,380
这两个功能的组合集成，它向您展示了一个功能如何修改另一个功能，或者

7
00:00:31,470 --> 00:00:36,520
修改另一个的形状，如果您进行了任何信号处理或电气工程，或者

8
00:00:36,520 --> 00:00:42,030
一个需要信号处理的专业，您不可避免地会得出结论

9
00:00:42,030 --> 00:00:42,390
功能。

10
00:00:42,390 --> 00:00:44,090
现在很流行。

11
00:00:44,100 --> 00:00:49,490
我们将再次保持数学上的亮点或将它们分开。

12
00:00:49,500 --> 00:00:56,190
如果您想了解卷积神经网络背后的数学知识，那么请阅读大量附加内容

13
00:00:56,520 --> 00:01:05,010
是南京大学教授吴J的卷积神经网络简介

14
00:01:05,010 --> 00:01:05,820
在中国。

15
00:01:05,820 --> 00:01:12,780
该论文从字面上讲就是像五，六天前一样在几天前发表的，并且专门针对

16
00:01:12,780 --> 00:01:17,690
对于初学者的人，他们开始了解卷积神经网络

17
00:01:18,250 --> 00:01:23,700
实际上应该通过电子邮件发送给约翰逊教授的数学。

18
00:01:23,730 --> 00:01:32,040
是的，他说他的整个目标是分解或分解复杂的事物，以便新手

19
00:01:32,040 --> 00:01:33,360
到这个领域就可以理解。

20
00:01:33,360 --> 00:01:40,680
他还提到他的主页上提供了一些资料，所以如果您自己

21
00:01:40,680 --> 00:01:47,220
您只需要删除最后两个部分，就可以像Slash W.J. X一样去他的家

22
00:01:47,220 --> 00:01:52,380
页面，您将可以找到更多尚未发布的其他教程和材料

23
00:01:52,380 --> 00:01:59,120
作为论文，但是他在他的教程中使用了它们，因此您可能会发现有用的内容，因此请浏览

24
00:01:59,130 --> 00:02:05,130
如果您想了解联盟神经网络和种类背后的数学知识

25
00:02:05,130 --> 00:02:08,470
围绕该区域建立坚实的基础。

26
00:02:08,550 --> 00:02:12,570
但是我们将继续前进，我们将谈论卷积。

27
00:02:12,570 --> 00:02:17,160
因此，在左侧，从直觉上来讲，什么是好的解决方案。

28
00:02:17,160 --> 00:02:21,690
在讨论过程中，我们得到了一个输入图像，这就是我们将如何看待仅是一和零的图像

29
00:02:21,690 --> 00:02:22,750
简化事情。

30
00:02:22,950 --> 00:02:25,050
您可以在那里看到笑脸。

31
00:02:25,090 --> 00:02:28,660
然后我们有了一个特征检测器，所以特征检测器是一个三乘三矩阵。

32
00:02:28,740 --> 00:02:30,120
是否必须三乘三。

33
00:02:30,150 --> 00:02:31,920
不，不是。

34
00:02:31,920 --> 00:02:35,810
我认为亚历克斯网使用的是七乘七。

35
00:02:35,850 --> 00:02:41,640
然后，其他一些著名的传感器使用的像是五乘五特征检测器。

36
00:02:41,640 --> 00:02:48,270
它们可以不同，但​​是通常您会看到它们三乘三，这是您知道的原因

37
00:02:48,270 --> 00:02:52,110
使其三乘三，因此我们将继续采用传统方式。

38
00:02:52,170 --> 00:02:57,510
具有三乘三特征检测器的特征检测器也很重要

39
00:02:57,510 --> 00:02:58,710
因为你可能会遇到他们。

40
00:02:58,710 --> 00:03:04,080
特征检测器有很多不同的术语，但最常见的是特征检测器

41
00:03:04,110 --> 00:03:09,540
或者Eik可能听说它被称为内核，或者您可能听到它被称为Filter。

42
00:03:09,540 --> 00:03:14,760
因此，在本课程中，我们将互换使用过滤器或特征检测器，但是

43
00:03:14,760 --> 00:03:23,670
请记住，它具有这些名称，并且联合操作由X表示。

44
00:03:23,670 --> 00:03:31,230
就像您在之前和此处的公式中看到的那样，发生的事情是直观的，或者只是思考

45
00:03:31,230 --> 00:03:34,980
它是根据背景实际发生的情况而不是数学来确定的。

46
00:03:35,010 --> 00:03:40,740
好了，您可以使用此特征检测器或滤镜，然后将其放在图像上，如左侧所示。

47
00:03:40,740 --> 00:03:48,120
因此，在这种情况下，您需要覆盖左上角的，例如，左上角的九个像素

48
00:03:48,450 --> 00:03:58,760
并且您基本上将每个有价值的值相乘，以便尊重价值，因此顶部0乘以顶部左值

49
00:03:58,780 --> 00:04:04,980
按左上角的值，则基本上在1 1的位置上，位置在1 1左右

50
00:04:05,090 --> 00:04:08,670
或0 1 0 1 0 2乘0 2，依此类推。

51
00:04:08,670 --> 00:04:13,410
因此，这是这些矩阵的元素明智乘法。

52
00:04:13,410 --> 00:04:14,460
然后将结果相加。

53
00:04:14,460 --> 00:04:20,010
因此，在这种情况下，没有任何匹配，因此它总是0乘0 0或1乘。

54
00:04:20,010 --> 00:04:21,280
因此结果为零。

55
00:04:21,530 --> 00:04:26,610
在这里，您可以看到其中一个与左边的一个相匹配。

56
00:04:26,610 --> 00:04:28,120
因此，这里有1。

57
00:04:28,120 --> 00:04:30,820
没有匹配的东西没有匹配的东西没有匹配的东西。

58
00:04:30,890 --> 00:04:38,100
然后我们继续进行下一个抛出，因此将整个过滤器移动的步骤称为

59
00:04:38,100 --> 00:04:38,610
大步前进。

60
00:04:38,610 --> 00:04:40,570
因此，这里的步幅为一个像素。

61
00:04:40,680 --> 00:04:45,820
在这里，您可以再次看到右下角匹配的东西与步幅匹配，但是

62
00:04:46,110 --> 00:04:50,850
中间的最下面的一个与这里匹配，右上的与不匹配度量相匹配。

63
00:04:50,970 --> 00:04:52,040
大步向前。

64
00:04:52,170 --> 00:04:53,930
您可以更改步幅。

65
00:04:54,330 --> 00:04:56,260
您可以将其设置为一。

66
00:04:56,340 --> 00:04:58,580
无论您喜欢什么，您都会得到三个。

67
00:04:58,830 --> 00:05:02,770
最终，效果最好的一个通常是一两个。

68
00:05:02,800 --> 00:05:04,280
这就是人们所坚持的。

69
00:05:04,600 --> 00:05:09,480
我们将讨论本教程末尾的进步。

70
00:05:09,520 --> 00:05:14,170
所以这里我们有，所以当我听到您可以看到我们有两个时，我们绝对匹配，因为两个

71
00:05:14,170 --> 00:05:17,270
他们匹配，依此类推。

72
00:05:17,290 --> 00:05:24,830
因此，在这里，我们进行了另一次匹配，然后完成了。

73
00:05:24,830 --> 00:05:27,770
那么我们创造了什么。

74
00:05:27,800 --> 00:05:28,600
对。

75
00:05:28,820 --> 00:05:31,860
这里有几件重要的事情。

76
00:05:31,970 --> 00:05:38,240
右边的图像称为特征图，也有多个术语，有时也可以称为

77
00:05:38,870 --> 00:05:40,530
它可以伏特功能。

78
00:05:41,000 --> 00:05:46,280
因此，在您的博客和volution操作运算符中，某些东西不会变得混乱

79
00:05:46,280 --> 00:05:53,680
卷积，有时我想对自己的想法是错误的，但这是正确的说法是

80
00:05:53,700 --> 00:05:57,900
卷积是一种古老的功能，或者也可以称为激活图。

81
00:05:58,040 --> 00:06:02,510
但是在本课程中，我们将其称为功能图，因此可以将其称为其中任何一种

82
00:06:03,500 --> 00:06:06,300
以及我们在这里做了什么。

83
00:06:06,320 --> 00:06:09,910
如您所见，我们减小了图像的尺寸。

84
00:06:09,920 --> 00:06:15,500
那是第一位，这是我想提及的有关输入图像和

85
00:06:15,500 --> 00:06:17,090
特色文字和大步前进。

86
00:06:17,240 --> 00:06:21,690
如果您的步幅为1，则可以看到图像缩小了一点，但是如果您有权使用该图像

87
00:06:21,690 --> 00:06:25,410
将产生更多，因此功能将变得更小。

88
00:06:25,610 --> 00:06:33,950
这是整个卷积步骤的特征检测器非常重要的功能

89
00:06:33,950 --> 00:06:42,100
图像变小，因为那样会更容易处理，并且速度会更快。

90
00:06:42,110 --> 00:06:51,830
它将并且您将得到养育，因为想象像这里一样，我们得到了一个七乘七的图像

91
00:06:51,860 --> 00:06:55,310
但是想像一下您是否有合适的照片。

92
00:06:55,700 --> 00:07:02,270
或者，如果您在56像素的图像上拥有256th像素，那它就是x的像素很多，如果x

93
00:07:02,900 --> 00:07:06,940
平方或类似，假设您有300但300像素。

94
00:07:07,060 --> 00:07:13,400
所以我们不会与R.G.  B 256必须说我们有300 x 300的图像

95
00:07:13,400 --> 00:07:14,720
大小和像素。

96
00:07:14,780 --> 00:07:22,640
那么您有300平方像素，这是一个巨大的数目，因此特征检测器将

97
00:07:23,360 --> 00:07:27,580
减小图像的大小，因此跨步实际上是有益的。

98
00:07:27,740 --> 00:07:29,970
但是，问题是我们会丢失信息吗？

99
00:07:29,990 --> 00:07:34,520
应用特征检测器时是否会丢失信息？

100
00:07:34,520 --> 00:07:40,580
好吧，我们当然会丢失一些信息，因为我们的值和所得矩阵更少。

101
00:07:40,700 --> 00:07:45,950
但是同时特征检测器的目的是检测某些特征某些部​​分

102
00:07:45,950 --> 00:07:48,170
不可或缺的图像。

103
00:07:48,620 --> 00:07:53,150
因此，例如，如果您以这种方式进行思考，例如特征检测器在

104
00:07:53,150 --> 00:07:54,080
它。

105
00:07:54,080 --> 00:07:57,950
特征图中的最高编号是该模式匹配的时间。

106
00:07:57,950 --> 00:08:04,820
实际上，在一个简化的示例中，您可以获得的最高数字就是该功能

107
00:08:04,820 --> 00:08:10,550
完全匹配，您可以看到特征图中的数字恰好是四。

108
00:08:10,550 --> 00:08:16,910
因此，如果您在此处查看它，正是该特征检测器的位置，因为只有四个

109
00:08:16,910 --> 00:08:21,460
它完美匹配，因此您可以在这里看到这一部分。

110
00:08:21,470 --> 00:08:23,220
因此，此处检测到该功能。

111
00:08:23,450 --> 00:08:32,340
正如我们在本节开始时所讨论的那样，它的特点是我们如何看待事物，这就是我们

112
00:08:32,430 --> 00:08:33,080
认识它。

113
00:08:33,090 --> 00:08:40,410
我们并不是看着每个像素，而是说我们在图像或现实生活中所看到的。

114
00:08:40,410 --> 00:08:46,440
我们不会只看每一张图片，我们不会看每张图片，我们不会看每一个特征，我们只会看鼻子，帽子，羽毛。

115
00:08:47,070 --> 00:08:55,110
猎豹眼睛下方的黑色小痕迹可以区分猎豹和

116
00:08:55,110 --> 00:08:57,470
豹子或火车的形状。

117
00:08:57,480 --> 00:09:02,610
我们不区分子弹火车和普通火车，以此类推，所以我们不看一切

118
00:09:02,610 --> 00:09:08,110
我们查看要素，这就是我们要保留的要素，这就是要素图帮助我们保留的要素。

119
00:09:08,110 --> 00:09:15,480
实际上，这就是使我们提出并摆脱所有不必要的事情的原因。

120
00:09:15,570 --> 00:09:22,740
即使作为人类，我们也不会处理太多信息进入您的眼睛，在任何给定时间

121
00:09:22,740 --> 00:09:28,680
千兆字节信息，如果您查看每个点的话，如果不是TB级的信息

122
00:09:28,680 --> 00:09:35,640
您每秒的眼神，但我们仍然可以继续，因为我们摆脱了不必要的东西

123
00:09:35,640 --> 00:09:41,510
专注于对我们很重要的重要功能，这些功能正是这些功能

124
00:09:41,640 --> 00:09:42,270
做。

125
00:09:42,270 --> 00:09:51,030
所以现在继续这是我们的输入图像，您创建了一个特征图，所以最前面的是

126
00:09:51,030 --> 00:09:54,300
最前面的是我们刚创建的那个，但是为什么会有很多呢。

127
00:09:54,300 --> 00:10:00,300
但是我们创建了多个特征图，因为我们使用了不同的过滤器。

128
00:10:00,300 --> 00:10:00,590
对。

129
00:10:00,630 --> 00:10:05,430
这是我们保留大量信息的另一种方式，因此我们不仅拥有一个特征图

130
00:10:05,880 --> 00:10:12,600
我们寻找某些功能，然后或基本上是网络决定通过其培训来决定

131
00:10:12,600 --> 00:10:18,030
我们将在本节的最后通过他的培训来讨论它，它决定了哪些功能

132
00:10:18,120 --> 00:10:23,670
对于某些类型或某些类别很重要，它会寻找它们，因此将具有

133
00:10:23,670 --> 00:10:26,070
不同的过滤器，我们现在将讨论过滤器。

134
00:10:26,160 --> 00:10:32,280
但基本上，我会应用这些过滤器，因此要获得此特征图，它会应用一个类似于我们的过滤器

135
00:10:32,280 --> 00:10:36,270
看到了，但是为了获得此功能，Mabbett应用了一个不同的过滤器以使此功能得到应用了一个不同的

136
00:10:36,270 --> 00:10:38,080
过滤器等。

137
00:10:38,370 --> 00:10:43,430
因此，基本上，它只是创建这些功能图。

138
00:10:43,650 --> 00:10:49,700
实际上，这就是为什么我个人认为术语特征检测器比过滤器更好。

139
00:10:49,710 --> 00:10:56,040
记住我们在这里有这个过滤器，我们也可以称其为特征检测器

140
00:10:56,040 --> 00:10:59,440
我认为词特征检测器更适合。

141
00:10:59,490 --> 00:11:03,390
这样做的原因是目的是正确的。

142
00:11:03,390 --> 00:11:06,510
我们不想只是不想滤掉我们的形象。

143
00:11:06,510 --> 00:11:10,220
但是，即使这是一个相同的整体，只是一个术语问题。

144
00:11:10,230 --> 00:11:11,990
但是基本上我们要检测特征。

145
00:11:12,000 --> 00:11:12,270
好吧。

146
00:11:12,270 --> 00:11:19,680
在这个巢穴中，我们将转到自己的特征地图，我们已经检测到某些特征在哪里

147
00:11:19,800 --> 00:11:24,240
在图像和此特征图中，我们检测到某些其他特征在哪里，某些特定

148
00:11:24,240 --> 00:11:30,350
要素已定位，并且将在其他特定要素位于的位置检测到此要素图

149
00:11:30,350 --> 00:11:31,420
图片。

150
00:11:31,440 --> 00:11:33,420
这就是我们正在做的。

151
00:11:33,420 --> 00:11:40,470
听着我们有几个例子，所以我们在这里使用，这是来自Gip dot org的。

152
00:11:40,610 --> 00:11:48,690
他们的文档是一种免费的工具，例如绘画，您可以使用它来调整图像

153
00:11:48,690 --> 00:11:49,550
或处理您的图像。

154
00:11:49,560 --> 00:11:56,490
但基本上，他们的文档中有一些有价值的示例，在这里，他们对

155
00:11:56,490 --> 00:11:59,790
泰姬陵”，然后您可以选择要应用的过滤器。

156
00:11:59,880 --> 00:12:06,150
因此，如果您下载该程序并将照片上传到其中，则可以实际开始转换

157
00:12:06,150 --> 00:12:12,600
矩阵并应用过滤器，您会发现这些英语矩阵实际上已应用了这些东西

158
00:12:12,600 --> 00:12:15,240
在图像处理和设计等方面。

159
00:12:15,240 --> 00:12:17,150
因此，让我们来看看我们得到了什么。

160
00:12:17,240 --> 00:12:21,520
因此，如果我们将此过滤器应用在中间的五个减一中是一一是一减一中。

161
00:12:21,690 --> 00:12:23,780
您会看到它锐化了图像。

162
00:12:23,890 --> 00:12:29,010
因此，如果您想到这一点，这是非常直观的。

163
00:12:29,010 --> 00:12:36,300
所以5是像滤镜或特征检测器中间的主要像素的像素

164
00:12:36,600 --> 00:12:43,410
然后减一减一只是一种只是一种类似的方式，以一种直观的方式减少了a周围的像素

165
00:12:44,430 --> 00:12:45,000
感。

166
00:12:46,170 --> 00:12:47,020
然后模糊。

167
00:12:47,040 --> 00:12:54,150
所以基本上取相等的有效值给所有像素都相等的相等值

168
00:12:54,150 --> 00:12:59,070
中心，因此将它们结合在一起，可以得到模糊边缘增强。

169
00:12:59,070 --> 00:13:03,860
因此，在这里您可以看到它减去一和一，然后得到正确的零。

170
00:13:03,870 --> 00:13:11,100
因此，您确实删除了中间的主要像素周围的像素，只保留了其中一个像素

171
00:13:11,100 --> 00:13:15,610
减一会给您带来优势，这很难理解它是如何工作的。

172
00:13:16,290 --> 00:13:20,700
仅凭直觉就可能认为边缘检测可能更难。

173
00:13:20,700 --> 00:13:23,340
是的，所以这可能更有意义。

174
00:13:23,340 --> 00:13:25,860
正确，您把他们当成中间人。

175
00:13:25,850 --> 00:13:28,880
您减少中间一个。

176
00:13:29,050 --> 00:13:36,180
大概喜欢中间像素的强度，然后您寻找所需的像素。

177
00:13:36,420 --> 00:13:41,980
您看到的这些增强了周围对象的力量。

178
00:13:42,090 --> 00:13:43,910
所以你在那里。

179
00:13:44,720 --> 00:13:45,610
是的，是的。

180
00:13:45,690 --> 00:13:50,700
这给了您优势，您可以看到到达那里并领导另一个。

181
00:13:50,700 --> 00:13:58,130
所以这里的关键是它是对称的，您也可以看到图像也变得不对称

182
00:13:58,140 --> 00:14:03,580
因此您会感觉到它对您很突出。

183
00:14:03,840 --> 00:14:08,910
这就是当您在这里有缺点时又得到的好处，再加上这里，这就是

184
00:14:08,970 --> 00:14:13,860
现在有点技术性，但是至少我们可以得到一些直观的印象，而Lissa可以快速通过它们

185
00:14:13,860 --> 00:14:14,160
再次。

186
00:14:14,160 --> 00:14:21,480
因此，锐化，模糊，锋利的手，边缘检测到的存在和上司

187
00:14:21,480 --> 00:14:27,350
您可以看到这些是同一张图片的出色示例，但是我们正在获取特征图。

188
00:14:27,360 --> 00:14:32,430
因此，我们使用不同的特征检测器来获取同一图像的不同特征图，因此

189
00:14:32,430 --> 00:14:40,380
现在我们有很多此图像的最后一个版本，在每个版本中我们都试图检测到

190
00:14:40,440 --> 00:14:44,920
这些条款中的某些内容不适用于我们。

191
00:14:44,940 --> 00:14:50,460
他们的第二任老板可能不适用于我们的卷积神经网络，但是年龄

192
00:14:50,550 --> 00:14:51,630
发现这一点很重要。

193
00:14:51,630 --> 00:14:58,590
我们要检测边缘，边缘增强可能不会模糊锐化，因此某些东西例如前卫文字。

194
00:14:58,580 --> 00:15:02,450
对于我们的工作而言，可能是最重要的一项。

195
00:15:02,460 --> 00:15:07,560
在理解计算机方面，他们将自己决定，而神经网络将决定

196
00:15:07,560 --> 00:15:12,900
对自己而言，重要的是什么，什么不重要，人的肉眼甚至可能无法识别。

197
00:15:12,900 --> 00:15:14,910
您将无法理解这些功能的含义。

198
00:15:14,910 --> 00:15:22,530
但是计算机会做出决定，这就是神经网络的魅力，它们可以处理很多

199
00:15:22,530 --> 00:15:28,950
不同的事物，即使没有直觉或没有解释也无法理解

200
00:15:28,950 --> 00:15:34,380
为什么他们会了解哪些功能对他们很重要，无论我们是否为其命名

201
00:15:34,810 --> 00:15:39,830
对于人工神经网络来说，这是一个无关紧要的问题。

202
00:15:39,990 --> 00:15:41,260
和我最喜欢的一个。

203
00:15:41,280 --> 00:15:50,940
这是来自Geoffrey Hinton的Geoffrey Hinton的图像通过了其中的一个滤镜。

204
00:15:50,940 --> 00:15:53,070
好的，这样把我们带到了Teresa Tauriel的尽头。

205
00:15:53,070 --> 00:15:55,460
希望您喜欢卷积学习。

206
00:15:55,470 --> 00:16:02,490
关键要点在于，卷积是我们进化的主要目的，是在其中找到特征。

207
00:16:02,490 --> 00:16:08,280
使用特征检测器将您的图像放入特征图，并将其放入将来的图

208
00:16:08,340 --> 00:16:15,710
它仍然保留了像素之间的空间关系，这对我们非常重要

209
00:16:15,720 --> 00:16:19,280
因为如果它们完全被弄乱了，那么我们就已经失去了模式。

210
00:16:19,350 --> 00:16:25,110
同时，重要的是要了解大多数时间神经网络的功能

211
00:16:25,110 --> 00:16:32,430
会检测并用来识别某些图像，而克拉斯对人类而言毫无意义，但

212
00:16:32,460 --> 00:16:33,120
他们工作。

213
00:16:33,120 --> 00:16:34,420
这就是卷积。

214
00:16:34,440 --> 00:16:36,280
我期待下一个Tauriel的到来。

215
00:16:36,300 --> 00:16:37,980
在此之前，请尽情学习。

