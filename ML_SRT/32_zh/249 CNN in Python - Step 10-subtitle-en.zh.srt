1
00:00:00,210 --> 00:00:02,690
您好，欢迎来到本Python教程。

2
00:00:02,700 --> 00:00:07,170
好吧，这将是一个非常令人兴奋的Tauriel，因为在本教程中，我们将看到

3
00:00:07,170 --> 00:00:12,180
如果我们能够实现在测试中获得80％以上的准确性的目标。

4
00:00:12,180 --> 00:00:17,580
因此，您是否找到了一种无需对任何参数进行任何设置即可达到该精度的方法。

5
00:00:17,700 --> 00:00:20,670
在上一教程的结尾，我给了你一个提示。

6
00:00:20,670 --> 00:00:26,430
提示的答案是深度学习部分的标题，实际上是

7
00:00:26,430 --> 00:00:32,670
让我们实现目标是建立更深层的深度学习模型，这是更深层的卷积神经

8
00:00:32,670 --> 00:00:34,980
网络以及我们如何使其更深入。

9
00:00:35,130 --> 00:00:36,990
好吧，我们有两个选择。

10
00:00:36,990 --> 00:00:40,550
第一种选择是添加另一个卷积层。

11
00:00:40,740 --> 00:00:44,090
第二种选择是添加另一个完全连接的层。

12
00:00:44,160 --> 00:00:50,730
因此，也许您正在尝试，也许您已经发现最好的解决方案实际上是添加卷积

13
00:00:50,730 --> 00:00:51,460
层。

14
00:00:51,510 --> 00:00:53,110
这就是我们在本教程中要做的。

15
00:00:53,130 --> 00:00:58,260
但是您始终可以通过考虑在其中添加卷积的两个选项来改进模型

16
00:00:58,590 --> 00:01:00,590
以及完全连接的字母。

17
00:01:00,840 --> 00:01:06,090
但是我敢打赌，我们设法实现了我们的目标，即到

18
00:01:06,090 --> 00:01:12,720
仅添加第二个卷积层，您将看到它将如何绝对改善我们的性能结果

19
00:01:12,990 --> 00:01:14,340
根据您的观察。

20
00:01:14,340 --> 00:01:18,110
那是在测试集上以及减少过度拟合。

21
00:01:18,150 --> 00:01:20,670
所以，让我们做吧，看看我是否正确。

22
00:01:20,670 --> 00:01:26,610
此外，进行本教程非常重要，因为您将看到添加另一个教程如此容易

23
00:01:26,610 --> 00:01:34,650
卷积层，因为基本上我们只需要做的就是将这条线复制并粘贴

24
00:01:35,070 --> 00:01:36,550
在前两个步骤之后。

25
00:01:36,630 --> 00:01:41,910
就是在我们构建了一个卷积层之后，我们在该卷积层上应用了Max滑轮来获取池

26
00:01:41,910 --> 00:01:42,380
层。

27
00:01:42,480 --> 00:01:46,270
因此，这恰好在这里，当然应该在展平步骤之前。

28
00:01:46,470 --> 00:01:51,520
因此，我将在此处粘贴此行，以添加另一个卷积层。

29
00:01:51,540 --> 00:01:57,190
当然，我们还需要在刚刚添加的该卷积层上应用最大池。

30
00:01:57,390 --> 00:02:08,980
因此，我将以此为基础，并在此指定在此添加第二个卷积。

31
00:02:10,160 --> 00:02:10,730
好吧。

32
00:02:10,750 --> 00:02:14,200
现在，在这两行中，我们只需要更改一件事。

33
00:02:14,290 --> 00:02:21,160
这是输入形状参数，因为我们必须指定此输入参数，因为它对应

34
00:02:21,160 --> 00:02:28,070
我们的形象，以及我们的CNN应该如何期望，这是它作为输入的期望尺寸

35
00:02:28,090 --> 00:02:28,760
CNN。

36
00:02:28,840 --> 00:02:34,240
这就是为什么我们在Pichay参数中指定此值以指定预处理后的尺寸的原因

37
00:02:34,360 --> 00:02:37,320
图像将作为CNN的输入。

38
00:02:37,480 --> 00:02:43,750
但是这里我们添加了第二个卷积层，输入将不是图像，而是

39
00:02:43,750 --> 00:02:47,100
来自前两个步骤的组合特征图。

40
00:02:47,110 --> 00:02:53,110
因此，我们将在图像上而不是图像上应用卷积技巧和最大拉动技巧。

41
00:02:53,110 --> 00:02:54,390
合并的要素图。

42
00:02:54,400 --> 00:02:59,410
因此，这是完全相同的操作，而且是相同的技巧，但它在前两个的拉动特征图上

43
00:02:59,410 --> 00:03:00,000
脚步。

44
00:03:00,190 --> 00:03:05,980
因此，我们无需在此处包括此参数输入形状，因为我们仅需包括

45
00:03:06,280 --> 00:03:11,410
当我们以前没有任何东西时，我们需要将其包括在内，因为我们没有图像

46
00:03:11,410 --> 00:03:12,410
以前还没有。

47
00:03:12,670 --> 00:03:17,630
但是在这里，我们需要一些东西，然后才是产生步骤的集合特征图。

48
00:03:17,680 --> 00:03:23,450
因此，克里斯将知道这一点，因此我们无需在Pichay参数中包括此内容。

49
00:03:23,650 --> 00:03:28,630
因此，总而言之，当您添加新的卷积层时，您只需要一些功能

50
00:03:28,630 --> 00:03:29,470
探测器。

51
00:03:29,470 --> 00:03:35,080
这些特征检测器的尺寸和激活功能，然后应用混合拉伸

52
00:03:35,080 --> 00:03:37,000
仅具有此池大小参数。

53
00:03:37,150 --> 00:03:39,540
因此，这里我们将保留相同的参数。

54
00:03:39,550 --> 00:03:44,590
您将看到我们将获得良好的结果，然后，如果您想获得乐趣，添加新的卷积层

55
00:03:44,980 --> 00:03:49,120
那么您可以增加特征检测器的数量，并且每次增加一倍。

56
00:03:49,120 --> 00:03:54,310
因此，例如，您可以添加带有64个特征检测器的第三卷积层。

57
00:03:54,310 --> 00:03:55,660
这是一种常见的做法。

58
00:03:55,660 --> 00:03:57,380
这导致了很好的结果。

59
00:03:57,460 --> 00:04:03,250
但是我敢打赌，现在只有这两个卷积层才能达到超过

60
00:04:03,250 --> 00:04:04,350
80％。

61
00:04:04,360 --> 00:04:08,100
因此，让我们检查一下，您会发现我重新启动了Spyder。

62
00:04:08,170 --> 00:04:15,580
因此，我现在要做的基本上是选择所有内容，然后只需要按Enter键即可

63
00:04:15,580 --> 00:04:17,150
将运行整个代码。

64
00:04:17,170 --> 00:04:22,420
因此，在运行它之前，请记住在之前的Statoil中我们只有一个卷积层，

65
00:04:22,420 --> 00:04:28,180
在测试集上的准确度为75％，而测试结果的准确度相差10％

66
00:04:28,180 --> 00:04:33,280
测试集和训练集的准确性，因为训练集的准确性约为85

67
00:04:33,280 --> 00:04:34,000
百分。

68
00:04:34,210 --> 00:04:38,110
现在，我们对具有两个卷积层的新CNN有了一个目标。

69
00:04:38,170 --> 00:04:43,540
它将获得10％的精度超过80％，并且精度之间的差异要小得多

70
00:04:43,540 --> 00:04:45,980
测试集和训练集之一。

71
00:04:46,180 --> 00:04:47,080
让我们来看看。

72
00:04:47,170 --> 00:04:49,670
让我们运行它，让我们喝点咖啡。

73
00:04:50,020 --> 00:04:50,890
好准备

74
00:04:50,890 --> 00:04:53,650
三二一走。

75
00:04:54,570 --> 00:05:00,330
使用Tanstaafl返回并为该动车组2000图像找到了属于两个类的数千个图像

76
00:05:00,330 --> 00:05:02,410
属于测试集的两个类别。

77
00:05:02,430 --> 00:05:04,140
在这里，我们读第一本书。

78
00:05:04,190 --> 00:05:10,860
25个中的一个，我们开始时对训练集的准确性为50％

79
00:05:10,860 --> 00:05:13,140
功能约占70％。

80
00:05:13,140 --> 00:05:15,350
并记住，这将减少。

81
00:05:15,480 --> 00:05:21,330
而且这将不断增加，我们不仅希望该精度超过80％，而且我们还希望

82
00:05:21,330 --> 00:05:25,050
希望测试集的准确性超过80％。

83
00:05:25,050 --> 00:05:26,800
所以现在它正在运行。

84
00:05:26,920 --> 00:05:31,470
我很高兴看到最后和我们喝咖啡或午餐之前会发生什么

85
00:05:31,710 --> 00:05:36,430
让我们来看看第一个时期测试集的准确性。

86
00:05:36,450 --> 00:05:37,410
开始了。

87
00:05:37,410 --> 00:05:38,370
快好了。

88
00:05:40,190 --> 00:05:41,190
我们先来。

89
00:05:41,220 --> 00:05:48,770
EPOC完成了测试中污渍的准确度，开始时为55％，几乎为56％。

90
00:05:48,770 --> 00:05:51,390
是的，实际上就像以前一样。

91
00:05:51,560 --> 00:05:53,460
我们开始缓慢，我们开始缓慢。

92
00:05:53,600 --> 00:05:55,880
但是，让我们看看最终会得到什么。

93
00:05:56,240 --> 00:05:58,120
所以现在我们处于第二个时代。

94
00:05:58,340 --> 00:06:01,750
训练集的准确性已经很好地提高了。

95
00:06:01,790 --> 00:06:04,070
我们已经达到60％。

96
00:06:04,190 --> 00:06:10,760
如您所见，它与以前非常相似，这不是因为我们添加了第二个卷积层

97
00:06:10,760 --> 00:06:12,630
我们需要增加体重。

98
00:06:12,740 --> 00:06:14,050
所以应该没问题。

99
00:06:14,390 --> 00:06:19,600
第二个时代即将完成，准确度不断提高。

100
00:06:19,750 --> 00:06:21,940
百分之六十四。

101
00:06:21,950 --> 00:06:30,000
让我们看看在第二个阶段结束时会得到什么，我们确实得到了64％和68％

102
00:06:30,090 --> 00:06:31,500
在腾讯上。

103
00:06:31,500 --> 00:06:32,970
好的，让我们开始吧。

104
00:06:33,030 --> 00:06:36,360
就我而言，让我们喝杯咖啡或小睡一下。

105
00:06:36,360 --> 00:06:38,080
我刚醒来，想睡个午觉。

106
00:06:38,100 --> 00:06:40,880
我只要喝杯好咖啡就感到满意，让我们保持联系。

107
00:06:40,890 --> 00:06:43,740
在20分钟内。

108
00:06:43,790 --> 00:06:44,150
好吧。

109
00:06:44,150 --> 00:06:46,160
我们快完成了，让我们看看我们得到了什么。

110
00:06:46,160 --> 00:06:49,500
那是25中的最后25。

111
00:06:49,550 --> 00:06:50,830
五秒钟

112
00:06:50,830 --> 00:07:00,800
趋势集的准确性将达到85％，测试的准确性将达到82％。

113
00:07:00,850 --> 00:07:05,790
令人惊奇的是，不仅我们达到了要达到80％以上准确度的测试目标。

114
00:07:05,860 --> 00:07:11,050
而且我们还减少了训练说的准确性和测试准确性之间的差异，因为

115
00:07:11,050 --> 00:07:16,900
现在我们确实得到了3％的差异，而不是我们得到的10％的差异

116
00:07:16,900 --> 00:07:18,090
上一教程。

117
00:07:18,280 --> 00:07:24,670
因此，恭喜我们建立了一个很好的卷积神经网络模型，并具有良好的预测。

118
00:07:24,670 --> 00:07:28,250
因此，您仍然可以尝试并尝试改进此模型。

119
00:07:28,330 --> 00:07:33,450
当然，添加更多的卷积层将有助于获得更高的准确性。

120
00:07:33,520 --> 00:07:40,330
但是，如果您想真正获得更高的精度，那就在这里选择更高的目标尺寸

121
00:07:40,570 --> 00:07:46,660
用于训练集编辑器集的图像，以便获得有关像素模式的更多信息

122
00:07:47,040 --> 00:07:52,600
因为确实，如果您增加图像的大小，即所有图像减小到的大小

123
00:07:52,600 --> 00:07:53,710
将调整大小。

124
00:07:53,800 --> 00:07:59,000
好吧，您将在输入中获得更多像素，行中获得更多像素和列

125
00:07:59,020 --> 00:08:03,580
图片，因此您将获得更多有关像素的信息。

126
00:08:03,580 --> 00:08:09,280
所以您可以尝试一下，但是我建议您使用NGV，或者在入睡之前尝试一下

127
00:08:09,280 --> 00:08:13,330
甚至可以达到90％以上的准确性。

128
00:08:13,330 --> 00:08:15,300
好的，到此为止。

129
00:08:15,310 --> 00:08:18,490
恭喜您制作了卷积神经网络。

130
00:08:18,490 --> 00:08:22,890
我们没有做蛋糕，希望以后对您有用。

131
00:08:23,170 --> 00:08:26,280
因此，我将在下一部分降维中看到您。

132
00:08:26,380 --> 00:08:28,090
直到那时，还是德国人Shalani。

