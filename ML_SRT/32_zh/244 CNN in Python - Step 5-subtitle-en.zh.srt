1
00:00:00,450 --> 00:00:05,550
您好，欢迎来到我省的Python教程，当我们开始第一步时，

2
00:00:05,550 --> 00:00:06,620
卷积步骤。

3
00:00:06,740 --> 00:00:09,660
这是完成的一步，现在还有三步。

4
00:00:09,690 --> 00:00:15,750
在今天的挪威国家石油公司（Statoil）中，我们将负责第二步的合并步骤，以便快速提醒您

5
00:00:15,750 --> 00:00:21,650
这很容易，它只包含减少要素地图的大小以及我们如何做到这一点。

6
00:00:21,720 --> 00:00:27,280
再次，我们将这张两乘两步的桌子放在这个蓝色方形桌子上，然后在此处查看

7
00:00:27,330 --> 00:00:32,790
我们会在整个特征图上滑动，每次我们提取蓝色内的四个单元格中的最大值

8
00:00:32,790 --> 00:00:33,510
广场。

9
00:00:33,510 --> 00:00:39,120
因此，取最大值称为“最大池”（Max pooling）。

10
00:00:39,120 --> 00:00:44,730
就像我们之前使用在输入图像上滑动的特征检测器所做的那样，迈出了一大步。

11
00:00:44,730 --> 00:00:50,520
在这里进行一次尝试时，步幅为2，因此自从每次我们采用最大

12
00:00:50,790 --> 00:00:56,900
的二乘二表最终发生的事情是，我们得到了一个尺寸减小的新特征图。

13
00:00:56,940 --> 00:01:01,450
更准确地说，原始特征图的大小被除以2。

14
00:01:01,470 --> 00:01:06,930
当我们应用最大池化时，在这里我们可以看到尺寸是五乘五，因为

15
00:01:06,960 --> 00:01:08,450
五行五列。

16
00:01:08,610 --> 00:01:13,110
当我们应用最大池化时，我们得到的特征图为三乘三。

17
00:01:13,140 --> 00:01:15,940
因此，这实际上是原始大小的一半加一。

18
00:01:16,080 --> 00:01:21,390
但是，如果要素图的大小为偶数，则将其大小除以二。

19
00:01:21,390 --> 00:01:27,090
因此，我们在每个未来的地图上应用混合池，然后获得由

20
00:01:27,150 --> 00:01:31,330
所有这些缩小的特征图，这就是所谓的池化。

21
00:01:31,350 --> 00:01:31,710
好吧。

22
00:01:31,740 --> 00:01:32,970
以及为什么我们要这样做。

23
00:01:32,970 --> 00:01:35,230
我们为什么要应用此溢出步骤。

24
00:01:35,240 --> 00:01:39,480
这是因为我们要减少下一步要获得的节点数。

25
00:01:39,480 --> 00:01:45,330
那是扁平化的步骤，然后是完整的连接步骤，因为在接下来的这些步骤中，基本上

26
00:01:45,330 --> 00:01:52,020
我们将得到的是将未来地图的所有像元平整在一个巨大的一维向量中。

27
00:01:52,050 --> 00:01:57,300
因此，如果我们没有很好地减小这些特征图的大小，我们将得到两个大向量，然后

28
00:01:57,300 --> 00:02:02,890
到达完全连接的层中的节点，因此我们的模型将是高度计算密集型的。

29
00:02:03,090 --> 00:02:07,920
我们希望避免这种情况，因此我们在进行最大拉动步骤以减小未来的规模

30
00:02:07,920 --> 00:02:12,430
映射，因此减少了将来的全连接层中的节点数量。

31
00:02:12,480 --> 00:02:16,020
这就是为什么这将减少复杂性并减少执行时间。

32
00:02:16,020 --> 00:02:23,040
但是不会损失性能，因为通过将两个表中的最大值乘以该功能的两个表

33
00:02:23,040 --> 00:02:29,310
映射我们以某种方式保留信息，因为我们一直在跟踪图像的各个部分

34
00:02:29,310 --> 00:02:34,950
包含对应于特征检测器检测到某些特定特征的位置的高数字

35
00:02:35,130 --> 00:02:36,360
在输入图像中。

36
00:02:36,360 --> 00:02:40,530
因此，我们不会丢失空间结构信息，因此我们也不会丢失

37
00:02:40,530 --> 00:02:41,030
模型。

38
00:02:41,100 --> 00:02:46,930
但与此同时，我们设法降低了时间复杂度，并降低了计算强度。

39
00:02:47,130 --> 00:02:48,570
因此，这是非常重要的一步。

40
00:02:48,690 --> 00:02:51,360
现在让我们在Spider上实施。

41
00:02:51,360 --> 00:02:58,620
因此，这里已经准备就绪，我们将照常使用分类器，因为再次

42
00:02:58,620 --> 00:03:04,370
我们现在要做的是使用仍然与Add方法相同的方法。

43
00:03:04,520 --> 00:03:11,220
所以在这里，然后添加所有现在的括号，然后我们将使用一个将完成的函数

44
00:03:11,490 --> 00:03:13,680
这个最大拉动步骤。

45
00:03:13,680 --> 00:03:16,860
因此，根据您的情况，此函数的名称将是什么。

46
00:03:16,980 --> 00:03:19,500
好吧，很容易就在这里。

47
00:03:19,500 --> 00:03:21,350
是Max拉2d。

48
00:03:21,360 --> 00:03:23,820
因此，将其放入我们的Add方法中。

49
00:03:23,910 --> 00:03:33,960
最大值向右拉，然后加上新的括号以输入您知道我们滑动的表格的大小

50
00:03:34,020 --> 00:03:37,420
遍及整个功能图，以在每个表中使用最大值。

51
00:03:37,680 --> 00:03:42,260
因此，size参数称为完整尺寸。

52
00:03:42,260 --> 00:03:43,100
开始了。

53
00:03:43,310 --> 00:03:49,120
然后等于然后加上括号，这就是我们输入尺寸的地方。

54
00:03:49,130 --> 00:03:54,800
因此，在这张幻灯片中给出的示例中，您可以看到我们的尺寸为2乘2，实际上

55
00:03:54,800 --> 00:04:00,030
在第一步之后创建的要素地图上应用最大池化时，通常会采取什么措施。

56
00:04:00,200 --> 00:04:05,090
好吧，大多数时候我们采取二乘二的方法，因为我们不想因为采取二乘而丢失信息

57
00:04:05,090 --> 00:04:05,640
加两个

58
00:04:05,660 --> 00:04:10,940
我们会保留信息，但我们仍在精确掌握哪些地方具有较高的数字和功能

59
00:04:10,940 --> 00:04:15,180
映射文本和输入图像的特定特征。

60
00:04:15,200 --> 00:04:19,170
因此，两乘两下就可以了，我建议大部分时间都使用它。

61
00:04:19,220 --> 00:04:25,470
因此，要将这两个维度放在一起，这很简单，我们只需要加和即可。

62
00:04:25,660 --> 00:04:26,060
好吧。

63
00:04:26,080 --> 00:04:28,930
这样就完成了最大拉动步骤。

64
00:04:28,960 --> 00:04:31,080
我们没有更多可输入的参数。

65
00:04:31,180 --> 00:04:37,200
基本上，我认为这条线会减少您将来的地图的大小，并且可以一分为二。

66
00:04:37,690 --> 00:04:42,130
因此，我将选择此行并执行。

67
00:04:42,130 --> 00:04:42,960
开始了。

68
00:04:42,970 --> 00:04:46,140
现在，要素地图的大小被除以二。

69
00:04:46,300 --> 00:04:50,980
因此，我们只是在不降低模型性能的情况下降低了模型的复杂性。

70
00:04:51,130 --> 00:04:51,970
完善。

71
00:04:51,970 --> 00:04:56,360
因此，第二步完成了另外两个操作，我们将在下一教程中进行第三步。

72
00:04:56,500 --> 00:04:58,120
在此之前，请享受机器学习。

