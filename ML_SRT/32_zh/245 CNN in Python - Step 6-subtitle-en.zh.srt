1
00:00:00,510 --> 00:00:03,160
您好，欢迎来到本Python教程。

2
00:00:03,180 --> 00:00:03,580
好吧。

3
00:00:03,580 --> 00:00:05,390
我们完成了四分之二的步骤。

4
00:00:05,400 --> 00:00:08,210
今天是第三步扁平化。

5
00:00:08,520 --> 00:00:14,910
因此，这一步是至关重要的一步，因为基本上，这些步骤包括将我们所有合并的

6
00:00:14,940 --> 00:00:18,750
特征图并将它们放入一个矢量中。

7
00:00:18,750 --> 00:00:23,640
这当然是一个巨大的载体，因为即使我们减小了未来质量的规模，

8
00:00:23,640 --> 00:00:24,850
除以二。

9
00:00:25,080 --> 00:00:27,630
好吧，我们仍然有许多拉动特征图。

10
00:00:27,630 --> 00:00:30,830
因此，总而言之，我们在池化层中拥有要素地图。

11
00:00:31,080 --> 00:00:37,890
我们应用Flaten步骤，我们得到了包含所有不同单元格的巨大单个矢量

12
00:00:37,950 --> 00:00:39,430
所有不同的特征图。

13
00:00:39,480 --> 00:00:43,180
这个单一向量将成为未来的输入层。

14
00:00:43,200 --> 00:00:48,870
最后，从上一节我们知道这是经典的A-N，并且具有完全连接

15
00:00:48,870 --> 00:00:53,790
现在我们可以问自己两个非常重要的问题。

16
00:00:53,940 --> 00:01:00,270
第一个问题是为什么我们不通过将所有这些特征图展平为

17
00:01:00,270 --> 00:01:01,860
一个相同的单个向量。

18
00:01:02,190 --> 00:01:08,520
答案是因为通过创建特征图，我们提取了空间结构信息

19
00:01:08,850 --> 00:01:11,850
您知道在未来的地图中获得这些高数字。

20
00:01:11,850 --> 00:01:17,090
多亏了我们通过卷积步骤将特征检测器应用于输入图像。

21
00:01:17,100 --> 00:01:23,370
所以基本上这些高数字代表我们图像的空间结构，因为这些高数字

22
00:01:23,370 --> 00:01:28,230
将来，地图将与输入图像中的特定特征相关联。

23
00:01:28,350 --> 00:01:33,780
从那时起，我们逐步应用墨西哥人，因此保持这些高数字，因为我们取了最大值，然后

24
00:01:33,780 --> 00:01:38,710
展平步骤仅包括将未来地图的像元中的所有数字合为一

25
00:01:38,730 --> 00:01:39,920
相同的单个向量。

26
00:01:40,080 --> 00:01:43,460
好吧，我们仍然将这些高数字保留在一个向量中。

27
00:01:43,650 --> 00:01:49,170
并且由于这些高数字代表输入图像的空间结构，并且与

28
00:01:49,170 --> 00:01:51,550
空间结构的一个特定特征。

29
00:01:51,660 --> 00:01:57,630
好吧，即使在这个巨大的单个矢量中，我们也保留了这种空间结构信息。

30
00:01:57,630 --> 00:02:03,480
现在第二个问题是为什么我们不直接获取输入图像的所有像素并展平

31
00:02:03,480 --> 00:02:05,690
将它们放入一个相同的单个向量中。

32
00:02:05,830 --> 00:02:09,950
您知道无需应用前面的步骤即可进行卷积步骤和下一步。

33
00:02:10,260 --> 00:02:15,660
那是因为如果我们直接将输入图像像素展平到这个巨大的单一一维中

34
00:02:15,660 --> 00:02:21,390
向量，则此巨大向量的每个节点将代表图像的一个像素，而与

35
00:02:21,390 --> 00:02:22,930
周围的像素。

36
00:02:23,130 --> 00:02:29,130
因此，我们仅获得有关像素本身的信息，而没有获得有关该像素的信息，特别是

37
00:02:29,160 --> 00:02:31,700
连接到周围的其他像素。

38
00:02:31,710 --> 00:02:37,010
因此，基本上我们不会获得该像素周围空间结构的任何信息。

39
00:02:37,430 --> 00:02:43,970
但是，如果我们应用卷积步骤和最大拉动步骤来创建所有尺寸减小的特征

40
00:02:43,980 --> 00:02:50,430
将所有这些特征图映射并展平到这个巨大的单个一维向量中，然后

41
00:02:50,430 --> 00:02:56,010
特征图对应于图像的一个特定特征，然后对应于该巨大矢量的每个节点

42
00:02:56,010 --> 00:03:01,980
包含较高的数字将代表特定功能的信息，特定细节

43
00:03:01,980 --> 00:03:03,010
输入图像。

44
00:03:03,120 --> 00:03:08,820
例如像狗鼻子的左上边界，那是因为这个高数字不代表

45
00:03:08,910 --> 00:03:10,570
本身就是唯一的像素。

46
00:03:10,680 --> 00:03:16,590
它代表了这个微小的特定特征，特征检测器可以通过以下方式从输入图像中提取

47
00:03:16,590 --> 00:03:18,230
卷积运算。

48
00:03:18,360 --> 00:03:23,700
因此，最终我们保留了输入图像的空间结构信息。

49
00:03:23,700 --> 00:03:28,170
因此，现在让我们回到蜘蛛，让我们来完成这一扁平化步骤。

50
00:03:28,170 --> 00:03:35,850
因此，像往常一样，我们将采用分类器并在此处复制并粘贴，然后加点以进行介绍

51
00:03:35,850 --> 00:03:40,620
我们仍然用来创建新图层的add方法。

52
00:03:40,620 --> 00:03:42,620
好吧，这个巨大的单一向量。

53
00:03:42,870 --> 00:03:47,970
因此，在括号内以及这些括号内，我们将使用尚未使用的新函数

54
00:03:47,970 --> 00:03:52,150
之前，就像您可能已经猜到了扁平函数一样。

55
00:03:52,200 --> 00:03:57,780
此功能会将拉动层中的所有要素图展平为这个巨大的

56
00:03:57,780 --> 00:03:58,670
向量。

57
00:03:58,680 --> 00:04:05,190
因此，让我们将此函数拼写成这种拼写形式，然后加上一些括号，因为它是

58
00:04:05,190 --> 00:04:05,820
一个功能。

59
00:04:06,030 --> 00:04:11,310
但是，好消息是我们不需要在这里输入任何参数，因为Carrot会理解

60
00:04:11,310 --> 00:04:16,740
您知道，因为我们在进行或分类或对象化时需要将前一层

61
00:04:16,740 --> 00:04:20,820
我们在卷积步骤和最大衰落步骤之后获得。

62
00:04:20,820 --> 00:04:28,470
所以我们都很好，我们只需要选择这一行并执行以完成展平步骤即可，

63
00:04:28,560 --> 00:04:29,730
一切都很好。

64
00:04:29,730 --> 00:04:34,800
现在，创建了这个巨大的单个矢量，基本上它包含了空间的所有信息

65
00:04:34,800 --> 00:04:36,380
图片的结构。

66
00:04:36,420 --> 00:04:43,140
因此，现在我们剩下要做的就是创建一个经典的A，然后对图像进行分类，

67
00:04:43,140 --> 00:04:48,120
由于包含了空间信息的输入向量，它将很好地对它们进行分类

68
00:04:48,120 --> 00:04:49,080
结构体。

69
00:04:49,080 --> 00:04:54,540
因此，我们又走了三步，我们已经完成了卷积神经网络

70
00:04:54,540 --> 00:04:55,700
在下一次迭代中。

71
00:04:56,100 --> 00:04:57,780
因此，我期待与您相会。

72
00:04:57,780 --> 00:04:59,680
在此之前，请享受机器学习。

