1
00:00:00,450 --> 00:00:05,060
您好，欢迎使用本卷积神经网络Python教程。

2
00:00:05,070 --> 00:00:10,080
因此，我不得不再次表示祝贺，因为您在产品中建立了第一个深度学习模型

3
00:00:10,080 --> 00:00:12,330
一节人工神经网络。

4
00:00:12,570 --> 00:00:18,390
正如您在直觉中所理解的那样，在神经网络上进行卷积只是人为的

5
00:00:18,390 --> 00:00:23,890
神经网络，您可以使用此卷积技巧在其中添加一些卷积层。

6
00:00:23,910 --> 00:00:25,970
以及为什么我们使用这种卷积技巧。

7
00:00:26,070 --> 00:00:31,810
它是为了保留图像中的空间结构，因此能够对某些图像进行分类。

8
00:00:32,070 --> 00:00:36,690
因此，您自己就有了点卷积，即作品是很棒的计算机深度学习模型

9
00:00:36,690 --> 00:00:42,520
视觉将一些图像分类为一些照片，甚至一些图像和一些视频。

10
00:00:42,780 --> 00:00:48,810
因此，在本节中，我们将不像以前的部分那样解决任何业务问题。

11
00:00:49,170 --> 00:00:55,020
但是我们只是要解决一个图像分类问题，我们的目标是对图像进行分类

12
00:00:55,020 --> 00:00:59,480
一些图像，并告诉每个图像图像的类别。

13
00:00:59,580 --> 00:01:03,580
因此，我们将处理一个非常简单的图像分类问题。

14
00:01:03,690 --> 00:01:10,380
我们将获得一些猫和狗的图像，并将训练一个卷积神经网络来预测

15
00:01:10,530 --> 00:01:14,190
如果图像是狗或猫的照片。

16
00:01:14,190 --> 00:01:18,900
因此，现在有些人可能会认为预测图像是否为

17
00:01:18,900 --> 00:01:25,020
猫或狗的照片，但这里要了解的关键是我们将拥有一个充满

18
00:01:25,020 --> 00:01:28,650
图像这些图像将是猫和狗的一些图像。

19
00:01:28,860 --> 00:01:34,620
但是，一旦我们建立了卷积神经网络模型，您只需要更改图像的图像即可。

20
00:01:34,620 --> 00:01:39,110
文件夹中的猫和狗，并用您要使用的图像替换它们。

21
00:01:39,120 --> 00:01:43,440
例如，如果本课程中有医生，您就可以更换这些猫，

22
00:01:43,440 --> 00:01:49,530
通过一些医学图像来查找图像，您必须预测这些图像所属的类别。

23
00:01:49,650 --> 00:01:55,530
因此，例如，如果您正在处理大脑图像，则必须预测该大脑图像是否包含

24
00:01:55,650 --> 00:02:02,490
如果您知道答案是很多观察结果，例如成千上万的观察结果

25
00:02:02,760 --> 00:02:09,330
那么您将能够训练卷积神经网络来预测是否有一些新的大脑图像包含

26
00:02:09,420 --> 00:02:11,020
肿瘤是或不是。

27
00:02:11,040 --> 00:02:16,590
所以我不是这里的医生，所以我希望我不要做没有意义的事情，但我知道深度学习

28
00:02:16,590 --> 00:02:22,710
在医学上用于医学成像，我也知道他们使用卷积神经网络来加速

29
00:02:22,710 --> 00:02:26,190
正如我们在本文中可以看到的，有关癌症的研究。

30
00:02:26,220 --> 00:02:31,860
这就是我们正在研究猫和狗的非常简单的图像的关键点，但是您将

31
00:02:31,860 --> 00:02:38,380
如果您需要预测图像的某些类别，则可以用所需的图像替换它们。

32
00:02:38,790 --> 00:02:39,060
好。

33
00:02:39,060 --> 00:02:44,820
所以现在我们要做的是为卷积神经网络准备我们的工作环境

34
00:02:45,150 --> 00:02:50,550
因为您将看到与我们以前使用的产品相比，情况将会发生变化

35
00:02:50,880 --> 00:02:57,450
因为到目前为止，请记住在分数中我们曾经使用过的数据是包含表的表

36
00:02:57,450 --> 00:03:03,630
除聚类或强化学习外，一些自变量和一个因变量。

37
00:03:03,630 --> 00:03:10,350
但是无论如何我们以前都有一张桌子，现在我们有一些图像，所以我们需要做一些图像处理

38
00:03:10,350 --> 00:03:15,130
才能将这些图像输入到我们有效的卷积神经中。

39
00:03:15,330 --> 00:03:16,910
那么我们该怎么做。

40
00:03:16,920 --> 00:03:25,350
好吧，首先让我们进入第8部分“深度学习”中的机器学习AC文件夹，然后进入第41部分“卷积”

41
00:03:25,370 --> 00:03:26,850
在可行的世界中。

42
00:03:26,850 --> 00:03:27,570
开始了。

43
00:03:27,750 --> 00:03:28,830
那是文件夹。

44
00:03:29,130 --> 00:03:29,400
好。

45
00:03:29,400 --> 00:03:35,530
因此，如您所见，在此文件夹中，我们有y的python文件CNN和数据集。

46
00:03:35,970 --> 00:03:42,180
如您所见，文件不再是c，因为您当然不能在其中创建CSB文件

47
00:03:42,180 --> 00:03:46,370
您的图像会被一些有意义的颜色分开。

48
00:03:46,560 --> 00:03:52,740
因此，除了拥有一个数据集之外，我现在暂时不要打开它，但基本上

49
00:03:52,740 --> 00:03:56,630
此数据集中的所有图片都是猫和狗的图片。

50
00:03:56,970 --> 00:04:02,490
但是此数据集具有特殊的结构，这种结构将使我们的生活更轻松，

51
00:04:02,490 --> 00:04:08,700
CNN模型也更容易，因为让我们仔细考虑一下如何制作训练集

52
00:04:08,760 --> 00:04:15,240
一个测试集的自变量现在是3D阵列中分布的像素，因此

53
00:04:15,240 --> 00:04:20,610
不像以前的数据那样分布，我们旁边有我们的自变量和列

54
00:04:20,610 --> 00:04:25,920
因为我们的数据集不再具有结构，所以最后一列包含因变量

55
00:04:25,920 --> 00:04:31,320
其中行是观察值，列是自变量和因变量

56
00:04:31,320 --> 00:04:32,480
彼此相邻。

57
00:04:32,640 --> 00:04:38,190
然后我们不能在数据集中显式添加因变量，因为它没有多大意义

58
00:04:38,190 --> 00:04:43,510
沿代表图像的三个数组添加此因变量列。

59
00:04:43,650 --> 00:04:48,420
您知道当我们训练机器运行模型时，我们总是需要因变量来具有

60
00:04:48,420 --> 00:04:54,330
理解独立变量中包含的信息之间的相互关系所需的实际结果

61
00:04:54,330 --> 00:04:58,150
变量以及包含在因变量中的实际结果。

62
00:04:58,320 --> 00:05:05,500
但是在这里，由于我们无法在同一张表中添加此依赖生存列，因此如何提取信息

63
00:05:05,500 --> 00:05:06,990
这无价之宝。

64
00:05:07,330 --> 00:05:13,990
好吧，我们有几种解决方案，经典的解决方案是仅包含一个包含我们图像的数据集

65
00:05:13,990 --> 00:05:18,030
分为不同的文件夹，用于训练集的文件夹和用于测试集的文件夹。

66
00:05:18,100 --> 00:05:23,380
然后您便知道了，因为每个图像都有一个名称，即袋子或文件的名称。

67
00:05:23,500 --> 00:05:29,770
好吧，您知道我们能做些什么，那就是第一个解决方案是按类别为每个图像命名

68
00:05:30,070 --> 00:05:32,590
是猫还是狗的图像。

69
00:05:32,840 --> 00:05:36,510
并且例如一个数字来区分所有图像。

70
00:05:36,550 --> 00:05:41,920
因此，这意味着在每个文件夹中，训练集和测试集将得到例如5000张图像

71
00:05:41,920 --> 00:05:48,520
的猫，我们将猫命名为一只猫，三只猫得到四只，五只猫得到五千只，然后道格

72
00:05:48,520 --> 00:05:54,940
一二三四五，直到5000，然后才是解决方案所在。

73
00:05:54,940 --> 00:06:01,960
我们可以编写某种代码从图像文件的名称中提取标签名称Cat或dog

74
00:06:02,170 --> 00:06:08,850
向算法指定此图像是属于Cat类还是属于dog类。

75
00:06:09,100 --> 00:06:14,650
并以某种方式获得因变量矢量，因为我们可以填写此因变量

76
00:06:14,650 --> 00:06:21,780
向量，其中包含我们要从所有图像的图像文件名中提取的标签名称。

77
00:06:22,030 --> 00:06:23,370
所以这是第一个解决方案。

78
00:06:23,380 --> 00:06:27,970
但这不是我们要使用的那个，因为我们有一个更好的一个和一个更有效率的一个

79
00:06:28,510 --> 00:06:35,500
更好的解决方案随附于keris，当然我们使用的是Khaira Scarus，它具有一个了不起的库

80
00:06:35,500 --> 00:06:41,680
深度学习和计算机视觉，当然它包含一些技巧和工具来导入一些图像

81
00:06:42,010 --> 00:06:43,430
以非常有效的方式

82
00:06:43,630 --> 00:06:49,180
这就是我们将使用的解决方案，您将看到您会很高兴使用它，因为基本上

83
00:06:49,180 --> 00:06:56,180
用Cara导入图像，我们要做的就是为数据准备一个特殊的结构

84
00:06:56,180 --> 00:06:56,730
组。

85
00:06:56,830 --> 00:07:00,160
但这是一个非常简单的结构，就像您现在将要看到的那样。

86
00:07:00,160 --> 00:07:06,580
因此，我要做的是打开此数据集，您将了解有关此特殊结构的信息。

87
00:07:06,580 --> 00:07:07,600
所以我们开始。

88
00:07:07,670 --> 00:07:08,710
数据集打开。

89
00:07:09,090 --> 00:07:09,360
好。

90
00:07:09,370 --> 00:07:14,650
因此，该结构的第一支柱是将图像分成两个单独的文件夹。

91
00:07:14,650 --> 00:07:18,720
我们已经说过训练集文件夹和测试文件夹。

92
00:07:18,730 --> 00:07:20,550
好的，但这不是窍门。

93
00:07:20,620 --> 00:07:26,560
记住，我们想要一种简单的方法来区分区分猫的类标签

94
00:07:26,620 --> 00:07:28,770
图像和狗图像。

95
00:07:28,840 --> 00:07:37,090
因此，基本上，我们可以在此处使用的简单技巧是再次使两个不同的文件夹成为一个文件夹

96
00:07:37,090 --> 00:07:39,470
为猫而为狗。

97
00:07:39,610 --> 00:07:45,390
这就是keras如何理解如何区分因变量标签的方式。

98
00:07:45,460 --> 00:07:51,760
无论您的每个图像是狗的图像还是猫的图像，这都是真实的结果，因为

99
00:07:51,760 --> 00:07:55,070
那么如果我们进入该文件夹，例如docs文件夹。

100
00:07:55,270 --> 00:07:59,440
就像您看到的一样，我对狗有一些不同的印象。

101
00:07:59,440 --> 00:08:00,760
这是第一只狗。

102
00:08:00,820 --> 00:08:09,050
这是第二只狗，第三只狗是第四只狗，它很可爱。

103
00:08:09,270 --> 00:08:15,150
好吧，无论如何，我有一些我所知道的图像，因为它们具有Jeep格式，因此可以是任何一种

104
00:08:15,150 --> 00:08:17,010
计算机上的图像数量。

105
00:08:17,010 --> 00:08:21,840
您知道您可以给朋友拍一些照片，然后将这些docs照片替换为这些照片

106
00:08:21,840 --> 00:08:25,490
的朋友，然后您将能够训练可以预测的算法。

107
00:08:25,590 --> 00:08:29,610
您的哪个朋友在图片中，所以做起来会很有趣。

108
00:08:29,610 --> 00:08:32,160
但是请记住，您需要很多图像。

109
00:08:32,160 --> 00:08:34,660
好吧，基本上，我们这里有鸭子的照片。

110
00:08:34,710 --> 00:08:40,020
然后，如果我们返回该文件夹中cats文件夹相同的另一个文件夹，

111
00:08:40,290 --> 00:08:42,300
猫的一些图像。

112
00:08:42,510 --> 00:08:49,290
因此，这是第一只猫，第二只猫，第三只猫等。

113
00:08:49,630 --> 00:08:53,140
因此，该数据集是计算机视觉中非常知名的数据集。

114
00:08:53,140 --> 00:08:59,230
它可以用作您了解的性能基准，以测试您的深度学习模型，从而简单地

115
00:08:59,230 --> 00:09:01,050
看看您是否获得了很好的准确性。

116
00:09:01,270 --> 00:09:03,210
因此，这是一个非常有用的数据集。

117
00:09:03,220 --> 00:09:09,610
因此，此数据集实际上是您可以在Kaggle上找到的整个数据集的子集，因为

118
00:09:09,610 --> 00:09:13,050
原始整个数据集包含25000张图像。

119
00:09:13,060 --> 00:09:16,600
但是这里只是一个子集，因为我们对此兴趣不大。

120
00:09:16,900 --> 00:09:19,290
让我们看看我们有多少张图片。

121
00:09:19,300 --> 00:09:26,950
好吧，它将与上一节中提到的业务问题相同，因为

122
00:09:26,950 --> 00:09:32,620
记得在上一节中，我们有10000个观测值，对应于10000个银行客户

123
00:09:32,770 --> 00:09:38,020
并记得在数据处理部分中，我们将这10000个客户划分为训练集，

124
00:09:38,020 --> 00:09:38,800
测试集。

125
00:09:38,950 --> 00:09:44,450
记住，培训集包含8000个客户，测试集包含2000个客户。

126
00:09:44,620 --> 00:09:48,430
好吧，这里的猫和狗的图像完全一样。

127
00:09:48,430 --> 00:09:50,740
我们总共有10000张图片。

128
00:09:50,740 --> 00:10:00,140
然后，我将8000张狗和猫的图像放入火车中，并将2000张狗和猫的图像放入测试中。

129
00:10:00,360 --> 00:10:10,220
然后在训练集中，我给狗放了4000张图像，为猫放了4000张猫。

130
00:10:10,260 --> 00:10:10,600
好吧。

131
00:10:10,620 --> 00:10:16,440
测试集也是如此，因为它包含2000张猫和狗的图像。

132
00:10:16,590 --> 00:10:24,290
好吧，我们这里有一千张狗的图像，您看到它的数量从四百一十变成了五千。

133
00:10:24,290 --> 00:10:32,420
因此，狗的1000张图像和获取的1000张图像。

134
00:10:32,500 --> 00:10:32,820
好吧。

135
00:10:32,820 --> 00:10:38,960
综上所述，我们在数据集中总共有10000张图像，训练集中有8000张图像，另外2张

136
00:10:38,960 --> 00:10:40,740
测试集中的一千张图片。

137
00:10:40,750 --> 00:10:43,050
因此，这是80％与20％的比例。

138
00:10:43,270 --> 00:10:49,240
然后在训练集中，我们有4000张狗的图像和4000张猫的图像，而在测试中，我们有

139
00:10:49,240 --> 00:10:57,080
1000张狗的图像和1000张猫的图像，基本上现在，我们做了很大一部分数据处理。

140
00:10:57,160 --> 00:11:02,650
我说的是我们在上一个Morell的第一部分中曾经做过的数据处理

141
00:11:02,650 --> 00:11:05,800
因为基本上我们已经导入了数据集。

142
00:11:05,830 --> 00:11:10,810
那么我们不需要编码任何分类数据，因为我们的自变量当然在

143
00:11:10,810 --> 00:11:13,700
以某种方式像素和三个通道。

144
00:11:13,720 --> 00:11:15,950
因此，这里没有分类数据。

145
00:11:16,090 --> 00:11:21,190
因此，我们不需要进行任何编码，然后在下一部分将数据集扩展到训练中

146
00:11:21,190 --> 00:11:22,380
集和测试集。

147
00:11:22,420 --> 00:11:23,680
好吧，这里也是一样。

148
00:11:23,680 --> 00:11:29,140
由于该文件夹的结构，我们的数据集已经被分成测试集和训练

149
00:11:29,140 --> 00:11:29,980
组。

150
00:11:29,980 --> 00:11:31,130
所以这里一切都很好。

151
00:11:31,240 --> 00:11:36,550
最后，我们进行下一部分和最后一部分的特征缩放，因此我们需要应用特征

152
00:11:36,550 --> 00:11:37,170
扫描。

153
00:11:37,300 --> 00:11:38,320
是的，我们愿意。

154
00:11:38,320 --> 00:11:43,590
记住我在农产品节中所说的功能缩放是深度学习中必选的100％

155
00:11:43,600 --> 00:11:45,250
尤其是计算机视觉。

156
00:11:45,250 --> 00:11:52,060
但是您知道，因为此功能扫描部分与整个数据处理部分相关，并且

157
00:11:52,060 --> 00:11:57,400
因为我们不使用此数据处理部分，所以以后我们会照顾以后的扫描

158
00:11:57,400 --> 00:12:01,110
在我们将CNN调整到适合我们的图像之前。

159
00:12:01,360 --> 00:12:07,870
因此，所有这些的结论是，没有一部分数据预处理Parwan数据处理

160
00:12:07,870 --> 00:12:09,220
是手动完成的。

161
00:12:09,340 --> 00:12:14,050
然后，我们只需要进行一些功能缩放和图像增强，以便我们的部署模型

162
00:12:14,050 --> 00:12:16,670
可以尽可能高效地运行。

163
00:12:16,780 --> 00:12:22,210
因此，由于我们要使用这一部分进行一个数据预处理，所以这意味着第一个

164
00:12:22,210 --> 00:12:27,170
我们的CNN模型的一部分将不会进行数据处理，而是直接处理。

165
00:12:27,250 --> 00:12:31,510
这就是令人兴奋的事情，因为数据预处理部分是无聊的部分。

166
00:12:31,540 --> 00:12:39,220
虽然本文的第一部分是构建卷积神经网络。

167
00:12:39,370 --> 00:12:40,320
现在我们开始。

168
00:12:40,420 --> 00:12:41,770
我们准备建造它。

169
00:12:41,920 --> 00:12:43,950
这就是我们接下来要做的。

170
00:12:44,080 --> 00:12:45,650
在那之前，我认为

