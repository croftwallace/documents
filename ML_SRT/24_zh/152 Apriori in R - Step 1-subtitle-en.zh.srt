1
00:00:00,330 --> 00:00:05,670
您好，欢迎您来到我们的艺术指导中心，以下是我们将要实现先验知识的教程

2
00:00:05,670 --> 00:00:11,130
算法，正如您所知，我们将使这个机器学习模型创造一些附加值

3
00:00:11,220 --> 00:00:12,840
在某些特定的业务中。

4
00:00:12,840 --> 00:00:18,180
在这一部分中，此业务问题将与优化杂货店的销售有关

5
00:00:18,410 --> 00:00:23,850
或法国南部的杂货店，您将完全了解先验算法

6
00:00:23,850 --> 00:00:27,940
在优化销售方面将做得很完美。

7
00:00:28,140 --> 00:00:34,130
因为最近有许多商店为机器学习和

8
00:00:34,150 --> 00:00:39,960
尤其是协会规则学习，可以使用它来优化其产品的销售。

9
00:00:39,990 --> 00:00:41,240
以及他们是如何做到的。

10
00:00:41,400 --> 00:00:48,180
好吧，他们只是使用关联规则学习来确切了解产品在商店中的放置位置

11
00:00:48,180 --> 00:00:48,480
。

12
00:00:48,480 --> 00:00:51,360
您知道例如，我会给您一个非常简单的例子。

13
00:00:51,720 --> 00:00:57,190
如果某人购买一些谷物，那么同一个人也很可能也购买一些牛奶。

14
00:00:57,360 --> 00:01:03,090
因此，通过将谷物放在靠近牛奶的位置，商店很可能会将这两种产品放入

15
00:01:03,090 --> 00:01:09,240
即使买家原本打算只购买谷物也可以使用同一篮子，或者我可以给您更笼统的内容

16
00:01:09,240 --> 00:01:12,860
例如，假设某人想要购买特定产品。

17
00:01:12,900 --> 00:01:14,390
我们称它为产品A。

18
00:01:14,700 --> 00:01:20,310
该产品可以很好地与另一个产品B和想要购买该产品的人相关联

19
00:01:20,310 --> 00:01:20,730
产品。

20
00:01:20,760 --> 00:01:21,900
未成年人。

21
00:01:21,900 --> 00:01:26,290
想一想产品与产品B之间的这种良好关联。

22
00:01:26,460 --> 00:01:30,120
好吧，如果您将产品放在产品中并排放置。

23
00:01:30,240 --> 00:01:35,850
好吧，这个关联会突然在买家的脑海中浮现，让您知道买家可以告诉您

24
00:01:35,850 --> 00:01:37,460
这实际上是一个很好的组合。

25
00:01:37,470 --> 00:01:40,430
为什么不为下一次午餐或其他时间尝试这两点呢？

26
00:01:40,620 --> 00:01:45,260
即使买家原本只打算购买产品，也要如此。

27
00:01:45,510 --> 00:01:50,530
Judy好吧，由于产品和产品的位置，这种联想突然出现

28
00:01:50,530 --> 00:01:51,720
彼此相邻。

29
00:01:51,870 --> 00:01:55,560
好了，买方最终购买了两个父母A和B。

30
00:01:55,740 --> 00:02:00,990
这就是我们如何为零售店或杂货店创造附加值的想法。

31
00:02:00,990 --> 00:02:06,510
因此，我们在未来的教程中将为优化销售所做的工作也可以应用于任何其他情况

32
00:02:06,510 --> 00:02:08,850
卖一些不同产品的商店。

33
00:02:08,910 --> 00:02:10,640
您可以想到一个在线商店。

34
00:02:10,740 --> 00:02:14,350
您知道这些建议，买这个的人也买了。

35
00:02:14,490 --> 00:02:19,980
这些建议也基于关联规则，但不仅可以作为结果

36
00:02:19,980 --> 00:02:25,980
推荐系统，例如协作过滤或基于定制的基于项目的协作过滤

37
00:02:26,060 --> 00:02:26,240
。

38
00:02:26,390 --> 00:02:29,040
协会将在学习中发挥作用。

39
00:02:29,340 --> 00:02:35,130
因此，现在让我们制作第一个关联规则和一个算法，该算法是针对此特定模型的先验模型

40
00:02:35,130 --> 00:02:36,860
商店在法国南部。

41
00:02:36,960 --> 00:02:37,960
因此，让我们开始吧。

42
00:02:38,160 --> 00:02:43,700
和往常一样，我们将通过进入秋天的新部件文件夹来设置工作目录

43
00:02:43,700 --> 00:02:49,200
第五部分协会死记硬背的学习，我们从先验算法开始。

44
00:02:49,200 --> 00:02:54,390
因此，这就是我们要设置的秋天，因为我们可以指导您进行市场优化

45
00:02:54,400 --> 00:02:59,630
他已经找到，您可以在此处单击此更多按钮，然后将其设置为工作目录。

46
00:02:59,640 --> 00:03:00,220
好吧。

47
00:03:00,220 --> 00:03:01,490
我们现在在步枪上。

48
00:03:01,560 --> 00:03:08,300
所以我们要做的第一件事是导入数据集，以便数据集在优化时重新标记

49
00:03:08,310 --> 00:03:11,690
因此像往常一样，我们将其称为数据集。

50
00:03:11,790 --> 00:03:16,110
然后，我们当然会在运行时使用它来进行阅读。

51
00:03:16,230 --> 00:03:19,930
现在，我们只需在城市名称中加上引号即可。

52
00:03:20,040 --> 00:03:21,650
所以我们开始。

53
00:03:21,690 --> 00:03:29,790
市场购物篮优化点CSC。

54
00:03:29,820 --> 00:03:34,950
好的，让我们执行一下并解释数据集的含义。

55
00:03:34,950 --> 00:03:35,660
开始了。

56
00:03:35,670 --> 00:03:41,880
他们说很好地输入了它有750个观测值和20个变量。

57
00:03:41,880 --> 00:03:45,070
因此，让我们检查一下并单击此处的数据集。

58
00:03:45,090 --> 00:03:45,410
好吧。

59
00:03:45,420 --> 00:03:46,620
那就是Dasent。

60
00:03:46,620 --> 00:03:54,340
因此，我们在这里看到的第一件事是，此行包含一些产品。

61
00:03:54,360 --> 00:03:59,620
这些产品在这里，当然，这些不是这里的不同产品的标题。

62
00:03:59,640 --> 00:04:07,590
因此，要改善这一点，我们首先要做的是在此处具有等号的情况下添加此Hetter参数

63
00:04:07,590 --> 00:04:14,580
只是以这种方式错误，这表明我们数据集的第一行不包含标题

64
00:04:14,580 --> 00:04:15,880
列。

65
00:04:15,990 --> 00:04:17,870
现在让我们检查一下。

66
00:04:18,150 --> 00:04:19,950
就像这行代码一样执行。

67
00:04:19,950 --> 00:04:20,990
开始了。

68
00:04:21,360 --> 00:04:24,710
让我们关闭它，然后再次单击数据集。

69
00:04:24,930 --> 00:04:25,470
现在我们开始。

70
00:04:25,500 --> 00:04:30,960
我们没有专栏的标题，但您知道这第一个观察不再被视​​为

71
00:04:30,960 --> 00:04:32,430
列标题。

72
00:04:32,440 --> 00:04:34,200
那是真正的观察本身。

73
00:04:34,200 --> 00:04:34,450
好。

74
00:04:34,470 --> 00:04:37,770
现在更好地描述数据集。

75
00:04:37,890 --> 00:04:44,100
因此，正如我告诉您的那样，我们正在为法国南部的一家商店建立先验模型。

76
00:04:44,190 --> 00:04:49,550
因此，我们想找出这次旅行的不同产品的关联规则，以了解

77
00:04:49,550 --> 00:04:55,430
商店的经理可以优化其不同产品的布局以优化销售。

78
00:04:55,660 --> 00:04:55,910
好。

79
00:04:55,900 --> 00:05:01,600
因此，现在首先要说的是，这家商店位于该市最受欢迎的地方之一

80
00:05:01,600 --> 00:05:02,480
法国南部。

81
00:05:02,500 --> 00:05:08,480
所以很多人进入商店，所以你知道这个地方是一个非常欢乐的地方，非常友好

82
00:05:08,470 --> 00:05:12,380
人们喜欢闲逛的地方，彼此放松交谈。

83
00:05:12,400 --> 00:05:18,340
因此，这些人经常来此旅游，因为即使不是出于某种原因，这也是一个地方

84
00:05:18,340 --> 00:05:23,630
认识他们的朋友，因此商店的经理注意到并平均计算出

85
00:05:23,930 --> 00:05:27,750
每个客户每周去一次商店买东西。

86
00:05:27,760 --> 00:05:34,630
因此，这里的数据集包含所有不同客户的七千五百笔交易

87
00:05:34,630 --> 00:05:38,140
在整个一周内购买了一篮子产品。

88
00:05:38,140 --> 00:05:42,960
确实，经理将其作为分析的基础，因为既然每个客户都在平均

89
00:05:43,000 --> 00:05:49,210
每周一次到商店，那么一周内注册的交易就可以代表什么

90
00:05:49,210 --> 00:05:50,570
客户要购买。

91
00:05:50,810 --> 00:05:58,830
因此，基于所有这7500笔交易，我们的机械模型和先验模型将学习

92
00:05:58,830 --> 00:06:03,120
可以理解实际规则的各种不同关联。

93
00:06:03,230 --> 00:06:08,970
例如，如果客户购买了该产品，那么他们很可能会购买另一套产品。

94
00:06:08,990 --> 00:06:13,870
这就是我们要弄清楚的，这就是我们的预读模型将告诉我们的。

95
00:06:14,010 --> 00:06:14,580
好。

96
00:06:14,950 --> 00:06:21,610
因此，这里的每条观察线都对应于购买特定篮子产品的特定客户

97
00:06:21,630 --> 00:06:21,760
。

98
00:06:21,880 --> 00:06:28,750
因此，例如，如果您查看第二行，该行对应于一位购买汉堡肉丸的客户

99
00:06:28,840 --> 00:06:31,570
和鸡蛋在本周的特定时间。

100
00:06:31,810 --> 00:06:36,130
对于与其他客户相对应的所有其他观察结果，也是如此。

101
00:06:36,130 --> 00:06:40,860
或者，也许是第二天或另一天又去商店的同一位客户。

102
00:06:40,900 --> 00:06:42,900
这就是今天的意义。

103
00:06:42,910 --> 00:06:45,180
但这实际上不是集合。

104
00:06:45,190 --> 00:06:49,440
我们将用来训练我们的先验模型。

105
00:06:49,730 --> 00:06:55,380
原因是我们将用来构建Priore模型的软件包

106
00:06:55,380 --> 00:07:00,040
Avril的软件包不会将像这样的数据集作为输入。

107
00:07:00,040 --> 00:07:02,630
正如我们认为要导入一样，它不需要C。

108
00:07:02,650 --> 00:07:09,160
多亏了重做的cxxviii函数，输入所需要的被称为稀疏矩阵。

109
00:07:09,160 --> 00:07:11,100
那么什么是稀疏矩阵。

110
00:07:11,140 --> 00:07:16,990
它实际上是一个在机械中包含很多零的矩阵，您会遇到很多次

111
00:07:17,000 --> 00:07:21,520
稀疏单词对应于大量的零。

112
00:07:21,620 --> 00:07:26,800
因此，稀疏矩阵是包含很少数量的非零值的矩阵。

113
00:07:26,800 --> 00:07:32,960
因此，我们现在要做的就是将此处的数据集转换为稀疏矩阵，您能猜到吗

114
00:07:32,950 --> 00:07:34,010
我们将要做的。

115
00:07:34,300 --> 00:07:39,060
好了，您要做的就是获取此数据集的所有不同产品。

116
00:07:39,400 --> 00:07:44,510
实际上，我已经知道有一百二十种产品，我们将归因于

117
00:07:44,600 --> 00:07:48,090
这120个产品中的每一个都包含一栏。

118
00:07:48,110 --> 00:07:52,370
因此，这意味着我们将获得120列。

119
00:07:52,420 --> 00:07:53,530
例如。

120
00:07:53,800 --> 00:07:59,320
因此，例如，我们必须称呼他们为Shrem，称呼他们为杏仁，称呼为鳄梨，称呼它们。

121
00:07:59,320 --> 00:08:06,400
蔬菜将卡拉奇的能量饮料番茄汁混合到我们拥有的100和20产品中

122
00:08:06,400 --> 00:08:08,790
然后在地块上查看所有产品。

123
00:08:09,040 --> 00:08:14,210
但是在这方面说有一百二十种产品，顺便说一句

124
00:08:14,190 --> 00:08:16,540
商店的二十种产品。

125
00:08:16,570 --> 00:08:21,390
因此，每种产品都会有一个选择，那就是专栏。

126
00:08:21,620 --> 00:08:28,410
然后这些行仍将是对应于每个7500的不同交易

127
00:08:28,510 --> 00:08:32,260
一整周内购买了一篮子产品的客户。

128
00:08:32,260 --> 00:08:38,470
但是，除了拥有他们所购买产品的列表之外，我们还将在这里的120列中提供

129
00:08:38,790 --> 00:08:40,480
零或一。

130
00:08:40,660 --> 00:08:46,340
如果产品在交易期间位于客户的购物篮中，则它将为1，并且

131
00:08:46,350 --> 00:08:49,300
如果产品不在购物篮中，则为零。

132
00:08:49,300 --> 00:08:52,760
例如，让我们在这里带第二个客户。

133
00:08:53,020 --> 00:08:58,440
第二位客户购买了一篮三个产品汉堡肉丸和鸡蛋。

134
00:08:58,630 --> 00:08:59,290
好。

135
00:08:59,290 --> 00:09:05,630
因此，在我们的稀疏矩阵中，我们将有一个汉堡叫它们1个肉丸叫，而1个叫它们。

136
00:09:05,620 --> 00:09:08,360
它们不一定会彼此相邻。

137
00:09:08,410 --> 00:09:14,770
您知道汉堡可以排在第五列，肉丸可以被Neyens称为X可以是12 Scullin

138
00:09:15,050 --> 00:09:20,020
这取决于Avril的软件包将如何制作矩阵，但是我们将为每个矩阵创建一列

139
00:09:20,020 --> 00:09:21,260
这三个产品中的一个。

140
00:09:21,250 --> 00:09:26,380
因此，在这些列中，因为第二个客户购买了一些汉堡肉丸和鸡蛋，

141
00:09:26,380 --> 00:09:31,630
在每个列中都为1，在burbs列中为1或在肉丸列中为1

142
00:09:31,930 --> 00:09:36,760
而X列中的一个和所有其余列的值将为零。

143
00:09:36,860 --> 00:09:42,140
那是因为所有其他产品都不在第二位客户的购物篮中。

144
00:09:42,380 --> 00:09:48,200
因此，您可以猜测，您可以想象我们将有很多零值，甚至更多

145
00:09:48,190 --> 00:09:53,170
考虑到我们有很多客户只购买一种产品的购物篮这一事实，这是正确的。

146
00:09:53,170 --> 00:09:56,400
例如，这里的10号客户购买了一些炸薯条。

147
00:09:56,560 --> 00:10:00,210
这个买了一些饼干，这个买了一些矿泉水。

148
00:10:00,400 --> 00:10:05,300
因此，对于这三位仅购买一种产品的客户，我们将只有一列

149
00:10:05,290 --> 00:10:11,780
包含一个非零值以及所有其他列，这意味着所有119个Collins将包含

150
00:10:11,770 --> 00:10:12,570
零。

151
00:10:12,700 --> 00:10:16,240
因此，您可以看到我们在这个矩阵中将有很多零。

152
00:10:16,300 --> 00:10:22,360
因此，对于那些发现稀疏性的人，我很高兴向您介绍稀疏矩阵，因此

153
00:10:22,450 --> 00:10:25,250
让我们现在建立这个稀疏矩阵。

154
00:10:25,330 --> 00:10:27,260
您将看到这将非常容易。

155
00:10:27,400 --> 00:10:31,120
因此，让我们回到我们的代码，并创建稀疏矩阵。

156
00:10:31,120 --> 00:10:37,710
因此，要创建稀疏矩阵，我们将使用一个程序包，该程序包是Avril的

157
00:10:37,720 --> 00:10:38,350
包。

158
00:10:38,360 --> 00:10:42,390
因此，我们将其安装为重要。

159
00:10:42,670 --> 00:10:49,420
因此，像往常一样，我们将使用功能安装软件包，然后在括号中，我们只需输入

160
00:10:49,720 --> 00:10:54,850
包中带引号的名称，即Avril的包。

161
00:10:55,030 --> 00:10:55,930
好吧。

162
00:10:56,080 --> 00:10:59,690
因此，让我们检查一下是否有它。

163
00:10:59,830 --> 00:11:01,470
好吧，我已经知道了。

164
00:11:01,490 --> 00:11:03,810
它实际上已经在这里并且已经导入。

165
00:11:03,940 --> 00:11:10,090
这就是Avril的软件包，描述中说这是Mining Association规则和

166
00:11:10,100 --> 00:11:11,640
频繁的项目集。

167
00:11:11,820 --> 00:11:16,010
确定，所以我的已经安装，所以我将不执行此行。

168
00:11:16,030 --> 00:11:17,280
我将发表评论。

169
00:11:17,440 --> 00:11:23,380
因此，如果您在列表中没有此处的Avril软件包，则需要选择此行

170
00:11:23,800 --> 00:11:24,670
并执行。

171
00:11:24,760 --> 00:11:27,520
这样就可以毫无问题地安装软件包。

172
00:11:27,740 --> 00:11:31,170
就我而言，我只是要说明一下。

173
00:11:31,420 --> 00:11:36,260
正确，并确保已正确导入规则包。

174
00:11:36,460 --> 00:11:42,050
我们需要在此处的库中添加该行，并在括号中将Avril添加到那里。

175
00:11:42,100 --> 00:11:42,940
完善。

176
00:11:43,060 --> 00:11:47,990
并确保如果您执行整个脚本，Avril的软件包将被导入。

177
00:11:48,220 --> 00:11:51,910
现在我们准备创建稀疏矩阵。

178
00:11:52,000 --> 00:11:58,160
因此，由于我们的数据集在这里没有用，因为我们不会用它来构建和训练打印机

179
00:11:58,150 --> 00:12:05,450
模型，我们将再次调用稀疏矩阵数据集并创建稀疏矩阵

180
00:12:05,470 --> 00:12:13,180
几乎与导入ACSU文件相同，因为与其说在这里写，不如说我们只需要

181
00:12:13,180 --> 00:12:21,040
键入读取点交易读取该交易，然后括号中的内容相同，我们需要

182
00:12:21,040 --> 00:12:23,710
输入CSP文件的名称。

183
00:12:23,710 --> 00:12:27,470
因此，我们将其复制并粘贴到此处。

184
00:12:27,940 --> 00:12:34,810
那是第一个文档，但随后我们需要为此功能指定CHB的分隔符

185
00:12:34,810 --> 00:12:37,140
文件实际上是一个逗号。

186
00:12:37,300 --> 00:12:41,320
因此，我们需要在此处添加引号逗号之外的调用。

187
00:12:41,600 --> 00:12:47,320
为什么我们需要这样做，这是因为您知道如果使用文本编辑器打开它，我们会归档RACF，

188
00:12:47,320 --> 00:12:50,320
会看到不同的产品用逗号分隔。

189
00:12:50,560 --> 00:12:55,540
实际上，我们不必指定分隔符即将到来，因为这是默认设置

190
00:12:55,540 --> 00:12:58,040
归约函数V的分隔符。

191
00:12:58,120 --> 00:13:02,050
但这不是减少动作功能的默认分隔符。

192
00:13:02,090 --> 00:13:04,500
这就是为什么我们需要在这里指定。

193
00:13:04,540 --> 00:13:08,730
这样就出现了set equals，实际上我们可以从这里开始。

194
00:13:08,870 --> 00:13:13,880
但是由于我答应过要给你真实的数据集，所以我在数据中故意添加了真实性

195
00:13:13,880 --> 00:13:14,340
套。

196
00:13:14,410 --> 00:13:21,430
这个现实是关于数据中存在一些异常，而这些异常实际上是一些重复项

197
00:13:21,440 --> 00:13:21,590
。

198
00:13:21,670 --> 00:13:25,300
确实，当该经理注册所有不同的交易时。

199
00:13:25,300 --> 00:13:30,920
好吧，他可能很可能会犯一些人为的错误，将一些重复项放入数据中。

200
00:13:31,030 --> 00:13:33,230
因此，例如，如果我们返回到数据集。

201
00:13:33,280 --> 00:13:37,550
因此，重要的是整个数据，这就是他对读数功能的看法。

202
00:13:37,570 --> 00:13:44,290
因此，例如，当注册了第一位30位客户的交易时，可能会犯一些错误

203
00:13:44,290 --> 00:13:51,110
例如，在这里像奶油一样放两次，并训练先验算法，我们不需要

204
00:13:51,110 --> 00:13:51,860
重复。

205
00:13:52,000 --> 00:13:55,840
因此，实际上有一个很好的方法来处理这些重复项。

206
00:13:55,850 --> 00:14:00,360
这实际上非常简单，因为我们只需要添加一个附加参数即可。

207
00:14:00,550 --> 00:14:07,690
如果我们按一下这里的读出交易功能，您会看到我们重复的结尾

208
00:14:07,750 --> 00:14:08,440
论点。

209
00:14:08,710 --> 00:14:14,980
如您所见，这是一个逻辑值，用于指定是否应从事务中删除重复的项目

210
00:14:14,980 --> 00:14:15,240
。

211
00:14:15,250 --> 00:14:21,290
因此，由于先验算法是在交易数据集上训练的，因此它们应该没有重复项

212
00:14:21,280 --> 00:14:22,090
价值观。

213
00:14:22,100 --> 00:14:30,520
我们需要添加此参数，或者不要重复并将其设置为true。

214
00:14:30,730 --> 00:14:34,440
并且这将删除每个事务中的所有重复项。

215
00:14:34,450 --> 00:14:39,290
也许您的数据集不会有任何重复，但是在数据集中出现一些异常是很常见的

216
00:14:39,360 --> 00:14:41,030
例如一些重复项。

217
00:14:41,180 --> 00:14:42,480
但是在这里我们会没事的。

218
00:14:42,490 --> 00:14:45,590
感谢我们结束封锁论据。

219
00:14:45,620 --> 00:14:50,390
好的，现在我们已经准备好创建稀疏矩阵。

220
00:14:50,470 --> 00:14:54,770
因此，让我们执行此行，然后开始。

221
00:14:55,000 --> 00:14:55,580
好吧。

222
00:14:55,720 --> 00:14:58,160
因此，现在创建了稀疏矩阵。

223
00:14:58,360 --> 00:15:03,110
不幸的是，我们无法对其进行查看，因为您可以看到我是否点击这些天。

224
00:15:03,150 --> 00:15:06,060
新的数据集稀疏矩阵没有出现在这里。

225
00:15:06,060 --> 00:15:12,910
那实际上是旧的，所以我们可以关闭它，但实际上我们可以获得有关此稀疏的一些信息

226
00:15:12,900 --> 00:15:13,610
矩阵。

227
00:15:13,720 --> 00:15:18,720
但是在获得所有这些详细信息之前，我们可以看到我们已经有了一些信息

228
00:15:18,900 --> 00:15:20,520
关于复制品本身。

229
00:15:20,740 --> 00:15:26,310
当执行此行以使用减少部分功能创建稀疏矩阵时，包括

230
00:15:26,360 --> 00:15:31,410
我们的重复参数结尾，您将自动获得此交易的消息分配

231
00:15:31,410 --> 00:15:34,070
重复，您将看到我们有1 5。

232
00:15:34,120 --> 00:15:38,190
这意味着有五个事务包含一个重复项。

233
00:15:38,320 --> 00:15:45,240
例如，如果您的数据集中有一些重复的重复项，那么任何事务中都会出现两次

234
00:15:45,250 --> 00:15:45,410
。

235
00:15:45,580 --> 00:15:50,120
好吧，您将在这里拥有两个，并且您将在这里拥有一式三份的数量。

236
00:15:50,160 --> 00:15:53,390
这样就可以给出重复交易的分布。

237
00:15:53,400 --> 00:15:55,010
而且无论如何现在它们已被删除。

238
00:15:55,170 --> 00:16:02,270
因此，我们实际上可以获取有关稀疏矩阵的更多详细信息并获取此信息。

239
00:16:02,390 --> 00:16:07,390
正如我们已经做过很多次一样，在需要使用摘要功能之前。

240
00:16:07,570 --> 00:16:08,560
总结一下。

241
00:16:08,740 --> 00:16:11,060
在这里，我们输入数据集。

242
00:16:11,110 --> 00:16:11,430
好吧。

243
00:16:11,430 --> 00:16:16,110
这将为我们提供有关稀疏矩阵的信息，因此让我们执行此行。

244
00:16:16,120 --> 00:16:17,290
现在我们开始。

245
00:16:17,880 --> 00:16:18,910
那么我们在这里看到什么。

246
00:16:18,900 --> 00:16:26,260
首先，我们提醒该数据集包含事务，因为我有一个稀疏格式的矩阵，因此

247
00:16:26,250 --> 00:16:32,610
确切地讲，它是一个稀疏矩阵，我们可以看到，我们有751个行

248
00:16:32,760 --> 00:16:40,120
我们有119列，我们可以看到在稀疏矩阵中密度为0.03

249
00:16:40,120 --> 00:16:40,950
那是什么意思。

250
00:16:40,990 --> 00:16:46,610
这意味着非零值的比例为0.03。

251
00:16:46,770 --> 00:16:50,950
我们有3％的非零值和97％的0值。

252
00:16:51,160 --> 00:16:53,520
好，那么我们有了最多的RIKOON物品。

253
00:16:53,520 --> 00:16:56,580
因此，购买最多的物品是矿泉水。

254
00:16:56,740 --> 00:17:01,690
是的，在法国南部可能很热，喝一瓶水是法国的优良传统

255
00:17:01,890 --> 00:17:02,840
在用餐时。

256
00:17:03,120 --> 00:17:08,520
好吧，法国人非常喜欢鸡蛋，他们也喜欢意大利面条法式炸薯条巧克力，仅此而已

257
00:17:08,530 --> 00:17:09,640
其他产品。

258
00:17:09,760 --> 00:17:16,440
然后我们有一些关于所有7500篮筐分布的有趣信息

259
00:17:16,470 --> 00:17:17,340
交易。

260
00:17:17,350 --> 00:17:27,660
因此，举例来说，这与1754相关联，意味着有1754个篮子仅包含一个

261
00:17:27,660 --> 00:17:35,760
产品，然后我们有1358个包含两个产品的篮子1044个包含三个产品的篮子

262
00:17:35,810 --> 00:17:36,760
等等。

263
00:17:37,170 --> 00:17:42,370
并且我们还具有最小值与最大值的五分位数分布。

264
00:17:42,450 --> 00:17:47,580
因此，最小值当然是一个产品的篮子，最大值是一个20产品的篮子

265
00:17:48,010 --> 00:17:54,220
通常，人们去商店时会在篮子里放四种产品。

266
00:17:54,210 --> 00:17:54,520
好吧。

267
00:17:54,530 --> 00:17:56,450
因此，这是有趣的信息。

268
00:17:56,490 --> 00:18:00,280
但是，当然，我们以后会得到一些更有趣的信息。

269
00:18:00,420 --> 00:18:04,640
谈到这些更有趣的信息，我们现在已经可以拥有一个。

270
00:18:04,810 --> 00:18:10,140
它实际上将是视觉信息，因为我们将绘制不同频率的频率图

271
00:18:10,140 --> 00:18:14,130
整个星期内商店中不同客户购买的商品。

272
00:18:14,400 --> 00:18:20,580
因此，要轻松获得此插件，我们可以使用Avril软件包中的一项功能

273
00:18:20,670 --> 00:18:27,210
频率图函数，在这个函数中，我们只需要放置两个参数即可

274
00:18:27,370 --> 00:18:28,290
数据集。

275
00:18:28,300 --> 00:18:29,970
这就是稀疏矩阵。

276
00:18:30,010 --> 00:18:32,710
那是第一个论点，第二个论点是强硬的。

277
00:18:32,760 --> 00:18:38,260
这就是您想要在该频率图中获得的最坚固产品的数量。

278
00:18:38,380 --> 00:18:47,460
因此，例如，如果我拨打100个电话，我将获得法国客户购买次数最多的100个产品

279
00:18:47,460 --> 00:18:48,440
在这家法国商店。

280
00:18:48,580 --> 00:18:49,810
因此，让我们检查一下。

281
00:18:49,850 --> 00:18:52,410
我们将执行此行。

282
00:18:52,410 --> 00:18:53,130
开始了。

283
00:18:53,140 --> 00:18:54,070
这就是插件。

284
00:18:54,070 --> 00:18:58,360
不用担心，我会放大它，以便我们可以更好地看到产品。

285
00:18:58,620 --> 00:18:59,460
现在我们开始。

286
00:18:59,670 --> 00:19:04,260
因此，这是客户购买最多的前100种产品。

287
00:19:04,260 --> 00:19:09,220
因此，这很有意思，如果您想减少本图中的产品数量，您可以看一下

288
00:19:09,220 --> 00:19:15,870
前10名，您实际上将获得客户购买的前10种产品，这当然是

289
00:19:15,880 --> 00:19:17,420
相同的前10个产品。

290
00:19:17,590 --> 00:19:17,860
好。

291
00:19:17,860 --> 00:19:21,290
因此，该图实际上对我们来说很有趣。

292
00:19:21,390 --> 00:19:27,790
接下来会发生什么，因为我们将不得不根据Priory算法为支撑选择一个值

293
00:19:27,780 --> 00:19:34,840
本身，我们将能够实际使用该图来查看产品的不同支持以

294
00:19:34,840 --> 00:19:37,440
选择一个好的支持价值。

295
00:19:37,470 --> 00:19:39,950
这就是我们接下来的教程中要做的。

296
00:19:39,950 --> 00:19:46,170
我们将开始在数据集上训练先验模型，该模型将成为稀疏矩阵

297
00:19:46,170 --> 00:19:47,560
我们刚刚建造的这里

298
00:19:47,760 --> 00:19:50,570
因此，我期待与您建立先验模型。

299
00:19:50,740 --> 00:19:52,960
在那之前享受机器学习

