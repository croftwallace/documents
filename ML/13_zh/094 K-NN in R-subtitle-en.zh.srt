1
00:00:00,420 --> 00:00:06,750
您好，欢迎来到Tauriel，今天我们将实施K最近邻分类器

2
00:00:06,830 --> 00:00:07,520
在我们的。

3
00:00:07,710 --> 00:00:09,300
现在开始吧。

4
00:00:09,300 --> 00:00:11,790
我们要做的第一件事是将其设置为工作目录。

5
00:00:11,970 --> 00:00:17,490
所以现在我在桌面上，我们将去机器学习文件夹，第3部分分类

6
00:00:17,790 --> 00:00:20,460
然后是 最近的邻居。

7
00:00:20,460 --> 00:00:24,660
好的，这是完整的。我们要设置为工作目录吗，请确保您具有此社交网站

8
00:00:24,660 --> 00:00:26,400
网络并查看文件。

9
00:00:26,610 --> 00:00:31,290
如果是这种情况，您准备单击此处的更多按钮以将文件夹设置为工作文件夹。

10
00:00:31,290 --> 00:00:32,520
目录。

11
00:00:32,520 --> 00:00:33,060
开始了。

12
00:00:33,060 --> 00:00:33,780
完成了

13
00:00:33,990 --> 00:00:40,890
现在，我们将使用分类模板来提高效率并生成所有结果

14
00:00:40,980 --> 00:00:41,990
在手电筒中。

15
00:00:42,300 --> 00:00:47,430
因此，我将选择从这里到顶部的所有内容。

16
00:00:47,430 --> 00:00:52,640
在那里，您将其复制并粘贴到此处。

17
00:00:52,830 --> 00:00:53,370
对。

18
00:00:53,550 --> 00:00:55,930
现在，我们需要更改一些事情。

19
00:00:55,980 --> 00:01:02,700
首先，我们需要在此处创建分类，我们只需要更改图中的地名即可

20
00:01:02,700 --> 00:01:04,810
通过培训得出测试结果。

21
00:01:04,810 --> 00:01:07,210
让我们现在就这样做，这样我们就不会忘记。

22
00:01:07,860 --> 00:01:09,490
我要答复，因为你在。

23
00:01:09,570 --> 00:01:10,610
这样就可以了

24
00:01:10,920 --> 00:01:19,050
因此，我们只是在执行此操作以指定我们正在计划的算法以及此处的分类器

25
00:01:19,350 --> 00:01:22,970
被K代替，然后向右。

26
00:01:23,010 --> 00:01:27,750
现在，我们只需要做的就是创建分类器。

27
00:01:28,050 --> 00:01:31,570
但是首先让我们选择并执行预处理步骤。

28
00:01:31,620 --> 00:01:38,710
所以我只需要跟踪从这里开始的所有内容，然后按Command Control到加号以及Enter

29
00:01:38,730 --> 00:01:41,490
执行完成。

30
00:01:41,520 --> 00:01:43,860
好的，我们有数据集。

31
00:01:43,860 --> 00:01:44,670
我们可以看看。

32
00:01:44,730 --> 00:01:46,130
那就是我们的数据集。

33
00:01:46,350 --> 00:01:51,600
我们的训练集和测试集都得到了很好的扩展。

34
00:01:51,820 --> 00:01:52,210
好的。

35
00:01:52,220 --> 00:01:59,250
提醒一下，数据集包含有关社交网络中用户的信息

36
00:01:59,250 --> 00:02:06,240
有一个商业客户，这是一家汽车公司，该公司在社交网络和社交网络上投放广告

37
00:02:06,240 --> 00:02:13,070
不仅收集了诸如这些使用者的年龄和估计工资之类的饮食形式，还收集了

38
00:02:13,080 --> 00:02:14,750
得到答案。

39
00:02:14,760 --> 00:02:23,550
如果用户未购买汽车产品，这些用户对广告的响应为零，而用户对产品的响应为零

40
00:02:23,640 --> 00:02:25,520
如果用户购买了产品。

41
00:02:25,530 --> 00:02:32,310
因此，您知道这是一款非常酷的豪华SUV，价格低得离谱。

42
00:02:32,340 --> 00:02:38,070
所以很多人在看到广告时说，让我们这样做，让我们得到汽车，我们可以看到

43
00:02:38,070 --> 00:02:39,050
很多买家。

44
00:02:39,240 --> 00:02:42,730
是的，正如您所看到的，它一定是一辆非常酷的汽车且价格便宜。

45
00:02:42,900 --> 00:02:48,260
现在让我们回到KNM并创建我们的分类器。

46
00:02:48,390 --> 00:02:56,540
因此，先进行分类器AK，然后进行气化器并进行创建，我们将首先导入正确的库

47
00:02:56,550 --> 00:03:00,150
为此，我们需要一个称为类的库。

48
00:03:00,420 --> 00:03:03,540
因此，让我们这样做。

49
00:03:03,540 --> 00:03:09,960
因此，如果任何时候该类库不在您的软件包列表中，则需要使用此库进行安装

50
00:03:09,960 --> 00:03:15,470
命令安装该软件包，并在括号中并用引号将类的名称命名为class

51
00:03:15,470 --> 00:03:15,870
。

52
00:03:16,200 --> 00:03:21,720
但我认为您可能默认情况下具有它，因此，如果不是这种情况，请使用

53
00:03:21,720 --> 00:03:25,300
里面的类，然后执行，它将安装它。

54
00:03:25,330 --> 00:03:34,080
但是，在这里，我们将要编写一个库并发明该类，该类会自动选择

55
00:03:34,080 --> 00:03:34,410
类。

56
00:03:34,410 --> 00:03:38,070
您会看到现在没有选择类包。

57
00:03:38,340 --> 00:03:42,790
一旦执行，它将自动选择它。

58
00:03:42,800 --> 00:03:43,480
好吧。

59
00:03:43,710 --> 00:03:52,470
现在，我们将做一些不同的事情，因为通常您会知道我们创建或分类

60
00:03:52,470 --> 00:03:58,500
在这里，然后我们使用我们应用的这个预测函数来创建预测y传播的向量

61
00:03:58,500 --> 00:04:02,240
在我们的分类器和测试集中的新观察结果上。

62
00:04:02,280 --> 00:04:09,090
但是在这里，就像我们要一次完成这两个步骤一样，因为我们将直接进行操作。

63
00:04:09,090 --> 00:04:20,510
实际上，我们将删除此行，实际上将替换不匹配的K和

64
00:04:20,520 --> 00:04:24,060
训练集和预测

65
00:04:26,790 --> 00:04:35,850
测试集的结果是因为我们将要适合的所有测试集并预测是否

66
00:04:35,850 --> 00:04:39,030
是或否，是我们测试集的用户。

67
00:04:39,080 --> 00:04:39,800
是。

68
00:04:40,020 --> 00:04:44,550
所以您将了解为什么我们要直接创建我们的预测向量y在这里创建

69
00:04:44,550 --> 00:04:45,530
。

70
00:04:45,570 --> 00:04:53,040
然后您知道我们必须先将您的等值分类为V.M. 或在这里进行逻辑回归

71
00:04:53,280 --> 00:04:55,830
这将直接是激进分子。

72
00:04:55,920 --> 00:05:02,400
并且因为实际上此k n n函数将返回测试和观察的预测

73
00:05:02,410 --> 00:05:02,860
。

74
00:05:03,300 --> 00:05:07,340
好，现在让我们看一下这个K，然后函数，您将得到它。

75
00:05:07,650 --> 00:05:15,140
所以按1 ok，邻居分类也可以。首先输入参数。

76
00:05:15,270 --> 00:05:17,680
第一个论点是火车。

77
00:05:17,760 --> 00:05:21,560
因此，您可以猜测乘火车意味着训练集。

78
00:05:21,660 --> 00:05:25,470
因此，在这里我们需要指定训练集是什么。

79
00:05:25,540 --> 00:05:32,740
实际上，由于我们将其称为火车组，所以它是火车，所以这里的火车可以转弯。

80
00:05:33,000 --> 00:05:39,810
但是，如您所见，训练集包含自变量和因变量

81
00:05:39,810 --> 00:05:40,070
。

82
00:05:40,140 --> 00:05:43,230
而且我们只需要取自变量。

83
00:05:43,230 --> 00:05:47,490
我们想在这里将该隐变量包括在该隐函数中。

84
00:05:47,490 --> 00:05:49,930
因此，这里我们只需要采用前两列。

85
00:05:50,010 --> 00:05:56,400
因此，我们将在此处添加一个支架，然后再进行操作，因为在该操作的左侧，所有行

86
00:05:56,400 --> 00:06:02,160
我要接受所有观察结果，而不是要提出的权利是我要包括的列

87
00:06:02,280 --> 00:06:03,360
在训练集中。

88
00:06:03,630 --> 00:06:06,050
因此，除了最后一列之外，所有列均如此。

89
00:06:06,150 --> 00:06:13,240
所以我要在这里减去三，这意味着我要删除培训中心的最后一列

90
00:06:13,240 --> 00:06:13,990
。

91
00:06:14,000 --> 00:06:14,680
好吧。

92
00:06:14,850 --> 00:06:18,030
这样便完成了，这是我们必须在这里导入预训练的内容。

93
00:06:18,140 --> 00:06:24,840
所以train是您的训练集，但是没有因变量，然后来，然后添加第二个

94
00:06:24,840 --> 00:06:25,410
论点。

95
00:06:25,590 --> 00:06:27,450
因此，第二个参数是测试。

96
00:06:27,690 --> 00:06:33,690
因此，您可以猜测，相同的测试当然等于测试集。

97
00:06:33,710 --> 00:06:34,160
对。

98
00:06:34,170 --> 00:06:40,260
测试集，然后再进行相同的训练，我们将删除依赖的Roybal，因为我们

99
00:06:40,260 --> 00:06:44,430
假设不知道结果，我们想预测测试的结果。

100
00:06:44,430 --> 00:06:45,940
因此，无论如何，我们需要将其删除。

101
00:06:46,200 --> 00:06:51,870
因此，接上所有的行，减去三行以删除最后一列。

102
00:06:52,560 --> 00:06:55,360
好，所以我们有趋势集和测试集。

103
00:06:55,440 --> 00:06:57,050
现在，下一个参数是什么。

104
00:06:57,090 --> 00:07:02,260
好，下一个参数是车削集真实分类的C L因子。

105
00:07:02,280 --> 00:07:05,340
因此，您可以猜测会是什么。

106
00:07:05,920 --> 00:07:06,750
好吧，让我们来看看。

107
00:07:06,840 --> 00:07:10,710
您认为C L等于会是什么。

108
00:07:11,100 --> 00:07:17,900
好吧，您知道要训练一个分类器，该类确实需要确定独立变量，但是

109
00:07:17,910 --> 00:07:24,300
它还需要具有该因变量，因为它需要具有您知道的结果

110
00:07:24,300 --> 00:07:30,420
自变量信息与所包含信息之间的相关性

111
00:07:30,420 --> 00:07:31,620
在因变量中。

112
00:07:31,710 --> 00:07:37,470
所以在这里，因为我们只有关于自变量的信息，所以我们还需要将其包含在某处

113
00:07:37,610 --> 00:07:40,800
因变量的信息，这就是我们在此处得到的信息。

114
00:07:40,800 --> 00:07:44,590
这就是趋势真正分类的C-L So因素。

115
00:07:44,640 --> 00:07:47,040
存在分类因变量。

116
00:07:47,310 --> 00:07:50,630
因此，让我们这样做以实际获取此向量。

117
00:07:50,630 --> 00:07:54,120
如您所见，这是训练集的最后一列。

118
00:07:54,120 --> 00:08:00,400
因此，它将采用所有观测值的所有直线，然后是一到三个的训练。

119
00:08:00,420 --> 00:08:03,920
因此，每个列的第三个索引都被追逐。

120
00:08:03,930 --> 00:08:06,530
所以让我们坐火车

121
00:08:10,230 --> 00:08:17,790
中括号，然后是三个，因为我们想要的列被三个索引。

122
00:08:17,790 --> 00:08:23,300
好吧，这是第三个参数，然后我们还有一个参数，即邻居数

123
00:08:23,300 --> 00:08:23,680
。

124
00:08:23,820 --> 00:08:25,340
因此，让我们添加这个。

125
00:08:25,380 --> 00:08:28,910
所以记得在野牛，我们带了五个邻居。

126
00:08:28,980 --> 00:08:30,510
这实际上是默认参数。

127
00:08:30,510 --> 00:08:35,810
所以在这里，我们将采用相同的方法，使我们可以比较在Python上获得的结果

128
00:08:35,820 --> 00:08:36,510
和我们的。

129
00:08:36,720 --> 00:08:38,160
因此这将很有趣。

130
00:08:38,340 --> 00:08:41,720
假设K等于5个邻居。

131
00:08:42,120 --> 00:08:42,570
好吧。

132
00:08:42,580 --> 00:08:44,150
现在我们有了所需的一切。

133
00:08:44,220 --> 00:08:46,210
我们可以选择这个。

134
00:08:46,410 --> 00:08:48,460
这就是为什么阅读一切都很好的原因。

135
00:08:48,690 --> 00:08:51,370
现在让我们来看看白面包。

136
00:08:51,900 --> 00:08:57,000
我们可以在这里看看为什么KRAD并按下为什么将其放入控制台并按Enter键

137
00:08:57,000 --> 00:08:57,460
在它。

138
00:08:57,750 --> 00:08:59,640
这里是测试的所有预测。

139
00:08:59,640 --> 00:09:02,740
因此，请记住该测试包含100个观察值。

140
00:09:02,740 --> 00:09:10,140
在这里，我们有一百个预测，对应于与这些人相同的观察结果。

141
00:09:10,140 --> 00:09:14,970
例如，让我们对第一个用户进行第一次观察。

142
00:09:14,970 --> 00:09:18,590
因此，让我们以一二三四五为例。

143
00:09:18,600 --> 00:09:26,400
因此，这五个第一用户中的五个第一用户实际上并没有购买此产品，因为per chaced变量

144
00:09:26,490 --> 00:09:28,380
在这里等于零，这就是事实。

145
00:09:28,380 --> 00:09:30,960
那就是现实中实际发生的事情。

146
00:09:30,960 --> 00:09:39,000
我们的预测说的是1 2 3 4 5 5 0，所以对于我们的用户来说，正确的预测是5。

147
00:09:39,150 --> 00:09:40,250
好的，完美。

148
00:09:40,440 --> 00:09:49,650
然后我们实际上有4个，分别是6 7 8和9个用户，但是可以。

149
00:09:49,890 --> 00:09:55,600
对于6 1 7 1年级来说也是如此，正确的预测81以及正确的预测。

150
00:09:55,620 --> 00:09:59,490
但是分类您在这里犯了一个小错误，这很好。

151
00:09:59,490 --> 00:10:04,120
看起来大多数时候它都在做出一些正确的预测，我们将检查一下

152
00:10:04,140 --> 00:10:05,480
混乱矩阵。

153
00:10:05,490 --> 00:10:07,190
那会更快。

154
00:10:07,540 --> 00:10:11,340
只是您知道要了解什么是白色印刷。

155
00:10:11,340 --> 00:10:12,660
但是我想你明白了。

156
00:10:12,930 --> 00:10:20,980
所以在这里我们就是这样，在这里执行C.M. 我们可以在控制台中看一下

157
00:10:21,280 --> 00:10:23,130
那就是预测。

158
00:10:23,140 --> 00:10:23,550
好。

159
00:10:23,560 --> 00:10:28,940
因此，我们有6加5个错误的预测，分别是11和预测。

160
00:10:29,020 --> 00:10:30,610
因此，这还不错。

161
00:10:30,620 --> 00:10:36,940
现在，我们最感兴趣的是预测区域的行为方式，尤其是

162
00:10:36,940 --> 00:10:41,930
预测边界以查看它是直线还是其他。

163
00:10:41,980 --> 00:10:47,470
实际上，您将看到K然后是一个非线性分类器，因此我们将得到一些

164
00:10:47,470 --> 00:10:50,580
与逻辑回归不同。

165
00:10:50,620 --> 00:10:58,060
所以我知道它应该是适用于每个分类器的模板，但佳能和分类器

166
00:10:58,210 --> 00:11:04,510
将是唯一需要分类的分类，除了我的标题外，我们还需要在模板中进行一些更改

167
00:11:04,510 --> 00:11:05,320
。

168
00:11:05,320 --> 00:11:11,230
正是由于这种结构，我们在这里更改了所有分类，因为我们首先拥有

169
00:11:12,730 --> 00:11:18,070
我们在此处创建或分类的部分，您知道对等分类，然后我们使用

170
00:11:18,070 --> 00:11:18,940
功能。

171
00:11:18,940 --> 00:11:25,810
然后在另一部分中，使用在上一节中构建的分类器创建广泛的

172
00:11:25,820 --> 00:11:26,100
。

173
00:11:26,350 --> 00:11:32,440
但是在这里，因为我们这样做了，所以在这里，因为我们同时做这两个，所以我们只需要改变一点

174
00:11:32,440 --> 00:11:34,130
模板中的内容。

175
00:11:34,210 --> 00:11:35,020
你也可以

176
00:11:35,080 --> 00:11:36,350
你能猜出这是什么。

177
00:11:36,580 --> 00:11:43,660
好的，实际上是这张幻灯片中的内容，因为如您所见，我们正在使用它来预测功能

178
00:11:44,020 --> 00:11:45,490
在我们的分类器上。

179
00:11:45,570 --> 00:11:51,690
但是在这里，因为我们没有与白色预测向量分开创建分类器。

180
00:11:52,120 --> 00:11:55,900
嗯，这意味着该产品类别在这里并不意味着任何东西。

181
00:11:55,900 --> 00:12:01,800
因此，实际上，我们要做的就是简单地替换此预测分类新数据

182
00:12:02,320 --> 00:12:09,410
在这里由此代码设置，因为这实际上是为了预测创建分类器所需的功能

183
00:12:09,410 --> 00:12:13,350
并同时进行预测，因此此处无法预测功能。

184
00:12:13,360 --> 00:12:18,730
因此，我们只需要做的就是拿这把Kamensky。

185
00:12:19,060 --> 00:12:24,760
在这里，您知道，因为这是网格中所有重要点的预测，因此我们需要更改

186
00:12:24,760 --> 00:12:24,990
这个。

187
00:12:25,000 --> 00:12:30,510
新数据等于测试集，因此该睾丸由网格集设置。

188
00:12:30,640 --> 00:12:37,640
因此，基本上将非常简单，我们将在此处删除此预测函数并将其粘贴。

189
00:12:37,660 --> 00:12:47,320
在这里，我们将用网格集替换测试集，因为我们想预测那些假想的

190
00:12:47,320 --> 00:12:54,430
我们想象为社交网络的虚构用户的像素点将根据是或否购买SUV

191
00:12:54,430 --> 00:12:59,170
他们的坐标和图表，即他们的年龄和估计的薪水。

192
00:12:59,260 --> 00:13:04,690
然后，一旦完成预测，它将以适当的绿色着色。

193
00:13:04,720 --> 00:13:10,480
如果预计这个虚构的用户像素点将购买SUV，而如果预测不购买，则为红色

194
00:13:10,490 --> 00:13:10,580
。

195
00:13:11,380 --> 00:13:12,850
这就是我们所需要的。

196
00:13:12,850 --> 00:13:22,360
因此，我们也将选择它并将其粘贴到此处以进行测试。

197
00:13:22,360 --> 00:13:24,230
当然是一样的。

198
00:13:25,390 --> 00:13:26,210
现在我们开始。

199
00:13:26,440 --> 00:13:29,360
然后我们都很好地绘制了结果。

200
00:13:29,470 --> 00:13:34,620
因此，让我们执行此操作，我们将选择它，然后看看我们获得了什么。

201
00:13:34,660 --> 00:13:38,710
命令和控制加实体执行图形。

202
00:13:38,710 --> 00:13:39,460
情节来了。

203
00:13:39,460 --> 00:13:46,150
您将看到我该如何管理才能将未购买的用户分类为两类

204
00:13:46,150 --> 00:13:47,620
SUV和购买它的人。

205
00:13:47,640 --> 00:13:48,490
现在我们开始。

206
00:13:48,640 --> 00:13:52,000
该图是此处的预测边界。

207
00:13:52,060 --> 00:13:57,460
所以您会看到很多不规则之处，但这是因为K和模型的工作方式

208
00:13:57,460 --> 00:14:03,780
因为每次都使用五个最接近的邻居作为预测边界。

209
00:14:03,790 --> 00:14:05,720
这是两个预测​​区域。

210
00:14:05,730 --> 00:14:11,090
红色点是绿色，这些点是绿色之一，这里的真实观察点是数据的真实用户

211
00:14:11,100 --> 00:14:13,120
设置以及当天的实际结果。

212
00:14:13,130 --> 00:14:17,850
但是是的，如果它是绿色，则不，他们不会购买它是红色的。

213
00:14:18,490 --> 00:14:24,040
因此我们可以看到我们的大多数预测都是正确的，因为所有的红点都在红色区域

214
00:14:24,040 --> 00:14:26,640
并且大多数绿点都在绿色区域中。

215
00:14:26,860 --> 00:14:34,150
我们还看到，在对Cana进行分类时，Canan可以更好地完成分类

216
00:14:34,150 --> 00:14:40,300
Logistic回归可以正确分类，因为它是一条直线，并且一些绿点是

217
00:14:40,300 --> 00:14:42,820
落在红色区域。

218
00:14:42,820 --> 00:14:45,410
因此，这是一项更好的工作。

219
00:14:45,580 --> 00:14:50,950
而所有年龄都在平均水平左右并且估计工资低于平均水平的用户

220
00:14:50,950 --> 00:14:52,910
分类为绿色区域。

221
00:14:53,020 --> 00:14:53,680
很好

222
00:14:53,680 --> 00:14:54,480
很好。

223
00:14:54,580 --> 00:15:00,400
但是，除非我们在测试集上找到结果，否则我们不要尖叫胜利。

224
00:15:00,400 --> 00:15:04,810
是一个训练场，而拐杖和转移是建立在训练的基础上的，说我们可能会得到不同的结果

225
00:15:04,810 --> 00:15:05,470
从那个集合。

226
00:15:05,470 --> 00:15:06,530
让我们来看看。

227
00:15:06,560 --> 00:15:13,790
我们将选择此选项，以准备执行测试集结果。

228
00:15:15,220 --> 00:15:16,550
这些都是很好的结果。

229
00:15:16,570 --> 00:15:21,310
大部分红色点位于红色区域中，大多数绿色点位于绿色区域中，且

230
00:15:21,310 --> 00:15:25,820
当然，我们这里有一些不正确的预测，例如这两个家伙。

231
00:15:25,900 --> 00:15:27,420
这两个家伙在这里。

232
00:15:27,640 --> 00:15:29,000
在这里看起来非常好。

233
00:15:29,290 --> 00:15:33,050
我们已经做出了不错的预测区域。

234
00:15:33,060 --> 00:15:33,450
好。

235
00:15:33,450 --> 00:15:35,550
这就是本教程的内容。

236
00:15:35,550 --> 00:15:39,110
我希望您非常喜欢发现这种新型课程。

237
00:15:39,220 --> 00:15:43,560
我们将在下一部分中发现新的分类器。

238
00:15:43,570 --> 00:15:45,120
我等不及要向您展示。

239
00:15:45,130 --> 00:15:47,040
在此之前，请享受机器学习。

