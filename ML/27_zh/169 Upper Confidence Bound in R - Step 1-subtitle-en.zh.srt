1
00:00:00,330 --> 00:00:02,650
您好，欢迎来到本美术教程。

2
00:00:02,670 --> 00:00:08,010
因此，今天我们开始了机器学习的一个新分支，即强化学习，这就是

3
00:00:08,010 --> 00:00:14,340
让我们更接近人工智能领域，因为机器人和人工智能

4
00:00:14,340 --> 00:00:18,210
它附带的部分内容是通过强化学习构建的。

5
00:00:18,480 --> 00:00:23,710
因此，为了防止在下一个教程中出现任何失望，我们不会构建任何机器人，但是我们会

6
00:00:23,710 --> 00:00:29,850
将解决一个非常有趣的问题，称为多Bendit问题，我们将解决

7
00:00:29,850 --> 00:00:32,780
两种最受欢迎​​的算法都可以解决这个问题。

8
00:00:32,790 --> 00:00:36,720
这些是置信上限，并且是汤普森算法。

9
00:00:36,720 --> 00:00:41,940
因此，我们今天将从置信区间上限开始，我们将在

10
00:00:41,960 --> 00:00:42,490
我们的。

11
00:00:42,660 --> 00:00:47,630
在第一个教程中，我们将导入数据集并解释问题所在。

12
00:00:47,670 --> 00:00:51,600
那就是我们将解释什么是多点问题。

13
00:00:51,600 --> 00:00:53,480
因此，让我们从基础开始。

14
00:00:53,490 --> 00:00:58,980
我们将它们的权限设置为工作目录，然后进入文件夹中的Part，然后进入Part

15
00:00:58,980 --> 00:01:04,420
6强化学习，每个公司的第32节是关于UCB的。

16
00:01:04,650 --> 00:01:05,380
好吧。

17
00:01:05,520 --> 00:01:11,280
现在，在此文件夹中，确保您具有添加城市优化城市Rs4点击率

18
00:01:11,280 --> 00:01:17,730
因此，我们将尝试优化投放的广告中不同用户的点击率

19
00:01:17,730 --> 00:01:21,210
一个社交网络，因此这就是我们数据集的名称。

20
00:01:21,230 --> 00:01:21,950
是。

21
00:01:22,200 --> 00:01:27,120
因此，如果您有此数据集，现在可以单击此处的更多按钮，然后将其设置为工作

22
00:01:27,120 --> 00:01:27,910
目录。

23
00:01:28,380 --> 00:01:28,770
好。

24
00:01:28,830 --> 00:01:31,500
现在，我们将导入数据集。

25
00:01:31,500 --> 00:01:39,570
因此，像往常一样，我们将对数据集数据集进行调用或使其无效，然后等于将t读取为

26
00:01:39,570 --> 00:01:40,520
我们听到了。

27
00:01:40,680 --> 00:01:46,620
然后在括号中，我们只需要在引号中添加数据集的名称。

28
00:01:46,650 --> 00:01:55,820
所以它就在这里，并且增加了下划线城市在zation上的得分。

29
00:01:55,830 --> 00:01:56,540
开始了。

30
00:01:56,670 --> 00:01:59,750
而且，我们不要忘记将视点视为终点。

31
00:01:59,880 --> 00:02:01,920
现在很少导入此数据集。

32
00:02:01,920 --> 00:02:07,370
因此，让我们选择该行，然后执行数据集将其导入。

33
00:02:07,410 --> 00:02:09,240
现在让我们看看。

34
00:02:09,240 --> 00:02:11,980
通过单击此设置就在这里。

35
00:02:12,120 --> 00:02:12,720
开始了。

36
00:02:12,930 --> 00:02:13,280
好。

37
00:02:13,320 --> 00:02:20,520
因此，请记住第3部分Cl。 我们处理的问题包括对用户进行分类和定位

38
00:02:20,520 --> 00:02:23,910
在社交网络上进行一些汽车公司的营销活动。

39
00:02:23,910 --> 00:02:29,550
请记住，我们有一个社交网络的业务客户，该客户在社交网络上投放广告

40
00:02:29,550 --> 00:02:35,010
我们制作了这些分类模型，以定位最有可能购买此商品的社交网络上的用户

41
00:02:35,280 --> 00:02:41,550
该汽车公司以极低的价格推出的全新豪华SUV，基本上是为此做准备

42
00:02:41,550 --> 00:02:47,650
这家汽车公司的市场营销活动准备了一个广告，并将其投放到社交网络上。

43
00:02:47,760 --> 00:02:52,470
发生的事情是，营销部准备了同一广告的一些不同版本

44
00:02:52,770 --> 00:02:58,200
您知道将汽车放置在不同的场景中，例如，一个广告使汽车行驶在美丽的道路上

45
00:02:58,560 --> 00:03:03,630
在另一版广告中，汽车在山上，也许在另一版中，汽车在山上

46
00:03:03,630 --> 00:03:04,380
桥。

47
00:03:04,380 --> 00:03:10,440
营销部准备了他们将要投放的同一广告的不同版本

48
00:03:10,440 --> 00:03:11,560
社交网络。

49
00:03:11,820 --> 00:03:19,860
但是问题在于，他们准备了该广告的10个出色版本，以及该广告外观的10个版本

50
00:03:20,040 --> 00:03:20,880
大。

51
00:03:20,880 --> 00:03:25,420
因此，他们实际上不太确定要在社交网络上投放哪个广告。

52
00:03:25,500 --> 00:03:28,680
他们想投放将获得最大点击次数的广告。

53
00:03:28,750 --> 00:03:31,260
您知道，因此大多数用户都购买SUV。

54
00:03:31,260 --> 00:03:35,170
因此，他们需要投放可带来最佳转化率的广告。

55
00:03:35,430 --> 00:03:41,670
所以这家公司所做的是，他们聘请我们担任数据科学家，他们说好，我有10个版本

56
00:03:41,670 --> 00:03:42,500
广告的

57
00:03:42,600 --> 00:03:47,250
我们将广告放置在The Social Network中的预算有限，因为将这些广告投放到Social

58
00:03:47,250 --> 00:03:48,590
网络花了他们钱。

59
00:03:48,720 --> 00:03:54,990
因此，这家公司希望科学家们找到最佳策略，以便快速找出

60
00:03:54,990 --> 00:04:01,530
此广告的版本最适合用户，即哪个版本的广告将使我们获得最高

61
00:04:01,620 --> 00:04:02,390
兑换率。

62
00:04:02,400 --> 00:04:05,310
那就是城市，那就是点击率。

63
00:04:05,310 --> 00:04:08,820
我们希望找到获得最多点击次数的广告。

64
00:04:08,850 --> 00:04:13,950
因此，现在说到这一点，我们就可以知道我们将要做的事情之间的主要区别

65
00:04:13,950 --> 00:04:20,910
现在以及我们之前所做的事情，因为之前我们有一个数据集，其中某些数据内容是独立的

66
00:04:20,910 --> 00:04:23,190
变量和一个因变量。

67
00:04:23,190 --> 00:04:29,180
然后我们进行了一些聚类，其中只有自变量，现在情况有所不同。

68
00:04:29,190 --> 00:04:31,580
我们从没有数据开始。

69
00:04:31,590 --> 00:04:37,050
我知道我们面前有一些数据集，但这只是用于仿真的数据集，因为会发生什么

70
00:04:37,050 --> 00:04:37,870
在真实生活中。

71
00:04:37,920 --> 00:04:39,690
我们将假装我们生活在现实中。

72
00:04:39,690 --> 00:04:42,550
我们将假装我们还没有任何数据。

73
00:04:42,780 --> 00:04:47,730
嗯，在现实生活中发生的事情是，我们将开始对此进行实验并通过放置

74
00:04:47,730 --> 00:04:50,530
在社交网络上将其投放到不同版本的广告。

75
00:04:50,730 --> 00:04:57,000
根据我们观察到的结果，我们将更改将这些广告投放到社交网络上的策略

76
00:04:57,000 --> 00:04:57,620
网络。

77
00:04:57,750 --> 00:05:05,090
所以这是不同的步骤，我们有10个相同的版本，再加上10个版本

78
00:05:05,150 --> 00:05:09,270
广告试图销售这种便宜的豪华SUV。

79
00:05:09,380 --> 00:05:15,860
每次社交网络用户登录到他的帐户时，我们都会放置一个版本

80
00:05:15,860 --> 00:05:21,050
10个广告，并且这将在用户每次连接到其帐户时进行。

81
00:05:21,050 --> 00:05:27,350
我们将向他展示该广告的一个版本，例如您的广告的第3个版本3。

82
00:05:27,440 --> 00:05:30,120
用户点击广告后的响应。

83
00:05:30,170 --> 00:05:32,490
我们得到的奖励等于1。

84
00:05:32,660 --> 00:05:38,630
如果用户不点击广告，我们将获得等于零的奖励，我们将为此

85
00:05:38,630 --> 00:05:41,870
社交网络上的一万个用户。

86
00:05:41,870 --> 00:05:44,300
我们将向10000个用户展示广告。

87
00:05:44,290 --> 00:05:49,580
我们将观察用户是否点击广告上的是或否。

88
00:05:49,580 --> 00:05:56,090
给我们一个我们想要的，如果用户不点击会给我们零的广告，我们就会

89
00:05:56,090 --> 00:06:02,180
不会展示我们选择的广告的不同版本，或者随机显示

90
00:06:02,180 --> 00:06:03,840
策略来做到这一点。

91
00:06:03,860 --> 00:06:10,030
了解强化学习的关键是，该策略将取决于每个人

92
00:06:10,030 --> 00:06:15,030
回合我们在前几轮所观察到的先前结果。

93
00:06:15,140 --> 00:06:17,700
举例来说，当我们大约10岁时

94
00:06:17,750 --> 00:06:22,250
幕后发生的事情是该算法将查看观察到的不同结果

95
00:06:22,340 --> 00:06:28,370
在前十轮中，根据这些结果，它将决定该广告的版本

96
00:06:28,370 --> 00:06:29,890
将显示给用户。

97
00:06:30,080 --> 00:06:35,280
因此，强化学习也称为在线学习或交互式学习。

98
00:06:35,450 --> 00:06:39,920
由于该策略是动态的，因此取决于实验开始时的观察结果

99
00:06:40,310 --> 00:06:41,980
到现在为止。

100
00:06:42,020 --> 00:06:43,770
那么现在是什么数据集。

101
00:06:43,790 --> 00:06:49,040
这只是对我们向用户展示广告时发生的情况的某种模拟。

102
00:06:49,040 --> 00:06:55,310
换句话说，这是上帝所知道的，因为我们不知道每个用户要点击哪个广告

103
00:06:55,310 --> 00:06:55,710
上。

104
00:06:55,910 --> 00:07:01,220
数据集告诉我们的是，这是针对每个用户连接的每一轮

105
00:07:01,220 --> 00:07:05,150
到他要在哪个版本的用户上点击的帐户。

106
00:07:05,180 --> 00:07:09,830
因此，让我们举一个例子，让我们解释一下这五个第一用户的情况。

107
00:07:09,830 --> 00:07:11,410
因此，让我们进行第一轮比赛。

108
00:07:11,600 --> 00:07:17,000
并且根据模拟或根据上帝，社交网络的第一位用户将

109
00:07:17,000 --> 00:07:19,830
如果我们向他展示第一个版本，请点击广告。

110
00:07:19,940 --> 00:07:26,060
第五版和第九版，如果我们向他展示第二版，第三版，第四版

111
00:07:26,060 --> 00:07:29,730
版本6 7 8或第十个版本。

112
00:07:29,900 --> 00:07:32,810
那么这个用户不会点击广告。

113
00:07:33,020 --> 00:07:34,680
这就是上帝所知道的。

114
00:07:34,820 --> 00:07:40,330
但是就我们而言，我们不知道点击哪个广告。

115
00:07:40,550 --> 00:07:41,940
那么第二位用户呢。

116
00:07:41,990 --> 00:07:47,120
因此，这是第二轮的第二轮，我们展示了该广告的另一个版本，并根据上帝的

117
00:07:47,120 --> 00:07:52,520
说实话，第二个用户只有在向他展示第九个版本时才会点击广告。

118
00:07:52,520 --> 00:07:56,120
第三位用户绝不会点击添加我们显示的任何版本。

119
00:07:56,150 --> 00:08:02,120
第四个用户将仅单击第二个版本和第8个版本，而第五个用户将永远不会单击

120
00:08:02,120 --> 00:08:02,920
点击广告。

121
00:08:02,990 --> 00:08:04,990
无论我们向他展示什么版本。

122
00:08:05,000 --> 00:08:07,010
好的，这就是问题的主意。

123
00:08:07,040 --> 00:08:12,590
因此，我们将构建UCB算法和Tompson something算法这两种算法，

124
00:08:12,590 --> 00:08:18,650
这些算法将从此处决定向用户展示哪个版本的广告。

125
00:08:18,650 --> 00:08:24,050
根据用户获得的奖励，当用户点击广告或

126
00:08:24,050 --> 00:08:29,440
如果用户未点击广告，则我们的字词等于零，它将决定向用户展示哪个广告

127
00:08:29,450 --> 00:08:30,370
下回合。

128
00:08:30,500 --> 00:08:32,850
根据以前的观察。

129
00:08:33,050 --> 00:08:39,990
因此，如果我们走到这里，我们将进行10000轮回合，可以看到我们将广告展示到10000

130
00:08:40,010 --> 00:08:40,790
用户。

131
00:08:40,970 --> 00:08:45,600
因此，当然，算法的目标是使总奖励最大化。

132
00:08:45,680 --> 00:08:51,020
那是所有不同奖励的总和，以及通过不同选择获得的每一轮

133
00:08:51,020 --> 00:08:51,780
广告。

134
00:08:52,040 --> 00:08:53,430
好，让我们开始吧。

135
00:08:53,450 --> 00:08:57,540
让我们从对UCB算法的较高置信度开始。

136
00:08:57,620 --> 00:09:02,690
但是在我们开始实现该算法之前，我想向您展示一些我想展示的东西

137
00:09:02,690 --> 00:09:07,700
如果您在每次试用时随机选择广告的版本，将会发生什么情况。

138
00:09:07,790 --> 00:09:10,850
你知道没有算法没有策略。

139
00:09:10,850 --> 00:09:17,820
每次用户连接到其帐户时，我们都会随机显示这十个版本中的一个。

140
00:09:17,840 --> 00:09:21,070
所以我实际上准备了这个算法。

141
00:09:21,080 --> 00:09:26,120
我们不会一起实现，因为该算法实际上与

142
00:09:26,120 --> 00:09:29,620
为您提供了我们将在接下来的教程中实现的动力。

143
00:09:29,780 --> 00:09:36,370
但是实际上在您看到的文件夹中提供了此算法，它是此随机选择文件。

144
00:09:36,410 --> 00:09:40,040
实际上，我在这里预先审查了该算法。

145
00:09:40,040 --> 00:09:43,700
如您所见，我在这里将此算法称为随机选择。

146
00:09:43,710 --> 00:09:47,800
我要按照我们刚才所说的那样输入日期，所以我不需要再次执行该操作。

147
00:09:47,960 --> 00:09:54,320
在本节中，我将实现随机选择算法，该算法仅包括选择

148
00:09:54,320 --> 00:09:59,730
广告的一个随机版本以及用户每次在其社交工作上进行交流时的每一轮

149
00:09:59,750 --> 00:10:00,840
至关重要。

150
00:10:00,840 --> 00:10:03,860
所以我现在要执行该部分。

151
00:10:04,320 --> 00:10:06,200
因此，这里实现得很好。

152
00:10:06,420 --> 00:10:09,140
我们可以看到该算法的不同结果。

153
00:10:09,150 --> 00:10:15,450
所以最重要的结果是总数我们希望这个变量是不同的总和

154
00:10:15,450 --> 00:10:17,520
奖励到最后一轮。

155
00:10:17,520 --> 00:10:19,860
最多可容纳10000个用户。

156
00:10:19,920 --> 00:10:25,300
那么总的奖励是什么？总的奖励是1,242。

157
00:10:25,560 --> 00:10:31,620
所以发生的是，随机选择算法可以随机选择每一轮

158
00:10:31,620 --> 00:10:35,450
实际上会在此选定列表中看到随机选择。

159
00:10:35,610 --> 00:10:40,890
因此，我们可以清楚地看到随机选择算法为第一个用户在零地面发生了什么

160
00:10:40,890 --> 00:10:46,040
然后选择版本号，然后在第二轮之前选择第二个版本

161
00:10:46,040 --> 00:10:51,300
版本号3，然后是第四个运行版本号1和第五个回合版本号4。

162
00:10:51,300 --> 00:10:52,820
那是随机选择。

163
00:10:52,860 --> 00:10:59,340
因此，根据上帝的真实结果，每一轮广告的选择都会产生回报。

164
00:10:59,520 --> 00:11:04,830
因此，在第一轮首次使用连接并计算随机选择算法时就选择了

165
00:11:04,860 --> 00:11:09,700
在第4位，我们在此处看到一个零，这意味着该第一位用户不会接受此操作。

166
00:11:09,700 --> 00:11:12,800
因此，我们在第一轮获得零奖励。

167
00:11:13,080 --> 00:11:15,520
那第二选择呢？

168
00:11:15,840 --> 00:11:20,550
好吧，我们在第二轮看到在第四轮也和您一样

169
00:11:20,550 --> 00:11:26,190
第二位用户没有点击此广告，因此我们还获得了零奖励以及

170
00:11:26,190 --> 00:11:33,300
我们观察到的实际上是在结束时获得的所有奖励的总和，无论是0还是1

171
00:11:33,300 --> 00:11:35,490
一万发

172
00:11:35,490 --> 00:11:35,810
好吧。

173
00:11:35,820 --> 00:11:42,030
因此，要记住的有趣一点是，当我们随机选择广告时，我们会得到

174
00:11:42,030 --> 00:11:44,170
1,242。

175
00:11:44,340 --> 00:11:46,570
好吧，您知道这是随机因素。

176
00:11:46,620 --> 00:11:53,300
因此，如果我们再次选择该选项，我们将得到另一个单词，但这将非常接近此值

177
00:11:53,300 --> 00:11:53,810
这里。

178
00:11:53,910 --> 00:11:55,900
我要再做一次。

179
00:11:56,010 --> 00:12:01,430
如您所见，我们得到了1232，我什至可以再次这样做。

180
00:12:01,480 --> 00:12:06,850
我又得到1246 1236。

181
00:12:06,870 --> 00:12:12,160
因此，我们总可获得接近1200的总奖励。

182
00:12:12,360 --> 00:12:19,460
因此，让我们牢记这一决心，因为我们将把它与我们获得的总回报进行比较。

183
00:12:19,500 --> 00:12:25,560
多亏了我们更先进的算法，该算法具有较低的置信度，然后是汤普森采样

184
00:12:25,590 --> 00:12:26,430
算法。

185
00:12:26,730 --> 00:12:32,270
所以1200让我们看看您如何看待我和汤普森。

186
00:12:32,370 --> 00:12:37,140
现在，最后一件事向您展示了我们在本课程中实现的每种算法，

187
00:12:37,140 --> 00:12:39,850
最后令人兴奋的一步是可视化结果。

188
00:12:40,080 --> 00:12:46,770
在本部分的强化学习中，结果的可视化将包括可视化

189
00:12:46,770 --> 00:12:51,470
直方图，我们可以看到不同版本的数据的不同选择。

190
00:12:51,600 --> 00:12:57,440
因此，我将向您展示Stuart Breske数量对我们的随机选择算法的影响

191
00:12:57,450 --> 00:12:59,350
控制和执行。

192
00:12:59,430 --> 00:13:00,530
现在我们开始。

193
00:13:00,600 --> 00:13:06,390
当然，由于我们的算法会在每个回合中随机选择不同版本的广告。

194
00:13:06,480 --> 00:13:13,410
当然，我们在十个不同的版本中获得了几乎相同的分布

195
00:13:13,410 --> 00:13:17,410
广告版本的选择次数几乎相同。

196
00:13:17,670 --> 00:13:24,660
好吧，那只是给您一些额外的动力，现在是时候让您回头了

197
00:13:24,660 --> 00:13:28,730
并开始实施它。

198
00:13:28,740 --> 00:13:33,370
因此，请记住我们总共使用了1200个随机选择算法。

199
00:13:33,510 --> 00:13:35,730
让我们看看UCB是如何击败它的。

200
00:13:35,730 --> 00:13:37,780
因此，我们将在下一个教程中找到。

201
00:13:37,810 --> 00:13:39,520
在那之前享受机器学习

