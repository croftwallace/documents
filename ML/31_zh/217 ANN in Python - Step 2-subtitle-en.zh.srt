1
00:00:00,330 --> 00:00:02,840
您好，欢迎使用Python教程。

2
00:00:03,030 --> 00:00:08,310
因此，在此之前，我们都导入了所需的库以构建未来的人工神经网络。

3
00:00:08,310 --> 00:00:08,940
网络。

4
00:00:09,090 --> 00:00:14,400
因此，现在我们将开始构建深度学习模型，并且我们将构建该模型

5
00:00:14,450 --> 00:00:15,540
分两部分。

6
00:00:15,540 --> 00:00:18,940
第一部分将是我在这里准备的数据处理。

7
00:00:19,140 --> 00:00:23,090
第2部分将仅涉及创建A-N和更多内容。

8
00:00:23,310 --> 00:00:28,800
因此，让我们从第1部分开始，您将在本教程中理解为什么准备如此重要

9
00:00:28,800 --> 00:00:32,210
正确地建立数据，从而进一步发展未来。

10
00:00:32,580 --> 00:00:39,210
因此，正如您在由curial解释的业务问题描述中所了解的那样，我们处于分类的前面

11
00:00:39,210 --> 00:00:39,890
问题。

12
00:00:39,990 --> 00:00:44,930
因此，我们有一些自变量，它们是有关银行客户的一些信息。

13
00:00:45,150 --> 00:00:50,310
并且我们正在尝试预测因变量的二进制结果，如果

14
00:00:50,310 --> 00:00:53,960
客户离开银行，如果客户留在银行，则为零。

15
00:00:54,150 --> 00:01:00,360
所以这是一个分类问题，因此我在这里准备了我们的分类模板

16
00:01:00,420 --> 00:01:03,050
我们在第3部分中进行了分类。

17
00:01:03,060 --> 00:01:08,870
因此，基本上，我们现在要做的就是将模板中的所有内容（除了可视化部分）

18
00:01:08,880 --> 00:01:11,460
因为我们知道我们有许多自变量。

19
00:01:11,460 --> 00:01:13,770
我们有10多个自变量。

20
00:01:13,950 --> 00:01:19,020
因此，我们当然在预测区域和预测边界方面没有可视化的地方

21
00:01:19,200 --> 00:01:22,500
因为我们只有两个以上的自变量。

22
00:01:22,500 --> 00:01:28,050
因此，我们将从导入库到这里，一概而论，因为最后我们将看看

23
00:01:28,050 --> 00:01:32,500
混淆矩阵来评估in和模型的性能。

24
00:01:32,610 --> 00:01:39,600
因此，我们将采用这一整个部分，回到我们的古老模型并将所有内容粘贴到此处。

25
00:01:39,600 --> 00:01:40,320
好吧。

26
00:01:40,320 --> 00:01:44,660
因此，让我们逐一处理每个部分。

27
00:01:44,670 --> 00:01:45,720
让我们从第一个开始。

28
00:01:45,740 --> 00:01:47,000
导入库。

29
00:01:47,190 --> 00:01:50,300
因此，让我们在这里获取此代码部分并执行。

30
00:01:50,310 --> 00:01:50,910
开始了。

31
00:01:50,910 --> 00:01:52,370
库将导入它。

32
00:01:52,440 --> 00:01:53,210
大。

33
00:01:53,220 --> 00:01:56,030
现在第二个代码部分导入数据集。

34
00:01:56,190 --> 00:02:01,160
因此，在导入数据集之前，我们需要做的是将正确的父亲设置为工作目录。

35
00:02:01,230 --> 00:02:06,240
您可能已经注意到，我刚刚更新了Spider的最新版本，因此

36
00:02:06,240 --> 00:02:12,220
我们可以观察到Spider中的一些细微变化，例如对象帮助已被帮助替换。

37
00:02:12,330 --> 00:02:16,470
然后我们在这里不再需要这个小按钮来将其发送给那些工作目录。

38
00:02:16,470 --> 00:02:20,330
此处已由“选项”按钮代替。

39
00:02:20,560 --> 00:02:21,320
这里是。

40
00:02:21,540 --> 00:02:25,950
那就是你说你父亲在工作目录的方式，但是当然我们需要选择

41
00:02:25,950 --> 00:02:26,670
正确的文件夹。

42
00:02:26,680 --> 00:02:28,320
我们到了文件浏览器。

43
00:02:28,320 --> 00:02:34,550
我们转到机械A-Z文件夹，然后将8个人学习和第40部分分开。

44
00:02:34,620 --> 00:02:36,380
人工神经网络。

45
00:02:36,390 --> 00:02:37,190
开始了。

46
00:02:37,410 --> 00:02:41,610
那就是我们要设置工作目录的步枪，以确保您具有转弯建模

47
00:02:41,740 --> 00:02:48,790
归档时，如果是这种情况，则可以在此处单击此选项，然后单击设置控制台

48
00:02:48,840 --> 00:02:50,030
工作目录。

49
00:02:50,250 --> 00:02:51,060
开始了。

50
00:02:51,070 --> 00:02:51,950
一切安好。

51
00:02:51,960 --> 00:02:53,800
现在我们可以导入数据集。

52
00:02:54,120 --> 00:02:55,140
因此，让我们开始吧。

53
00:02:55,290 --> 00:02:57,850
数据集不是社交网络广告。

54
00:02:57,870 --> 00:02:58,800
那很容易。

55
00:02:58,920 --> 00:03:04,840
毛德林说，现在要强调。

56
00:03:05,020 --> 00:03:05,320
好吧。

57
00:03:05,320 --> 00:03:05,890
完善。

58
00:03:05,920 --> 00:03:12,880
因此，让我们很好地导入它，同时重要的是它将很好地探索以快速浏览。

59
00:03:13,090 --> 00:03:17,040
这就是我们的。

60
00:03:17,270 --> 00:03:23,630
提醒您，我们在银行的银行客户信息会收集这些信息，

61
00:03:23,630 --> 00:03:29,690
同时观察客户是否在六个月内留下或离开了银行。

62
00:03:29,990 --> 00:03:36,400
因此，这里要理解的关键是所有这些变量都是独立变量。

63
00:03:36,470 --> 00:03:39,830
并且这里退出的最后一列已经是无价的。

64
00:03:39,980 --> 00:03:47,000
因此，我们正在尝试根据这些独立机构的信息来预测这种退出的结果是无价的

65
00:03:47,000 --> 00:03:47,890
变量。

66
00:03:48,080 --> 00:03:51,520
我们将使用人工神经网络来做到这一点。

67
00:03:51,530 --> 00:03:53,140
好吧，让我们按OK。

68
00:03:53,270 --> 00:03:59,690
现在，我们要做的下一件事是创建特征的矩阵X并执行所需的操作

69
00:03:59,690 --> 00:04:01,760
在此处放置正确的索引。

70
00:04:01,760 --> 00:04:07,820
因此，要了解这些索引是什么，我们需要返回到数据集并查看哪个独立索引

71
00:04:07,820 --> 00:04:13,430
我们想要包含在要素矩阵中的变量，因为我们的指标和要素别无其他

72
00:04:13,430 --> 00:04:16,290
而不是包含自变量的矩阵。

73
00:04:16,610 --> 00:04:16,940
好吧。

74
00:04:16,940 --> 00:04:18,890
因此，让我们开始吧。

75
00:04:18,890 --> 00:04:20,470
我们这里有所有变量。

76
00:04:20,630 --> 00:04:22,510
让我们一一看一下。

77
00:04:22,520 --> 00:04:28,880
第一列是行号行号当然不会影响客户离开的决定

78
00:04:28,910 --> 00:04:30,200
或留在银行。

79
00:04:30,200 --> 00:04:34,300
因此，我们不会在功能矩阵中包含此变量。

80
00:04:34,430 --> 00:04:40,170
第二个变量的客户ID相同，对敞篷车绝对没有影响。

81
00:04:40,190 --> 00:04:40,730
好吧。

82
00:04:40,760 --> 00:04:42,350
第三栏姓。

83
00:04:42,440 --> 00:04:43,760
嗯，是一样的。

84
00:04:43,760 --> 00:04:48,470
并不是因为您的名字叫安德鲁斯（Andrewes），您才有更多的机会离开银行

85
00:04:48,470 --> 00:04:50,120
是麦当劳。

86
00:04:50,150 --> 00:04:50,440
好吧。

87
00:04:50,450 --> 00:04:56,240
这绝对不会影响深层目标，因此我们将不包括可雇用的CRN

88
00:04:56,300 --> 00:04:57,250
要么。

89
00:04:57,290 --> 00:05:00,100
现在，下一个可行的信用评分以及良好的信用评分。

90
00:05:00,100 --> 00:05:05,690
是的，信用分数很可能会影响客户留在银行的决定。

91
00:05:05,690 --> 00:05:11,450
银行或离开银行，如果我们考虑一下，我们可能会期望信用评分低的客户

92
00:05:11,450 --> 00:05:15,640
与信用评分高的客户相比，离开银行的可能性更大。

93
00:05:15,650 --> 00:05:20,870
所以可以肯定，这是第一个将进入我们特征矩阵的自变量。

94
00:05:20,870 --> 00:05:22,990
可以然后地理地理。

95
00:05:23,030 --> 00:05:29,000
是的，也许客户和朋友比德国的客户更有可能离开银行，所以他们愿意

96
00:05:29,000 --> 00:05:30,260
做到这一点。

97
00:05:30,260 --> 00:05:30,870
性别。

98
00:05:31,040 --> 00:05:32,190
可能是的。

99
00:05:32,210 --> 00:05:34,700
男人比女人更有可能离开银行。

100
00:05:34,700 --> 00:05:35,400
我们不知道。

101
00:05:35,450 --> 00:05:38,700
我们必须检查一下年龄。

102
00:05:38,720 --> 00:05:44,030
当然，年轻人可能比不仅仅拥有老年人的老年人更有可能离开银行

103
00:05:44,030 --> 00:05:48,740
更稳定，但也可能在银行待了更长的时间，因此更加稳定

104
00:05:48,740 --> 00:05:51,400
可能会比任期保持正确。

105
00:05:51,500 --> 00:05:53,820
任期是客户在银行呆了多长时间。

106
00:05:53,990 --> 00:05:58,240
当然，这可能会影响到留下或离开银行的决定。

107
00:05:58,370 --> 00:06:01,300
因此，我们还要兼顾平衡。

108
00:06:01,370 --> 00:06:07,460
当然，与余额为零的客户相比，余额为零的客户有更多的机会离开银行。

109
00:06:07,460 --> 00:06:09,850
高余额产品。

110
00:06:09,860 --> 00:06:10,490
我们不知道。

111
00:06:10,490 --> 00:06:11,620
这可能会产生影响。

112
00:06:11,680 --> 00:06:13,930
我们也将使用信用卡。

113
00:06:14,060 --> 00:06:19,910
是的，也许我们可以期望拥有信用卡的客户比在银行停留的可能性更大。

114
00:06:19,910 --> 00:06:22,090
没有信用卡的客户。

115
00:06:22,100 --> 00:06:24,960
因此，我们也必须检查它是否是活动成员。

116
00:06:25,070 --> 00:06:26,810
同样的逻辑在这里。

117
00:06:26,960 --> 00:06:33,710
如果客户很活跃，那么他可能更有可能留在银行，并最终估算工资。

118
00:06:33,830 --> 00:06:39,620
嗯，这与高估计薪水的平衡客户的逻辑相同

119
00:06:39,620 --> 00:06:43,410
比估计薪水较低的客户留在银行。

120
00:06:43,640 --> 00:06:50,420
因此，根据我们自己的逻辑，我们可以说出哪些自变量可能会对可用的跌落产生影响。

121
00:06:50,570 --> 00:06:55,930
但是我们不知道哪个自变量对因变量的影响最大。

122
00:06:56,150 --> 00:07:01,970
这就是我们的人工神经网络将发现的东西，通过查看相关性，我们将完美地看到

123
00:07:01,970 --> 00:07:07,340
因此，它将在神经网络中赋予机器人更大的权重，

124
00:07:07,340 --> 00:07:08,870
影响最大。

125
00:07:08,870 --> 00:07:13,410
好的，现在我们知道要在功能矩阵中包含哪些自变量。

126
00:07:13,460 --> 00:07:17,510
这就是从信用评分到最后一个的所有自变量。

127
00:07:17,510 --> 00:07:18,800
估计不好意思。

128
00:07:18,840 --> 00:07:23,330
因此，让我们看看这些变量的索引是什么。

129
00:07:23,360 --> 00:07:25,630
因此，让我们看看索引和野牛从零开始。

130
00:07:25,730 --> 00:07:26,830
所以这里是零。

131
00:07:26,840 --> 00:07:28,770
一二三。

132
00:07:28,850 --> 00:07:36,290
好，所以我们从三二三四五五六七八九10 11和12开始。

133
00:07:36,290 --> 00:07:39,640
好的，所以我们必须包含从3到12的索引。

134
00:07:39,740 --> 00:07:40,940
因此，让我们开始吧。

135
00:07:40,940 --> 00:07:42,200
让我们在这里按OK。

136
00:07:42,350 --> 00:07:46,340
好吧，我们需要将索引从3改为12。

137
00:07:46,340 --> 00:07:49,330
这需要索引2和3。

138
00:07:49,580 --> 00:07:56,930
因此，要使索引从3到12，我们需要在此处将索引3列的下端添加

139
00:07:56,930 --> 00:08:01,230
那么上限，但请记住，上限被排除在范围内。

140
00:08:01,250 --> 00:08:04,410
因此，我们需要投入13而不是投入12。

141
00:08:04,580 --> 00:08:07,520
这将所有索引从3变为12。

142
00:08:07,520 --> 00:08:08,200
好的

143
00:08:08,250 --> 00:08:14,900
因此，现在我们准备创建特征X的矩阵，让我们选择此行并执行

144
00:08:15,130 --> 00:08:17,340
矩阵特征X it。

145
00:08:17,440 --> 00:08:18,090
好吧。

146
00:08:18,340 --> 00:08:20,920
现在让我们创建一个不可见的向量。

147
00:08:21,040 --> 00:08:22,200
所以这很容易。

148
00:08:22,240 --> 00:08:28,120
您知道吗，我们的自变量的索引是3到12，因此索引

149
00:08:28,120 --> 00:08:34,720
已经非常有价值的不是X数字13，因此我们在这里输入13，而不是4。

150
00:08:34,990 --> 00:08:35,450
对。

151
00:08:35,650 --> 00:08:37,690
因此，我们准备构建因变量矢量。

152
00:08:37,700 --> 00:08:40,370
因此，让我们喜欢这一行并执行。

153
00:08:40,680 --> 00:08:41,010
好吧。

154
00:08:41,010 --> 00:08:42,660
在这里，我们去看看。

155
00:08:42,670 --> 00:08:51,800
对于该银行样本的所有10000个客户，为什么二进制结果都为零或之一。

156
00:08:51,850 --> 00:08:53,250
好吧，让我们按OK。

157
00:08:53,400 --> 00:08:55,700
我们已经完成了导入数据集的工作。

158
00:08:55,720 --> 00:08:57,610
一切准备就绪。

159
00:08:57,610 --> 00:08:59,590
现在，让我们继续下一个代码部分。

160
00:08:59,680 --> 00:09:04,580
下一个代码部分是关于将数据集分为训练集和测试集。

161
00:09:04,720 --> 00:09:10,810
但是在执行此操作之前，我们必须注意一些事项，在查看数据之前必须先进行修正

162
00:09:10,810 --> 00:09:12,980
设置为训练集和测试。

163
00:09:13,060 --> 00:09:14,220
你能猜出这是什么。

164
00:09:14,440 --> 00:09:19,860
好吧，这当然与以下事实有关：我们在特征矩阵中有一些类别变量

165
00:09:20,140 --> 00:09:25,020
因此，我们需要像第1部分中的数据处理一样对它们进行完全编码。

166
00:09:25,300 --> 00:09:31,680
这就是为什么我也在此处准备分类数据文件的原因，因此在此文件中，我们

167
00:09:31,680 --> 00:09:37,910
将在此处使用此代码部分，该部分对您数据集中的所有分类数据进行编码。

168
00:09:38,080 --> 00:09:44,660
因此，顺便说一下，我们的因变量是分类的，但它的取值为0或1。

169
00:09:44,710 --> 00:09:50,880
因此它需要数值，因此我们无需将标签编码器应用于您知道已编码的文本

170
00:09:50,890 --> 00:09:56,500
数字，但我们有我们的自变量，其中的类别是字符串，因此我们

171
00:09:56,500 --> 00:10:01,720
需要在此处使用此代码段，以对分类自变量进行编码。

172
00:10:01,720 --> 00:10:06,450
好的，我现在拿着这份副本，回到我的帮助和档案中。

173
00:10:06,610 --> 00:10:12,550
在将数据集分为训练集和测试之前，我们将对分类数据进行处理，因为

174
00:10:12,550 --> 00:10:18,010
基本上，当您这样做时，因变量y中的特征矩阵X必须已经

175
00:10:18,010 --> 00:10:18,720
编码。

176
00:10:18,880 --> 00:10:21,090
好吧，所以我在这里立足。

177
00:10:21,100 --> 00:10:21,870
开始了。

178
00:10:21,880 --> 00:10:27,190
我将删除它只是为了区分自变量和因变量。

179
00:10:27,190 --> 00:10:30,760
现在，我们将对分类自变量进行编码。

180
00:10:30,760 --> 00:10:36,250
因此，让我们看看它们是什么，我们将通过控制台查看功能矩阵。

181
00:10:36,250 --> 00:10:39,640
所以我在这里按X，让我们看一下。

182
00:10:39,640 --> 00:10:40,470
好吧。

183
00:10:40,660 --> 00:10:42,940
这些都是我们的自变量。

184
00:10:42,970 --> 00:10:49,090
我们可以非常清楚快速地看到这里只有两个分类自变量

185
00:10:49,090 --> 00:10:52,970
是包含三个类别的国家。

186
00:10:53,020 --> 00:10:54,820
法国西班牙和德国。

187
00:10:55,000 --> 00:11:00,110
并且性别变量包含女性和男性两类。

188
00:11:00,130 --> 00:11:05,080
因此，这是我们需要在特征矩阵中编码的仅有两个变量。

189
00:11:05,200 --> 00:11:06,430
因此，让我们在这里at可危。

190
00:11:06,430 --> 00:11:08,340
第一个国家。

191
00:11:08,350 --> 00:11:14,440
好的，因为我们都需要对两个变量进行编码，所以我们需要创建它们以对对象进行标记和编码

192
00:11:14,440 --> 00:11:14,850
这里。

193
00:11:14,920 --> 00:11:18,670
因此，我们将第一个标签编码器称为下划线X。

194
00:11:18,780 --> 00:11:20,290
下划线一个。

195
00:11:20,300 --> 00:11:22,990
好的，所以我们在这里创建对象。

196
00:11:23,080 --> 00:11:28,430
然后在下一行中，应用第五种变换方法对该变量进行编码。

197
00:11:28,450 --> 00:11:34,990
也就是说，它将法国，西班牙和德国的街道转换为数字0 1和2。

198
00:11:35,000 --> 00:11:36,860
因此，这是编码的第一步。

199
00:11:36,940 --> 00:11:37,930
因此，让我们开始吧。

200
00:11:37,930 --> 00:11:44,800
我们需要在此处放置正确的索引，它不是零，而是一个，因为索引和字节以及

201
00:11:44,800 --> 00:11:45,650
开始为零。

202
00:11:45,730 --> 00:11:48,930
那就是索引0，那就是我们想要的索引1。

203
00:11:48,940 --> 00:11:50,530
很好，这里也一样。

204
00:11:50,530 --> 00:11:52,870
我们将零替换为一。

205
00:11:53,140 --> 00:11:53,920
好的

206
00:11:53,920 --> 00:11:59,540
我们不要忘记在此添加下划线，以接受在此创建的对象。

207
00:11:59,640 --> 00:12:07,210
因此，我将在此处选择这三行，这会将字符串转换为三个数字。

208
00:12:07,210 --> 00:12:08,680
好吧，执行得很好。

209
00:12:08,680 --> 00:12:10,510
现在让我们看一下X。

210
00:12:10,600 --> 00:12:11,350
开始了。

211
00:12:11,410 --> 00:12:12,330
就是这样。

212
00:12:12,460 --> 00:12:15,070
如您所见，朋友变成了0。

213
00:12:15,100 --> 00:12:18,910
西班牙成为2，德国成为1。

214
00:12:18,910 --> 00:12:19,320
好吧。

215
00:12:19,370 --> 00:12:23,210
现在，让我们来关注第二个类别变量，即性别变量。

216
00:12:23,220 --> 00:12:28,210
我们将执行与此处完全相同的操作，但只使用一个新对象。

217
00:12:28,210 --> 00:12:36,850
因此，我将复制此副本并将其粘贴到此处，在这里我不仅会更改标签的名称

218
00:12:36,850 --> 00:12:41,700
以及将由标签和代码x替换的代码或对象。

219
00:12:41,860 --> 00:12:42,620
对。

220
00:12:42,640 --> 00:12:45,700
并且不要忘了在这里也应用它。

221
00:12:45,790 --> 00:12:51,340
当然，我们需要在此处更改与自变量的索引相对应的索引

222
00:12:51,370 --> 00:12:56,660
我们要编码，因此当然是索引号2 0 1和2。

223
00:12:56,890 --> 00:13:01,720
好吧，所以我们在这里一换二，也一样。

224
00:13:01,790 --> 00:13:02,070
对。

225
00:13:02,160 --> 00:13:06,800
到此，我们只需要选择它并执行即可。

226
00:13:06,890 --> 00:13:07,650
好吧。

227
00:13:07,720 --> 00:13:10,490
现在让我们在这里看一下x x。

228
00:13:10,660 --> 00:13:11,480
开始了。

229
00:13:11,530 --> 00:13:18,370
如您所见，女性成为零，男性成为本课程的女士之一，这一点不会受到冒犯

230
00:13:18,820 --> 00:13:20,950
但这纯粹是随机的。

231
00:13:20,950 --> 00:13:26,530
好吧，现在我们需要再做一件事，这当然与我们绝对的

232
00:13:26,530 --> 00:13:28,620
变量不是序数。

233
00:13:28,630 --> 00:13:33,720
这意味着类别变量的类别之间没有关系顺序。

234
00:13:33,760 --> 00:13:39,520
也就是说，您知道法国不高于德国，德国和法国，而西班牙和

235
00:13:39,520 --> 00:13:41,620
德国，西班牙和法国。

236
00:13:41,620 --> 00:13:47,020
好的，就像我们在第1部分中所做的一样，我们需要为此分类变量创建虚拟变量

237
00:13:47,260 --> 00:13:53,410
而且我们只会针对该国家/地区的分类变量执行此操作，因为它包含三个类别

238
00:13:53,680 --> 00:13:55,770
这包含两个类别。

239
00:13:55,870 --> 00:14:01,270
因此，既然谁将删除一列以避免很好地避免虚拟变量陷阱，那么这样做将毫无用处

240
00:14:01,270 --> 00:14:03,120
为此创建一个虚拟变量。

241
00:14:03,190 --> 00:14:04,690
因此，让我们为此做一个。

242
00:14:04,720 --> 00:14:10,280
我们已经在这里准备了所有的内容，其中一个热门的编码类将创建这些内容

243
00:14:10,480 --> 00:14:11,410
变量。

244
00:14:11,470 --> 00:14:16,060
我们甚至不需要更改索引，因为它对应于我们列的正确索引

245
00:14:16,060 --> 00:14:18,650
要为其创建虚拟变量。

246
00:14:18,740 --> 00:14:20,470
确实，那是索引一。

247
00:14:20,470 --> 00:14:28,150
好吧，基本上我们已经准备好了，我们可以在这里选择创建虚拟变量。

248
00:14:28,170 --> 00:14:28,750
好吧。

249
00:14:28,760 --> 00:14:30,630
做得好。

250
00:14:30,640 --> 00:14:35,680
现在我们来看看X，实际上从现在开始，所有列都具有相同的类型。

251
00:14:35,770 --> 00:14:41,260
我们可以从这里看X，因为类型不再是对象，而是浮点数64。

252
00:14:41,410 --> 00:14:48,640
因此，让我们看一下，我们可以清楚地看到特征矩阵的所有独立变量。

253
00:14:48,640 --> 00:14:53,300
好的，现在我们有了12个Nepenthe大理石，因为我们有了三个新的虚拟变量。

254
00:14:53,330 --> 00:14:55,320
我们将非常快速地更改格式。

255
00:14:55,540 --> 00:14:56,630
零。

256
00:14:56,950 --> 00:14:57,640
好。

257
00:14:57,850 --> 00:15:01,100
好的，这些是对应于国家/地区的三个虚拟变量。

258
00:15:01,270 --> 00:15:06,270
然后，我们得到了信用评分，然后是与性别相对应的分类变量

259
00:15:06,490 --> 00:15:08,560
然后是其他自变量。

260
00:15:08,560 --> 00:15:09,370
太好了。

261
00:15:09,430 --> 00:15:16,330
但是现在我们将在此处删除一个变量，以避免陷入虚拟变量陷阱。

262
00:15:16,330 --> 00:15:17,610
好的，让我们现在就开始做。

263
00:15:17,620 --> 00:15:19,710
这将是非常快速和容易的。

264
00:15:19,720 --> 00:15:27,730
我们采用特征X的矩阵，并将采用该矩阵的所有行以及所有

265
00:15:27,730 --> 00:15:34,420
除第一个列之外的列，为此，我从索引1中获取了所有列，它们对应于

266
00:15:34,420 --> 00:15:37,810
到第二列，直到最后一列的最后一个索引。

267
00:15:37,810 --> 00:15:38,170
好吧。

268
00:15:38,170 --> 00:15:39,280
这样就可以了。

269
00:15:39,280 --> 00:15:41,790
我要这样说并执行。

270
00:15:41,980 --> 00:15:47,820
现在，您可以看到，对于一个伟大的国家，我们只有两个变量。

271
00:15:47,860 --> 00:15:49,720
所以只不过是言语陷阱。

272
00:15:49,720 --> 00:15:50,330
好吧。

273
00:15:50,440 --> 00:15:51,440
所以我们很好。

274
00:15:51,550 --> 00:15:56,590
我们准备将数据集分为训练集和测试集。

275
00:15:56,710 --> 00:15:58,740
这正是我们在本节中所做的。

276
00:15:58,750 --> 00:15:59,930
一切都准备好了。

277
00:16:00,040 --> 00:16:04,200
您可能会知道，我们可能会将测试大小更改为0.2。

278
00:16:04,270 --> 00:16:09,970
然后对8000个观测值进行测试并测试性能和2000个观测值。

279
00:16:09,970 --> 00:16:11,110
所以做吧。

280
00:16:11,110 --> 00:16:15,000
我将在此处选择三行并执行。

281
00:16:15,070 --> 00:16:19,110
在这里，我们得到了一些新的东西，我们得到了弃用警告，这是很好的。

282
00:16:19,120 --> 00:16:22,510
仅仅是因为Spider的日期是最新版本。

283
00:16:22,510 --> 00:16:24,260
并在此最新版本中。

284
00:16:24,520 --> 00:16:31,420
好吧，这里的交叉验证包被道德选择所取代。

285
00:16:31,420 --> 00:16:37,040
因此，基本上可以避免此警告，这很好，可以在测试集中完美地创建训练集。

286
00:16:37,150 --> 00:16:45,070
但是为了避免警告，我们只需要在此通过模型选择来代替交叉验证。

287
00:16:45,220 --> 00:16:45,660
好吧。

288
00:16:45,750 --> 00:16:53,110
现在，如果我像这样进行研究并像您看到的那样执行，警告就会消失。

289
00:16:53,150 --> 00:16:53,510
好吧。

290
00:16:53,530 --> 00:16:54,470
很高兴知道。

291
00:16:54,640 --> 00:16:58,270
这对于避免将来的错误很有用。

292
00:16:58,270 --> 00:16:58,570
好吧。

293
00:16:58,580 --> 00:17:00,280
现在该进行功能Schelling。

294
00:17:00,280 --> 00:17:05,410
我们是否需要像您刚进入人工神经网络和一般深度学习一样。

295
00:17:05,410 --> 00:17:07,940
好吧，答案是肯定的。

296
00:17:07,990 --> 00:17:13,870
那是完全强制性的，这是因为您会知道很多抵触

297
00:17:13,870 --> 00:17:17,920
除并行计算外，还需要大量计算密集型计算。

298
00:17:18,010 --> 00:17:22,050
因此，我们需要应用将来的缩放比例来简化这些计算。

299
00:17:22,060 --> 00:17:25,830
此外，我们不想让一个独立变量主导另一个变量。

300
00:17:25,870 --> 00:17:31,770
因此非常重要，我们需要应用真正强制性的功能，所以让我们开始吧。

301
00:17:31,780 --> 00:17:32,980
一切准备就绪。

302
00:17:32,980 --> 00:17:35,410
我不需要更改任何内容。

303
00:17:35,590 --> 00:17:43,660
因此，让我们执行所有未正确完成的警告功能，我们可以快速了解一下极端

304
00:17:43,680 --> 00:17:44,190
这里。

305
00:17:44,380 --> 00:17:46,750
如您所见，所有自变量均已缩放。

306
00:17:46,930 --> 00:17:49,650
测试集也是如此。

307
00:17:49,810 --> 00:17:51,440
一切都按比例缩放。

308
00:17:51,460 --> 00:17:52,780
我们都很好。

309
00:17:52,870 --> 00:17:59,890
我们的数据没有经过很好的预处理，现在我非常兴奋，因为我们即将开始构建

310
00:18:00,370 --> 00:18:02,440
人工神经网络。

311
00:18:02,500 --> 00:18:07,780
这将成为我们现在正在使用的机器学习中最强大的工具之一

312
00:18:08,170 --> 00:18:11,710
如果您需要将它们应用到工作中，我相信它将非常有用。

313
00:18:11,980 --> 00:18:14,370
因此，我们将在下一个Statoil中做到这一点。

314
00:18:14,380 --> 00:18:16,530
在那之前享受机器学习

