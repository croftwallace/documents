1
00:00:00,240 --> 00:00:02,920
您好，欢迎来到本Python教程。

2
00:00:03,000 --> 00:00:08,640
因此，我们只是在火车上训练了人工神经网络，现在是时候进行预测和

3
00:00:08,630 --> 00:00:09,500
测试集。

4
00:00:09,720 --> 00:00:13,090
好是我们在这里准备好了一切。

5
00:00:13,110 --> 00:00:18,060
实际上，我们无需更改任何内容即可做出预测，因为即使我们进行了此分类

6
00:00:18,060 --> 00:00:23,340
胡萝卜的对象，然后sikat学习好了，有相同的预测方法可以进行预测

7
00:00:23,340 --> 00:00:24,430
在测试集上。

8
00:00:24,570 --> 00:00:32,300
因此，我们可以直接选择该行并执行以获得预测的概率等级。

9
00:00:32,310 --> 00:00:33,360
让我们来看一下。

10
00:00:33,420 --> 00:00:34,860
为什么pred在这里。

11
00:00:34,890 --> 00:00:36,450
让我们加倍考虑。

12
00:00:36,450 --> 00:00:37,040
开始了。

13
00:00:37,230 --> 00:00:42,360
这就是测试集的2000个客户带来的所有可能性。

14
00:00:42,360 --> 00:00:48,150
因此，例如，如果您将第一个概率看成20％，则意味着

15
00:00:48,240 --> 00:00:53,880
此处索引为零的测试集的客户有20％的机会离开银行。

16
00:00:53,880 --> 00:00:59,280
因此，在测试集上做出这些预测对于我们评估测试系统的性能将很有趣。

17
00:00:59,280 --> 00:01:05,370
该模型基于新观测值，因为我们在上一教程中获得的精度与

18
00:01:05,370 --> 00:01:06,500
在训练集上。

19
00:01:06,600 --> 00:01:09,500
但是现在，我们正在对新观察结果做出一些预测。

20
00:01:09,630 --> 00:01:14,580
因此，非常有趣的是，看看这种精度是否会与在计算机上获得的精度一样好。

21
00:01:14,580 --> 00:01:18,330
培训站点，我们将根据您的观察获得这种准确性。

22
00:01:18,330 --> 00:01:21,750
由于我们将在后面讨论混淆矩阵。

23
00:01:21,990 --> 00:01:27,140
然后，如果我们在测试集上获得良好的准确性，则可以知道接近86％。

24
00:01:27,180 --> 00:01:29,200
我们在训练集上获得的那个。

25
00:01:29,340 --> 00:01:31,200
好吧，这将验证模型。

26
00:01:31,230 --> 00:01:36,380
因此，下一个对银行来说非常有趣的事情是使用我们刚刚验证过的模型

27
00:01:36,390 --> 00:01:39,630
对银行客户进行测试。

28
00:01:39,930 --> 00:01:45,900
然后，银行将能够对银行的所有客户进行道德操守，并通过对概率进行排名

29
00:01:45,900 --> 00:01:52,010
从最高到最低，它对最有可能离开银行的客户进行排名。

30
00:01:52,170 --> 00:01:56,940
因此，例如，银行要查看其客户的10％最高概率

31
00:01:56,940 --> 00:02:02,790
离开银行，因此将其细分，然后借助数据挖掘技术进行更深入的分析

32
00:02:03,060 --> 00:02:07,750
了解为什么该细分市场的客户最有可能离开银行。

33
00:02:07,800 --> 00:02:13,470
因此，总体而言，我们制作的人工神经网络为银行创造了很多附加值

34
00:02:13,680 --> 00:02:19,380
因为针对这些客户最有可能离开银行，那么银行本身可以采取一些措施

35
00:02:19,650 --> 00:02:22,010
以防止这些客户离开。

36
00:02:22,260 --> 00:02:26,050
因此，现在让我们希望我们的模型能够在测试集下得到验证。

37
00:02:26,250 --> 00:02:28,010
这就是我们现在将要看到的。

38
00:02:28,050 --> 00:02:30,180
感谢混乱矩阵。

39
00:02:30,180 --> 00:02:32,200
好的，我将在此处按“确定”。

40
00:02:32,460 --> 00:02:35,850
因此，让我们看一下混淆矩阵的结果。

41
00:02:35,850 --> 00:02:42,390
但是，在执行此操作之前，我们必须谨慎对待此预测方法返回的概率

42
00:02:42,570 --> 00:02:47,840
客户离开银行，为了使用此计算机指标，我们不需要概率

43
00:02:47,880 --> 00:02:50,640
但是我们需要表格中的预测结果。

44
00:02:50,640 --> 00:02:52,030
对或错。

45
00:02:52,080 --> 00:02:58,140
因此，我们只需要在此处做一些事情即可将这些概率转换为预测结果

46
00:02:58,220 --> 00:02:58,820
的形式。

47
00:02:58,820 --> 00:03:00,030
对或错。

48
00:03:00,060 --> 00:03:06,030
为此，我们需要选择一个阈值来确定何时预测结果为1，何时预测结果为

49
00:03:06,030 --> 00:03:07,650
预测结果为零。

50
00:03:07,830 --> 00:03:12,550
因此，您知道我们预测阈值以上为1，而预测阈值以下为零。

51
00:03:12,690 --> 00:03:17,290
当然，取的自然阈值为0.5 50％。

52
00:03:17,310 --> 00:03:22,830
在医学上，如果我们必须预测的是敏感信息，例如

53
00:03:22,830 --> 00:03:25,920
例如，如果我们必须预测肿瘤是否是恶性的。

54
00:03:26,040 --> 00:03:30,190
但是在这里，我们只是在预测客户是要离开银行还是留在银行。

55
00:03:30,270 --> 00:03:32,270
所以50％的特雷塞尔很好。

56
00:03:32,370 --> 00:03:34,620
这就是这里的真实门槛。

57
00:03:34,620 --> 00:03:35,260
好吧。

58
00:03:35,340 --> 00:03:42,970
因此，我们现在要使用的技巧是您知道更新预测概率的向量y分布。

59
00:03:43,230 --> 00:03:50,210
所以等于，然后这个技巧是在这里和我们加y的括号内添加一些括号

60
00:03:50,260 --> 00:04:01,300
Pret大于0点5，并且这里的语法等效，就好像y大于0.5则它

61
00:04:01,300 --> 00:04:07,330
返回true，如果y不大于0.5，则返回false。

62
00:04:07,330 --> 00:04:08,500
因此，让我们检查一下。

63
00:04:08,530 --> 00:04:11,740
我将选择此行并执行。

64
00:04:11,770 --> 00:04:13,770
好的，现在为什么传播会更新。

65
00:04:13,900 --> 00:04:17,820
现在，如果我们看看Wybert，就会发现我们以表格的形式得到了结果。

66
00:04:17,830 --> 00:04:19,300
错误或正确。

67
00:04:19,300 --> 00:04:24,820
因此，测试集的第一批客户不会根据模型和客户离开银行

68
00:04:24,820 --> 00:04:26,280
在测试集中排名第六。

69
00:04:26,350 --> 00:04:29,510
按照他们的全部离开银行。

70
00:04:29,590 --> 00:04:34,730
因此，现在有了这个论坛，我们可以执行此代码来获取混淆矩阵。

71
00:04:34,990 --> 00:04:36,040
让我们来看一下。

72
00:04:36,040 --> 00:04:39,820
我将在这里选择这两行并执行。

73
00:04:39,820 --> 00:04:40,520
开始了。

74
00:04:40,520 --> 00:04:41,840
执行正确。

75
00:04:42,010 --> 00:04:46,570
因此，现在让我们看一下结果，看看正确的预测数和

76
00:04:46,570 --> 00:04:47,930
错误的预测。

77
00:04:48,010 --> 00:04:51,580
然后最终是新观测值的准确性。

78
00:04:51,580 --> 00:04:52,590
让我们来看看。

79
00:04:52,840 --> 00:05:04,000
因此，在2000年的新观测结果中，我们得到1550个50加175个正确的预测和230个加45个不正确的预测

80
00:05:04,090 --> 00:05:04,960
预测。

81
00:05:05,020 --> 00:05:06,430
这样看起来真的很好。

82
00:05:06,550 --> 00:05:09,140
由于准确性，我们现在将确认。

83
00:05:09,310 --> 00:05:14,820
因此，让我们在此处按“确定”，然后计算将在此处在控制台中计算出的精度。

84
00:05:14,860 --> 00:05:19,900
因此，准确度是正确预测的数量除以预测的总数。

85
00:05:19,900 --> 00:05:27,460
因此，让我们看一下，我们将在括号中放入正确的预测数1550

86
00:05:28,180 --> 00:05:32,170
加上175个正确的预测。

87
00:05:32,320 --> 00:05:36,070
然后，将这个数字除以测试集中的预测总数。

88
00:05:36,220 --> 00:05:37,730
那是2000。

89
00:05:37,930 --> 00:05:39,090
而我们得到什么。

90
00:05:39,160 --> 00:05:44,420
我们的准确性为86％。

91
00:05:44,440 --> 00:05:51,040
很棒的观察结果是我们没有训练人工神经网络的观察结果。

92
00:05:51,250 --> 00:05:54,300
好吧，我们的准确度达到86％。

93
00:05:54,550 --> 00:05:57,970
此外，我们在没有艺术家的情况下也得到了这种预测。

94
00:05:58,060 --> 00:06:01,050
我的意思是说我们没有做任何参数调整。

95
00:06:01,270 --> 00:06:04,350
因此，也许我们仍然可以获得更好的准确性。

96
00:06:04,540 --> 00:06:10,150
但是86％的确非常好，因为它与我们在训练集上获得的精度一样高

97
00:06:10,480 --> 00:06:12,650
但在这里根据测试集获得。

98
00:06:12,850 --> 00:06:18,520
因此，最终我们可以验证我们的模型，现在银行可以使用它来对其客户进行排名

99
00:06:18,790 --> 00:06:23,530
根据他们从可能性最高的客户离开银行的可能性进行排名

100
00:06:23,530 --> 00:06:27,820
将银行留给最有可能离开银行的客户。

101
00:06:28,030 --> 00:06:34,930
建立了您的第一个人工神经网络，完成了如此伟大的任务并表示祝贺。

102
00:06:34,960 --> 00:06:39,530
那是本节的结尾，下一节将讨论卷积神经网络。

103
00:06:39,530 --> 00:06:42,890
深度学习的另一个非常令人兴奋和强大的分支。

104
00:06:42,910 --> 00:06:44,590
因此，我期待与您相会。

105
00:06:44,620 --> 00:06:46,460
在那之前享受机器学习

