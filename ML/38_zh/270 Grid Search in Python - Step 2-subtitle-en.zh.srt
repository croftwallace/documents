1
00:00:00,270 --> 00:00:02,670
您好，欢迎来到本Python教程。

2
00:00:02,760 --> 00:00:05,440
因此，让我们继续进行网格搜索实现。

3
00:00:05,490 --> 00:00:11,760
因此，现在我们建立了这个字典参数列表，基本上包含三个不同的

4
00:00:11,820 --> 00:00:18,420
网格搜索将调查的选项，以最终找到最佳选项

5
00:00:18,420 --> 00:00:19,530
参数。

6
00:00:19,530 --> 00:00:25,980
好了，现在我们唯一要做的就是使用此网格搜索功能找到这些最优

7
00:00:25,980 --> 00:00:27,050
参数。

8
00:00:27,150 --> 00:00:28,140
因此，让我们开始吧。

9
00:00:28,160 --> 00:00:32,920
在这些参数列表之后，我们将立即执行此操作。

10
00:00:32,940 --> 00:00:33,620
好吧。

11
00:00:33,680 --> 00:00:39,780
因此，现在我们要做的是创建足够数量的网格搜索类，然后我们将

12
00:00:39,780 --> 00:00:42,620
将此对象适合我们的训练集。

13
00:00:42,630 --> 00:00:43,260
因此，让我们开始吧。

14
00:00:43,260 --> 00:00:50,900
我们将调用此对象网格搜索，然后他调用，然后由于该对象是的对象

15
00:00:50,900 --> 00:00:52,640
网格搜索请参见B级。

16
00:00:52,640 --> 00:00:58,110
现在，我们需要做的是使用网格搜索C-v类。

17
00:00:58,120 --> 00:00:59,300
那是课程。

18
00:00:59,300 --> 00:01:02,180
现在我们需要输入一些参数。

19
00:01:02,180 --> 00:01:08,580
因此，第一个参数是我们的估算器，这样称为估算器。

20
00:01:08,780 --> 00:01:13,970
所以基本上这是我们的机器学习模型，无论是回归模型还是分类

21
00:01:13,970 --> 00:01:15,990
道德或任何其他类型的模型。

22
00:01:16,160 --> 00:01:23,110
由于我们的模型基本上被称为分类器，因此这里的估计参数是

23
00:01:23,150 --> 00:01:25,500
等于分类器。

24
00:01:25,670 --> 00:01:32,230
好的下一个参数下一个参数是parum下划线gred。

25
00:01:32,480 --> 00:01:38,330
多数民众赞成，基本上，此参数是包含此线性选项的不同选项的列表

26
00:01:38,480 --> 00:01:44,990
带有线性核和惩罚参数的不同选项，参见非线性

27
00:01:45,050 --> 00:01:50,930
带有非线性核或B.F.的选项，以及惩罚参数的不同选项，请参见和

28
00:01:50,930 --> 00:01:56,170
还有gamma参数的不同选项，这是内核函数的更正。

29
00:01:56,180 --> 00:02:02,150
因此，这里基本上我们需要将parum grid equals参数放入。

30
00:02:02,210 --> 00:02:02,840
好吧。

31
00:02:02,840 --> 00:02:05,900
第二个参数完成，现在第三个参数。

32
00:02:05,900 --> 00:02:13,100
第三个参数是您要用来决定最佳参数的得分指标。

33
00:02:13,100 --> 00:02:19,130
因为您知道网格搜索将根据一个性能指标选择最佳参数

34
00:02:19,490 --> 00:02:22,910
它可以是精度，也可以是召回率。

35
00:02:22,940 --> 00:02:24,980
它可以是不同的性能指标。

36
00:02:25,100 --> 00:02:29,410
而且，既然您知道我们可以拥有一个比另一个模型具有更高准确性的模型。

37
00:02:29,570 --> 00:02:35,090
但是，如果我们采用另一个性能指标，它的性能可能会较低，因此我们需要指定

38
00:02:35,240 --> 00:02:40,130
得分指标，我们将采用最常见的指标，就像我们对深度学习所做的一样

39
00:02:40,130 --> 00:02:45,790
我们还必须选择性能指标，然后选择要实现的精度

40
00:02:46,090 --> 00:02:47,930
那就是我们要在这里做的。

41
00:02:47,960 --> 00:02:49,470
因此，让我们做吧。

42
00:02:49,540 --> 00:02:58,770
计分等于并且报价的准确性是晴雨表的完美。

43
00:02:58,840 --> 00:03:01,790
现在第四个参数是。

44
00:03:02,320 --> 00:03:07,240
因此，您可能已经猜到国家的KK。

45
00:03:07,240 --> 00:03:12,970
当然，这意味着网格搜索将评估每个模型及其性能的性能。

46
00:03:12,970 --> 00:03:14,900
自己的一组参数。

47
00:03:15,100 --> 00:03:20,770
当然，在评估这些模型的准确性时，将通过仔细的交叉验证来做到这一点。

48
00:03:21,010 --> 00:03:26,740
因为正如我们在上一教程中看到的那样，“好Caple交叉验证”部分的第一篇教程

49
00:03:26,860 --> 00:03:30,720
是评估模型性能的相关方法。

50
00:03:30,850 --> 00:03:37,810
因此，当然不会基于采用

51
00:03:37,810 --> 00:03:39,440
一项测试的准确性。

52
00:03:39,640 --> 00:03:45,180
这将需要几个精度，更准确地说是10个精度，因为我们要输入，因为

53
00:03:45,200 --> 00:03:51,400
一次又一次地意味着意义，因此它将获得更多相关的绩效指标。

54
00:03:51,490 --> 00:04:00,240
因此CV等于10，因此将通过网格搜索应用十倍交叉验证。

55
00:04:00,250 --> 00:04:00,820
好吧。

56
00:04:00,820 --> 00:04:03,760
实际上这就是网格搜索的全部内容。

57
00:04:03,760 --> 00:04:10,390
如果您正在处理非常大的数据集，那么您可以做的就是添加我们也看到的最后一个参数

58
00:04:10,600 --> 00:04:14,960
在K4交叉验证中，这是记忆和工作。

59
00:04:15,130 --> 00:04:20,770
而且，如果您正在处理非常大的数据集，那么执行网格搜索将花费相当长的时间

60
00:04:20,890 --> 00:04:25,900
因为您知道它正在测试一些不同的选项，这些选项基本上可以为

61
00:04:25,900 --> 00:04:31,270
您的问题涉及大数据集，因此应该从中获得所有可用的功能

62
00:04:31,270 --> 00:04:32,170
您的机器。

63
00:04:32,350 --> 00:04:38,350
因此，我只是在此处添加此最终工作晴雨表，并将其设置为减一，以防您在以下位置使用此代码

64
00:04:38,350 --> 00:04:40,240
大数据集。

65
00:04:40,240 --> 00:04:45,000
好的，这样就可以为网格搜索功能或网格搜索对象做好准备。

66
00:04:45,160 --> 00:04:50,170
现在，我们可以使用它来使其适合我们的训练集。

67
00:04:50,170 --> 00:05:00,410
那么，我们该如何处理网格搜索对象呢？我们可以先复制它，然后等于它，然后再取它

68
00:05:00,440 --> 00:05:07,410
点，然后我们像往常一样应用fit方法将对象拟合到训练集或

69
00:05:07,440 --> 00:05:08,730
任何类型的数据集。

70
00:05:08,940 --> 00:05:12,080
然后在括号中输入训练集。

71
00:05:12,180 --> 00:05:15,650
因此，火车组由X火车和y火车组成。

72
00:05:15,660 --> 00:05:21,260
因此，在这里我们需要放置额外的N和Y火车。

73
00:05:21,960 --> 00:05:27,590
然后我们开始将网格搜索对象拟合到训练集中。

74
00:05:27,720 --> 00:05:28,410
完善。

75
00:05:28,410 --> 00:05:32,300
因此，我们已经可以尝试执行此操作。

76
00:05:32,370 --> 00:05:36,630
首先，我们将网格搜索导入为class。

77
00:05:36,630 --> 00:05:38,230
因此，让我们开始吧。

78
00:05:38,230 --> 00:05:41,060
在这里，我们去网格搜索导入的城市类。

79
00:05:41,270 --> 00:05:48,300
现在，让我们定义将要通过网格搜索调查的参数集。

80
00:05:48,300 --> 00:05:50,570
那么如何再次得到这个。

81
00:05:50,850 --> 00:05:51,430
大。

82
00:05:51,430 --> 00:05:59,160
现在，我们将网格搜索功能与所选参数一起使用，并执行此操作。

83
00:05:59,160 --> 00:06:01,460
在这里，我们准备好网格搜索功能。

84
00:06:01,590 --> 00:06:06,630
现在我们已经准备好将网格搜索对象适合火车组。

85
00:06:06,660 --> 00:06:12,900
因此，让我们执行它，您会看到它花了大约一两秒钟，但是我们的数据

86
00:06:12,900 --> 00:06:13,780
设置很小。

87
00:06:13,830 --> 00:06:20,160
因此，如果您有大数据集，则可能需要更长的时间，但请确保输入此Jobs参数

88
00:06:20,160 --> 00:06:22,280
并将其设置为负1。

89
00:06:22,440 --> 00:06:22,950
大。

90
00:06:22,950 --> 00:06:26,600
因此，现在基本上实现了网格搜索。

91
00:06:26,660 --> 00:06:33,120
因此，现在我们最感兴趣的是查看结果，因此做到这一点非常容易

92
00:06:33,120 --> 00:06:39,690
承担网格搜索对象并使用一些属性来获得最佳选择

93
00:06:39,690 --> 00:06:45,330
参数，以及通过此选择找到的最佳准确性得分。

94
00:06:45,330 --> 00:06:48,970
因此，让我们首先实际获得最佳准确性得分。

95
00:06:49,110 --> 00:06:58,590
因此，要获得最佳精度，那么我们在这里定义一个新变量，我们称之为最佳精度然后等于。

96
00:06:58,590 --> 00:07:08,820
现在，就像我刚才说的那样，我们先选择网格搜索对象，再点一个点，然后使用best score属性

97
00:07:09,150 --> 00:07:12,480
并且我们需要像这样最后加上下划线。

98
00:07:12,660 --> 00:07:15,450
因此，这将为我们提供最佳分数，我们可以对其进行检查。

99
00:07:15,480 --> 00:07:18,800
我将选择此行并正确执行。

100
00:07:18,840 --> 00:07:20,230
最佳精度。

101
00:07:20,240 --> 00:07:22,240
是百分之九十。

102
00:07:22,320 --> 00:07:23,130
这样很好。

103
00:07:23,130 --> 00:07:28,840
它不是仅在一组上测得的精度，而是10的平均值。

104
00:07:28,840 --> 00:07:35,550
通过K4交叉验证十倍交叉验证来测量准确性，我们获得9％的准确性

105
00:07:35,550 --> 00:07:37,130
真的很好

106
00:07:37,230 --> 00:07:41,540
这就是这些参数的最佳选择。

107
00:07:41,640 --> 00:07:46,450
很好，我们知道这需要一队女孩，他们将立即得到确认。

108
00:07:46,560 --> 00:07:51,630
但是，随后还采用了最佳座位惩罚参数C和最佳伽玛。

109
00:07:51,660 --> 00:07:55,120
因此，让我们看看这些参数是什么来获取这些参数。

110
00:07:55,120 --> 00:08:04,880
好吧，让我们定义一个新的变量最佳参数，然后等于，然后再次进行网格搜索

111
00:08:04,970 --> 00:08:06,990
对象然后什么。

112
00:08:07,070 --> 00:08:13,040
然后，我们采用最佳程序属性，该属性将为我们提供找到的最佳参数列表

113
00:08:13,160 --> 00:08:14,540
通过网格搜索。

114
00:08:14,540 --> 00:08:22,160
所以在这里，我们添加最佳下划线程序，然后再次下划线。

115
00:08:22,170 --> 00:08:22,770
好吧。

116
00:08:22,770 --> 00:08:23,390
完善。

117
00:08:23,430 --> 00:08:24,180
准备。

118
00:08:24,180 --> 00:08:27,580
我们将知道解决问题的最佳参数。

119
00:08:27,690 --> 00:08:33,870
而且不仅会知道我们应该使用非线性模型还是线性模型，我们已经知道

120
00:08:33,870 --> 00:08:35,400
将是一个非线性模型。

121
00:08:35,400 --> 00:08:37,060
那是作为VM的内核。

122
00:08:37,110 --> 00:08:42,660
但是接下来，我们最感兴趣的是什么，在那之前我们不知道的是第3部分

123
00:08:42,870 --> 00:08:48,320
内核作为YEM是C的最佳值和gamma参数的最佳值。

124
00:08:48,330 --> 00:08:50,120
因此，让我们了解一下。

125
00:08:50,130 --> 00:08:52,030
我要问你这个。

126
00:08:52,050 --> 00:08:54,750
在这里，什么是最好的参数。

127
00:08:54,870 --> 00:08:57,780
这些是C参数的一个。

128
00:08:57,780 --> 00:09:01,180
我们很幸运，因为这实际上是默认值。

129
00:09:01,200 --> 00:09:02,510
与gamma参数相同。

130
00:09:02,520 --> 00:09:04,350
那也是0.5。

131
00:09:04,350 --> 00:09:05,620
所以我们也很幸运。

132
00:09:05,670 --> 00:09:12,120
当然，它是一个RPF内核，这意味着最适合问题的模型是非线性的

133
00:09:12,120 --> 00:09:12,780
模型。

134
00:09:12,990 --> 00:09:13,710
这样很好。

135
00:09:13,740 --> 00:09:17,950
因此，我们已经知道该模型的结果，我们将不再对其进行可视化。

136
00:09:18,120 --> 00:09:23,730
但是，如果您想进一步提高自己的工作效率，那么您可以做些什么

137
00:09:23,730 --> 00:09:29,490
再次为该参数尝试一些更准确的值，因为现在我们知道最佳值

138
00:09:29,490 --> 00:09:32,130
伽玛值约为0.5。

139
00:09:32,160 --> 00:09:37,500
所以我们实际上不需要0.01 1 0 1和0点0 1。

140
00:09:37,650 --> 00:09:55,880
因此，我们在这里可以更加准确，例如选择0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8和0.9。

141
00:09:56,220 --> 00:10:00,590
然后您知道我们只需要再次选择即可。

142
00:10:00,890 --> 00:10:07,120
关于网格搜索的所有部分都将对参数的新选项进行一些搜索。

143
00:10:07,170 --> 00:10:13,690
因此，如果再次执行此操作，则将获得新的最佳精度和新的参数最佳选择。

144
00:10:13,690 --> 00:10:18,050
因此，让我们看看这些最佳精度是什么，现在90％相同。

145
00:10:18,080 --> 00:10:19,830
最好的参数是什么。

146
00:10:19,830 --> 00:10:24,660
好吧，您可以看到0.7甚至比0.5更好。

147
00:10:24,840 --> 00:10:30,170
这就是说，如果您想推动工作以进一步提高性能，那么您将得到

148
00:10:30,260 --> 00:10:34,210
gamma参数的值为0.7。

149
00:10:34,210 --> 00:10:35,950
好吧，让我们按OK。

150
00:10:36,010 --> 00:10:40,450
现在，您知道了如何通过参数作弊来提高模型性能。

151
00:10:40,840 --> 00:10:42,270
这就是本节的内容。

152
00:10:42,280 --> 00:10:47,260
我希望它能回答您剩余的问题，当然，如果您还有其他问题，可以

153
00:10:47,260 --> 00:10:49,150
在Q Any中问他们。

154
00:10:49,150 --> 00:10:54,460
现在我们几乎快要结束本课程了，因为下一部分将是奖金部分

155
00:10:54,460 --> 00:10:56,080
关于前GI的提升。

156
00:10:56,080 --> 00:11:00,760
机器学习中最强大的模型之一，我期待实现最后一个模型

157
00:11:00,760 --> 00:11:02,560
与您在下一节中。

158
00:11:02,590 --> 00:11:04,240
在此之前，请享受机器学习。

