1
00:00:00,360 --> 00:00:02,850
您好，欢迎来到本Python教程。

2
00:00:02,850 --> 00:00:08,670
如此一来，我们刚刚解决了业务问题，我们还通过准备数据来预处理了数据集

3
00:00:08,670 --> 00:00:10,900
功能矩阵已经是无价的。

4
00:00:10,950 --> 00:00:15,600
将数据分为测试的两件事，我们最终应用了将来的扩展

5
00:00:15,600 --> 00:00:21,210
是BCA所必需的，现在在Statoil中，我们将应用第一个降维

6
00:00:21,210 --> 00:00:24,240
技术主成分分析。

7
00:00:24,240 --> 00:00:26,630
因此，让我们照常做。

8
00:00:26,670 --> 00:00:31,590
我们需要做的第一件事是导入正确的包，更准确地说是正确的类

9
00:00:31,710 --> 00:00:37,680
使用BTA，因为像往常一样，我们将导入一个类，然后创建该类的对象，然后

10
00:00:37,680 --> 00:00:42,810
我们将使用我们要处理的这个繁忙对象的经典Ficke变换和变换方法

11
00:00:42,810 --> 00:00:46,650
分别创建训练集和测试。

12
00:00:46,710 --> 00:00:47,340
所以做吧。

13
00:00:47,340 --> 00:00:50,390
让我们从导入正确的类开始。

14
00:00:50,520 --> 00:00:56,410
因此，我们从标量和点分解中导入此类。

15
00:00:56,430 --> 00:00:57,810
这是第一个。

16
00:00:57,810 --> 00:00:58,310
开始了。

17
00:00:58,320 --> 00:01:04,780
然后导入，非常简单地将Pete C A导入首都。

18
00:01:04,820 --> 00:01:05,460
好吧。

19
00:01:05,490 --> 00:01:06,570
这就是我们的班级。

20
00:01:06,600 --> 00:01:11,790
现在，我们将创建此PCA类的新对象，并将其称为该对象

21
00:01:12,120 --> 00:01:20,730
PCa然后等于，然后在这里我们用大写字母然后加上括号来表示C A类。

22
00:01:21,000 --> 00:01:27,540
在这些括号内，我们将导入具有本数的主参数

23
00:01:27,540 --> 00:01:32,350
组件和此参数称为和类似的组件。

24
00:01:32,610 --> 00:01:37,270
因此，基本上这就是您想要获得的提取特征的数量。

25
00:01:37,320 --> 00:01:42,450
这将解释最多的变体，并取决于您要解释的变体

26
00:01:42,720 --> 00:01:45,600
您将选择正确数量的主成分。

27
00:01:45,660 --> 00:01:49,250
好吧，然后权利等于，这就是我们指定此数字的地方。

28
00:01:49,290 --> 00:01:54,540
但是现在的问题是，我们知道我们最终想要获得两个主要组成部分，以便能够

29
00:01:54,540 --> 00:02:00,750
可视化此训练集结果和测试结果，但我们不知道这两个差异有多大

30
00:02:00,750 --> 00:02:02,460
组件说明。

31
00:02:02,490 --> 00:02:03,920
所以我们需要检查一下。

32
00:02:03,930 --> 00:02:09,120
您知道我们需要确保解释最多变体的两个第一主成分

33
00:02:09,510 --> 00:02:13,520
不要将其解释为低方差，因此我们在此不提供输入。

34
00:02:13,680 --> 00:02:20,190
我们将不输入任何内容，因为然后我们将创建一个向量，我们将其称为解释方差

35
00:02:20,460 --> 00:02:25,280
我们将看到所有主要成分所解释的累积方差。

36
00:02:25,380 --> 00:02:29,170
因此，当我们看一下向量时，您会发现这将变得更加清晰。

37
00:02:29,190 --> 00:02:30,840
好的，让我们现在结束这个。

38
00:02:30,930 --> 00:02:32,900
这将创建我们的PCA对象。

39
00:02:33,030 --> 00:02:39,740
现在我们将使用该对象将方法应用于第五种转移方法以适合该对象

40
00:02:39,740 --> 00:02:44,730
到训练集，以便此对象可以看到训练集的结构以及因此如何

41
00:02:44,730 --> 00:02:50,130
它可以提取一些解释最大方差的新自变量，因此最终

42
00:02:50,130 --> 00:02:52,940
该对象将适合训练集。

43
00:02:53,160 --> 00:02:58,710
然后，一旦主题适应训练集，我们将仅使用transform方法进行变换

44
00:02:58,770 --> 00:03:02,040
以及作为X测试的测试。

45
00:03:02,040 --> 00:03:02,630
所以做吧。

46
00:03:02,630 --> 00:03:08,520
让我们首先将该对象填充到训练集中并同时转换训练。

47
00:03:08,520 --> 00:03:16,230
因此，我们采用由矩阵特征极值表示的训练集，然后等于

48
00:03:16,230 --> 00:03:19,210
然后拿走我们的PC对象。

49
00:03:19,260 --> 00:03:24,420
这就是我们使用转移方法的地方，这里按回车即可。

50
00:03:24,870 --> 00:03:33,330
您知道该怎么做，我们需要在此处输入X对训练集的特征矩阵进行训练。

51
00:03:33,330 --> 00:03:38,280
好的，这将适合我们的目标训练集并同时进行转换

52
00:03:38,490 --> 00:03:40,740
提取所有主要成分。

53
00:03:40,820 --> 00:03:44,660
现在，让我们对测试集进行相同的转换。

54
00:03:44,850 --> 00:03:52,470
因此，我们在这里进行测试，并在括号内将测试X进行测试。

55
00:03:52,470 --> 00:03:53,150
大。

56
00:03:53,160 --> 00:03:56,680
因此，现在说明已在此阶段完成。

57
00:03:56,910 --> 00:04:03,210
但是正如我告诉你的，我们需要看一下不同本金的累积解释方差

58
00:04:03,210 --> 00:04:11,190
组件，因此我们将创建一个解释方差向量，该向量将包含

59
00:04:11,380 --> 00:04:17,400
由此处提取的每个主要成分解释的方差百分比。

60
00:04:17,430 --> 00:04:22,720
因此，解释方差，然后诀窍是利用PC对象的自然美感。

61
00:04:22,740 --> 00:04:29,910
所以我们取对象PCa，然后我们要取的属性是Explained方差

62
00:04:30,000 --> 00:04:35,520
比率，这将为我们提供所有主要成分的列表，我们将获得百分比

63
00:04:35,580 --> 00:04:37,900
各自解释的差异。

64
00:04:38,220 --> 00:04:39,270
所以，让我们来。

65
00:04:39,270 --> 00:04:39,810
现在我们开始。

66
00:04:39,820 --> 00:04:40,870
准备好了

67
00:04:40,890 --> 00:04:44,910
现在我们可以看一下所有主要成分的解释差异。

68
00:04:44,910 --> 00:04:51,080
因此，让我们在这里进行所有这些步骤并执行Perfect的操作，您将正确地进行操作。

69
00:04:51,180 --> 00:04:55,920
因此，现在我们感兴趣的是Explained Varians向量。

70
00:04:55,920 --> 00:04:56,910
好吧。

71
00:04:56,910 --> 00:05:05,400
如您所见，因为我们最初有13个自变量，所以它提取了13个本金

72
00:05:05,400 --> 00:05:06,330
组件。

73
00:05:06,390 --> 00:05:11,730
所以这13个成分是自变量，但不是原始的自变量

74
00:05:11,730 --> 00:05:13,840
我们在数据集中拥有的

75
00:05:13,860 --> 00:05:18,910
这些是新提取的自变量，但解释最多。

76
00:05:18,930 --> 00:05:24,990
如您所见，它们是从解释最多方差的第一个主成分中排名的

77
00:05:25,350 --> 00:05:30,510
直到解释差异最小的第12个也是最后一个主成分。

78
00:05:30,510 --> 00:05:36,060
因此，这意味着如果我们包含一个可以解释37％的方差的主要成分

79
00:05:36,420 --> 00:05:44,480
那么如果我们采用两个主要成分来解释37加19等于方差的56％。

80
00:05:44,550 --> 00:05:51,870
然后，如果我们采用前三个主要成分来解释37加10:19那么11等于

81
00:05:51,870 --> 00:05:54,770
差异的67％等。

82
00:05:55,080 --> 00:06:01,590
所以请记住，我们要采用的是前两个主要成分，因为我们要获得两个维度

83
00:06:01,680 --> 00:06:06,000
在训练结果的可视化中，因此我们需要两个独立变量

84
00:06:06,000 --> 00:06:08,150
是两个主要组成部分。

85
00:06:08,220 --> 00:06:14,730
因此，我们可以看到，如果我们在这里很好地考虑这两个主要成分，它们将解释56％

86
00:06:14,850 --> 00:06:16,720
的差异，这是非常好的。

87
00:06:16,830 --> 00:06:21,130
实际上，可以从中进行更多分类。

88
00:06:21,360 --> 00:06:22,240
这样很好。

89
00:06:22,440 --> 00:06:28,260
因此，现在我们要做的是采用前两个主要组成部分

90
00:06:28,260 --> 00:06:33,750
数据集的两个新自变量，因此我们回到了部分情况

91
00:06:33,750 --> 00:06:40,290
3，我们有两个自变量，即使最初我们拥有的变量比13个多

92
00:06:40,290 --> 00:06:41,180
变量。

93
00:06:41,490 --> 00:06:42,300
太好了。

94
00:06:42,300 --> 00:06:50,760
现在我要按“ OK”（确定），在这里我将不替换两个，以便提取特定的类

95
00:06:51,060 --> 00:06:54,390
解释最多变体的前两个主要组成部分。

96
00:06:54,430 --> 00:06:59,880
现在我只需要重置控制台，因为现在它在隔壁，不是我原来的

97
00:06:59,880 --> 00:07:02,870
训练集和测试集，因为我们只是对其进行了转换。

98
00:07:03,060 --> 00:07:07,870
当然，我们希望从原始数据集中提取这两个主要成分。

99
00:07:08,070 --> 00:07:12,180
所以我要在这里重新启动内核来重置我的内核。

100
00:07:12,180 --> 00:07:13,620
您确定要重启内核吗？

101
00:07:13,620 --> 00:07:14,300
是。

102
00:07:14,430 --> 00:07:15,360
恢复内核。

103
00:07:15,360 --> 00:07:16,520
开始了。

104
00:07:16,580 --> 00:07:22,260
所以现在我要选择从这里到顶部的所有内容，然后按命令控制

105
00:07:22,260 --> 00:07:29,100
加上Enter键即可执行并提取解释以下内容的大部分变体的前两个主要组成部分

106
00:07:29,100 --> 00:07:30,020
我们的数据集。

107
00:07:30,240 --> 00:07:37,350
现在，如您所见，我们的数据集仍然是我们的原始数据集，具有13个独立变量

108
00:07:37,440 --> 00:07:38,850
和一场皇家之战。

109
00:07:39,000 --> 00:07:45,410
但是当我们现在看一下X时，它只包含两个自变量

110
00:07:45,410 --> 00:07:49,110
当然，解释最多变体的前两个主要组成部分。

111
00:07:49,290 --> 00:07:52,590
而且还有天平，所以很棒。

112
00:07:52,590 --> 00:07:57,960
现在我们有两个自变量，因此我们可以拟合所有逻辑回归模型

113
00:07:58,230 --> 00:08:01,160
并以二维方式可视化其结果。

114
00:08:01,170 --> 00:08:02,920
这就是我们在下一个教程中将要做的。

115
00:08:02,940 --> 00:08:04,620
直到那时引擎机械。

