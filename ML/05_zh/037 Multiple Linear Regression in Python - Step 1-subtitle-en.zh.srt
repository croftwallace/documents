1
00:00:00,360 --> 00:00:05,610
您好，欢迎来到这个有关多元线性回归的Python教程。

2
00:00:05,670 --> 00:00:11,120
因此，在上一节中，我们在Python中实现了一个简单的线性回归，这次我们将

3
00:00:11,120 --> 00:00:17,180
向前迈出一步，我们将在数据集中添加一些时间，因为这次

4
00:00:17,220 --> 00:00:22,410
在回归中简单地将是几个自变量我们只有一个自变量

5
00:00:22,410 --> 00:00:22,650
。

6
00:00:22,650 --> 00:00:25,210
这次我们将有几个自变量。

7
00:00:25,560 --> 00:00:30,110
好的，让我们现在对野牛实施多元回归。

8
00:00:30,330 --> 00:00:33,910
因此，我们需要做的第一件事就是照常设置工作目录。

9
00:00:34,110 --> 00:00:36,340
因此，我们将在此处转到文件导出。

10
00:00:36,480 --> 00:00:39,010
我们将转到我们的机器学习Asie文件夹。

11
00:00:39,040 --> 00:00:43,230
第二部分回归部分多元线性回归。

12
00:00:43,440 --> 00:00:46,160
这是我们要设置工作目录的目录。

13
00:00:46,410 --> 00:00:51,900
让我们确保在此文件夹中归档50个启动项时拥有数据集。

14
00:00:52,080 --> 00:00:56,510
如果是这种情况，我们准备将这个文件夹作为工作目录发送。

15
00:00:56,820 --> 00:01:00,560
因此，要做到这一点，请不要忘记单击此处的这个小按钮。

16
00:01:00,570 --> 00:01:01,220
开始了。

17
00:01:01,230 --> 00:01:02,350
现在准备好了。

18
00:01:02,870 --> 00:01:03,180
好。

19
00:01:03,190 --> 00:01:09,340
现在，制作模型的第一步是准备数据集，然后执行此操作。

20
00:01:09,360 --> 00:01:14,460
与往常一样，我们将使用在第1部分中制作的数据预处理模板。

21
00:01:14,760 --> 00:01:22,340
因此，我将复制所有副本，然后将其粘贴到此处，这样可以节省大量时间。

22
00:01:22,560 --> 00:01:27,420
现在我们需要做的是更改一些事情，所以让我们从数据集的名称开始

23
00:01:27,420 --> 00:01:35,200
当然不是说我们的数据，而是50家创业公司是正确的。

24
00:01:35,400 --> 00:01:37,360
然后让我们看一下数据集。

25
00:01:37,630 --> 00:01:42,990
但是要做到这一点，我们需要导入必要的库，尤其是Bender的库，因为

26
00:01:42,990 --> 00:01:45,960
我们正在使用bander导入此数据集。

27
00:01:45,960 --> 00:01:48,190
因此，让我们执行一下。

28
00:01:48,210 --> 00:01:48,900
开始了。

29
00:01:48,900 --> 00:01:55,760
很好地导入了，现在让我们选择这一行以查看我们的数据集。

30
00:01:55,920 --> 00:01:58,350
因此，数据集可以很好地导入。

31
00:01:58,350 --> 00:02:01,730
现在，让我们进入Voivod Explorer进行查看。

32
00:02:01,730 --> 00:02:03,340
那就是双击数据集。

33
00:02:03,540 --> 00:02:04,590
现在我们开始。

34
00:02:04,990 --> 00:02:05,360
好。

35
00:02:05,370 --> 00:02:10,840
因此，首先格式不是很好，所以我们将对其进行更改。

36
00:02:11,180 --> 00:02:18,720
因此，如您所见，这是一种科学计数法，我们将通过用零替换三来要求没有小数

37
00:02:19,200 --> 00:02:24,510
然后我们将G更改为F以具有浮点数。

38
00:02:24,900 --> 00:02:27,540
好吧，现在更好了。

39
00:02:27,570 --> 00:02:34,200
好的，那么关于此数据集的数据说的是什么，实际上包含了

40
00:02:34,440 --> 00:02:35,640
50颗星。

41
00:02:35,640 --> 00:02:37,560
我们有50个观察结果。

42
00:02:38,310 --> 00:02:45,990
这些信息是R＆D支出，管理支出，营销支出

43
00:02:46,370 --> 00:02:54,300
初创公司运营的状态，利润以及这里要了解的是我们想要

44
00:02:54,300 --> 00:03:01,140
建立模型以查看所有这些变量之间是否存在Linae我们的依赖关系。

45
00:03:01,140 --> 00:03:06,720
那就是R-Ind。 是行政支出，营销支出，状态及其变量

46
00:03:06,720 --> 00:03:07,630
是利润。

47
00:03:07,740 --> 00:03:15,480
因此，这意味着最终我们希望我们的模型能够基于这些信息来预测利润

48
00:03:15,480 --> 00:03:16,020
这里。

49
00:03:16,110 --> 00:03:18,780
州的研发支出管理营销支出。

50
00:03:19,050 --> 00:03:21,510
因此，这就是我们头脑中必须清楚的事情。

51
00:03:21,540 --> 00:03:26,910
这是两个自变量，这是因变量，现在我们了解到

52
00:03:27,180 --> 00:03:34,080
我们知道要在此处为​​特征矩阵即自变量矩阵输入哪些索引

53
00:03:34,650 --> 00:03:40,920
因为简单地，我们的自变量矩阵将是从这里到这里的所有矩阵

54
00:03:40,930 --> 00:03:41,160
。

55
00:03:41,400 --> 00:03:47,690
因此，利润不包含我们的50个观察值。

56
00:03:47,800 --> 00:03:48,630
好吧。

57
00:03:48,630 --> 00:03:49,770
多数民众赞成在矩阵。

58
00:03:50,070 --> 00:03:55,320
然后为什么这里将成为最后一列，因为它将成为因变量向量

59
00:03:55,340 --> 00:03:55,580
。

60
00:03:55,800 --> 00:03:59,120
因此，这里将成为利润的载体。

61
00:03:59,210 --> 00:03:59,520
好的。

62
00:03:59,520 --> 00:04:05,250
因此，现在让我们按照数据预处理部分中告诉您的那样更改索引，我们不需要更改

63
00:04:05,250 --> 00:04:11,310
这是因为我在本课程中的所有数据集都将首先使用自变量

64
00:04:11,460 --> 00:04:13,980
然后将因变量作为最后一列。

65
00:04:13,980 --> 00:04:21,030
因此，这就是为什么我在此处放置减号以删除最后一列以采用独立变量矩阵的原因

66
00:04:21,030 --> 00:04:21,550
这里。

67
00:04:21,780 --> 00:04:22,540
好吧。

68
00:04:22,560 --> 00:04:28,500
但是，我们可能需要在此处更改此索引，但也许不能让我们看看该索引必须是索引

69
00:04:28,500 --> 00:04:30,190
因变量向量。

70
00:04:30,200 --> 00:04:31,590
利润栏。

71
00:04:31,620 --> 00:04:38,050
因此，由于索引和野牛开始为零，因此袍长为0 1 2 3和4。

72
00:04:38,040 --> 00:04:41,350
不幸的是，我们必须对其进行更改，但这确实是正确的。

73
00:04:41,400 --> 00:04:44,160
我们只需要将三乘四替换即可。

74
00:04:44,700 --> 00:04:51,450
好的，现在已经准备好，我们可以构建我们的独立变量矩阵x和我们的因变量

75
00:04:51,450 --> 00:04:52,780
变量向量y。

76
00:04:52,980 --> 00:04:58,620
好的，现在让我们选择这两个命令和控件，然后按Enter键执行。

77
00:04:58,620 --> 00:05:01,250
在这里，我们进行x和y的创建。

78
00:05:01,260 --> 00:05:02,180
我们来看一下。

79
00:05:02,400 --> 00:05:02,700
好。

80
00:05:02,700 --> 00:05:07,950
所以我们不能在这里看看，因为类型是一个对象，那是因为矩阵包含不同的

81
00:05:07,950 --> 00:05:11,040
类型，因此无法在此处选择单个类型。

82
00:05:11,250 --> 00:05:15,680
因此，我们将从这里x对其进行研究。

83
00:05:15,850 --> 00:05:16,180
好吧。

84
00:05:16,180 --> 00:05:21,620
这就是我们的独立变量矩阵，您可以看到我们清楚地看到了四个独立变量

85
00:05:21,640 --> 00:05:27,650
“ R＆D支出管理”的“专栏”支出了美国的营销支出。

86
00:05:27,880 --> 00:05:29,520
现在让我们看看原因。

87
00:05:29,650 --> 00:05:34,180
好吧，实际上我们从这里开始看看，因为既然它只有一个类型，我们就可以看看

88
00:05:34,450 --> 00:05:38,870
因为顺便说一句，如果我双击它，我会收到此消息，那是因为类型是一个对象

89
00:05:38,940 --> 00:05:40,810
在这里键入仅流64。

90
00:05:40,960 --> 00:05:44,550
因此，我可以单击它，然后查看我的因变量。

91
00:05:44,560 --> 00:05:45,440
向量。

92
00:05:45,660 --> 00:05:46,010
好的。

93
00:05:46,030 --> 00:05:50,010
这些都是我们尚未做出任何预测的实际利润。

94
00:05:50,340 --> 00:05:51,500
那么好吧。

95
00:05:51,580 --> 00:05:52,350
对。

96
00:05:52,420 --> 00:05:55,660
我们还没有准备好。

97
00:05:55,690 --> 00:06:02,650
现在我们需要暂停一秒钟，因为当您查看此自变量指标时，

98
00:06:02,650 --> 00:06:08,470
引起您的注意，某些事情一定引起您的注意，特别是如果您遵循

99
00:06:08,650 --> 00:06:10,910
登上一日进行预处理。

100
00:06:11,410 --> 00:06:13,660
请记住，我们可能需要在这里做些事情。

101
00:06:13,660 --> 00:06:15,330
它是什么。

102
00:06:16,420 --> 00:06:22,150
好吧，请记住，有一天您在进行预处理时，我们谈到了必须

103
00:06:22,150 --> 00:06:23,110
被编码。

104
00:06:23,110 --> 00:06:28,600
因为如果将它们保留给我们，这可能会在机器学习模型方程式中引起一些问题

105
00:06:29,170 --> 00:06:35,050
如您所见，这里有一个类别变量，即状态变量和该变量

106
00:06:35,050 --> 00:06:36,650
尚未编码。

107
00:06:36,700 --> 00:06:38,970
我们只有Trina，这里有文字。

108
00:06:38,980 --> 00:06:40,590
纽约加利福尼亚佛罗里达。

109
00:06:40,600 --> 00:06:43,510
因此，我们可能在方程式中遇到一些问题。

110
00:06:43,510 --> 00:06:47,650
因此，我们当然需要在此处编码此调用。

111
00:06:47,950 --> 00:06:52,390
因此，我们将做与数据处理部分完全相同的操作。

112
00:06:52,600 --> 00:07:00,340
我们将使用标签编码器将此列编码为数字，然后将其删除

113
00:07:00,400 --> 00:07:06,590
任何关系顺序，我们将使用冷热一号来创建虚拟变量。

114
00:07:06,640 --> 00:07:07,990
因此，让我们这样做。

115
00:07:08,110 --> 00:07:09,970
我们将在这里探索太远了。

116
00:07:10,000 --> 00:07:18,500
然后，我们将跳回到上一部分，即此处的第1部分数据处理。

117
00:07:18,520 --> 00:07:20,920
所以我在这里打开更饱满的东西。

118
00:07:20,980 --> 00:07:29,410
我正在打开section文件夹，这是分类数据文件，现在将用于编码我们的

119
00:07:29,410 --> 00:07:32,600
我们在数据集中的分类变量状态。

120
00:07:32,660 --> 00:07:36,490
我们将看到这有多快，我只需要打开它。

121
00:07:36,590 --> 00:07:37,660
好吧。

122
00:07:37,720 --> 00:07:42,270
现在，我将在这里使用此代码部分。

123
00:07:42,910 --> 00:07:44,120
复制。

124
00:07:44,140 --> 00:07:52,210
然后，我只需要关闭它，然后在这里添加它，因为必须在编码之前完成

125
00:07:52,450 --> 00:07:55,930
将数据集拆分为集合中的训练集。

126
00:07:56,490 --> 00:08:00,280
好的，现在让我们编码是可行的。

127
00:08:00,280 --> 00:08:06,460
所以首先我们只有一个分类变量，即状态变量，因此它是一个独立的

128
00:08:06,460 --> 00:08:07,280
变量。

129
00:08:07,300 --> 00:08:12,380
我们不需要对因变量进行任何编码，因为它是工资，不是绝对的

130
00:08:12,460 --> 00:08:12,720
。

131
00:08:12,730 --> 00:08:18,720
因此，首先我们将删除对不需要的因变量进行编码的部分。

132
00:08:19,270 --> 00:08:23,790
但是，我们需要对任何自变量进行编码的这一部分。

133
00:08:23,950 --> 00:08:29,890
现在我们只需要更改一些内容，就可以准备对自变量进行编码了

134
00:08:29,890 --> 00:08:30,770
州。

135
00:08:31,150 --> 00:08:36,790
因此，我们需要更改的第一件事实际上是我们要编码的列的索引

136
00:08:36,810 --> 00:08:37,150
。

137
00:08:37,450 --> 00:08:43,670
因此，在我们的模板的第1部分数据预处理中，请记住该列是被零索引的列

138
00:08:43,720 --> 00:08:49,160
因为如果您没有记错的话，那是一个国家，并且它是第一列，因此被零索引。

139
00:08:49,330 --> 00:08:56,290
在这里，我们的分类变量列的索引是索引0 1到第三个索引。

140
00:08:56,290 --> 00:09:00,950
因此，我们同意输入3而不是0。

141
00:09:00,950 --> 00:09:03,520
好的，这里也一样。

142
00:09:04,210 --> 00:09:04,920
好。

143
00:09:05,080 --> 00:09:11,110
这部分是我们使用标签编码器将文本更改为数字的部分，实际上

144
00:09:11,110 --> 00:09:16,450
需要这样做，因为我们将无法在此处直接在文本上使用一个热编码器，因为

145
00:09:16,540 --> 00:09:20,250
必须有数字才能创建虚拟变量。

146
00:09:20,290 --> 00:09:24,140
因此，在哈德逊走廊的一个走廊中，我们只需要替换索引即可。

147
00:09:24,290 --> 00:09:30,350
当然是3，因为这是您想对一个冷热列的索引。

148
00:09:30,950 --> 00:09:31,450
好。

149
00:09:31,450 --> 00:09:38,080
实际上，正如我告诉您的那样，现在已经准备就绪，我们只需要更改索引就可以了

150
00:09:38,100 --> 00:09:38,400
。

151
00:09:38,740 --> 00:09:42,160
现在让我们最后看一下矩阵，因为这将改变。

152
00:09:42,160 --> 00:09:43,720
因此，让我们只记得它是怎么回事。

153
00:09:43,900 --> 00:09:54,510
我们在文本中有状态列，现在让我们选择此命令或在下面控制我们执行。

154
00:09:54,520 --> 00:09:55,610
现在我们开始。

155
00:09:55,720 --> 00:10:02,530
编码已成功完成，现在很酷，因为我们所有的列都在同一列中

156
00:10:02,530 --> 00:10:05,440
输入笔中矩阵的类型。

157
00:10:05,500 --> 00:10:07,830
X现在是浮点数64。

158
00:10:08,020 --> 00:10:09,760
因此，我们可以从这里查看X。

159
00:10:09,760 --> 00:10:10,760
让我们来看一下。

160
00:10:10,760 --> 00:10:17,040
双击X，这是我要放大的位置，当然要更改格式。

161
00:10:17,210 --> 00:10:20,740
所以像往常一样，我要把浮子放到这里。

162
00:10:20,810 --> 00:10:23,390
但是我将选择零小数。

163
00:10:23,780 --> 00:10:24,530
好。

164
00:10:24,740 --> 00:10:31,580
好的，现在我们清楚地看到，我们在研发专栏中花了三分钱，在研究和营销上花了钱。

165
00:10:31,580 --> 00:10:32,390
花。

166
00:10:32,600 --> 00:10:38,090
并记住在我们有第四列之前是状态列，其中包含文本和

167
00:10:38,090 --> 00:10:46,380
第四列被替换为三列，它们是虚拟变量，请记住每一列

168
00:10:46,400 --> 00:10:48,620
对应一个状态。

169
00:10:48,620 --> 00:10:51,510
好吧，让我们来看一下数据集。

170
00:10:51,530 --> 00:10:53,280
我在这里打开数据集。

171
00:10:53,750 --> 00:10:57,140
因此，我只想向您展示第一个观察结果。

172
00:10:57,140 --> 00:11:00,440
因此，第一个观察值为零索引的观察。

173
00:11:00,470 --> 00:11:07,410
因此，这只是我们可以检查出是否有相同的16 53 49 16 53 49的一个。

174
00:11:07,410 --> 00:11:10,830
好的，这与这里的观察相同。

175
00:11:11,060 --> 00:11:17,300
在这里有州专栏之前，这个观察有纽约州和州专栏

176
00:11:17,300 --> 00:11:19,560
被三个虚拟变量代替。

177
00:11:19,700 --> 00:11:22,790
每个虚拟变量对应一个状态。

178
00:11:22,820 --> 00:11:30,920
因此，由于我们这里有零零零，这意味着这里的讨论是纽约虚拟变量

179
00:11:30,920 --> 00:11:31,620
打电话。

180
00:11:31,880 --> 00:11:36,890
所以这是新的变量调用，因为此观察的州为纽约，我们有一个

181
00:11:36,890 --> 00:11:39,530
此处表示该列是新的。

182
00:11:39,890 --> 00:11:46,340
如果我们进行第二次观察，我们可以检查它是否相同16:25 9 8 16:25 9 8。

183
00:11:46,340 --> 00:11:48,920
好的，适合第二次观察。

184
00:11:48,920 --> 00:11:53,260
第一栏中的数字为1，加利福尼亚州为该州。

185
00:11:53,270 --> 00:11:56,200
这意味着第一个来到加利福尼亚。

186
00:11:56,720 --> 00:12:03,860
最后第三次观察，我们在中间有一个1，该州是佛罗里达州，这意味着

187
00:12:03,860 --> 00:12:05,630
第二列是佛罗里达。

188
00:12:05,960 --> 00:12:09,120
因此，加州可以先在佛罗里达再打电话。

189
00:12:09,200 --> 00:12:11,440
第三，叫他们纽约。

190
00:12:11,690 --> 00:12:14,820
因此，这就是创建虚拟变量的方式。

191
00:12:15,170 --> 00:12:18,320
所以我要关闭这个和这个。

192
00:12:18,680 --> 00:12:19,290
好。

193
00:12:19,540 --> 00:12:25,040
现在，为了形成直觉，我将在此处添加一行。

194
00:12:25,040 --> 00:12:29,150
好吧，实际上一个美国。我要称呼这部分以避免

195
00:12:31,880 --> 00:12:37,800
该虚拟变量陷阱。

196
00:12:38,330 --> 00:12:38,730
好。

197
00:12:38,810 --> 00:12:48,220
在此操作中，我将只写一行X等于x括号冒号。

198
00:12:48,440 --> 00:12:50,780
然后打个电话。

199
00:12:51,320 --> 00:12:52,860
好，那我刚才做了什么。

200
00:12:53,030 --> 00:12:59,810
我刚刚从X删除了第一列，因为这样做是因为我占用了x的所有行，所以

201
00:12:59,810 --> 00:13:00,400
精细。

202
00:13:00,500 --> 00:13:06,080
但是，通过在此处放置这一列，这意味着我要开始使用X的所有列

203
00:13:06,080 --> 00:13:08,390
从索引1到末尾。

204
00:13:08,600 --> 00:13:13,220
因此，这意味着我不采用索引为0的列，因此不采用第一列

205
00:13:13,220 --> 00:13:13,560
。

206
00:13:13,700 --> 00:13:14,910
以及为什么我要这样做。

207
00:13:15,050 --> 00:13:19,420
答案就在标题中，因为我想避免虚拟变量陷阱。

208
00:13:19,460 --> 00:13:24,660
但是，当然，用于线性回归的Python库正在处理虚拟变量陷阱

209
00:13:24,660 --> 00:13:27,520
因此我们不需要像这里一样手动进行操作。

210
00:13:27,800 --> 00:13:34,340
但是我只想添加此行以提醒您有关虚拟变量陷阱的信息，因为对于某些软件

211
00:13:34,520 --> 00:13:39,020
对于某些图书馆，您需要将其取下来才能手动使用。

212
00:13:39,020 --> 00:13:41,950
因此，这里只是提醒我们，我们不必在这里这样做。

213
00:13:41,960 --> 00:13:47,180
但是实际上我们可以在这里做到这一点，我们可以选择太阳并执行，然后我们将确保我们的

214
00:13:47,180 --> 00:13:54,070
数据将不包含一些冗余的依赖项，因为这就是虚拟变量陷阱所针对的

215
00:13:54,080 --> 00:13:57,580
因此我们可以执行这一行。

216
00:13:57,710 --> 00:13:58,210
这里是。

217
00:13:58,230 --> 00:14:05,180
现在，您可以看到是否返回到自变量矩阵X，它不再包含第一个

218
00:14:05,330 --> 00:14:08,000
列是加利福尼亚。

219
00:14:08,320 --> 00:14:10,950
下次您不需要手动进行。

220
00:14:10,970 --> 00:14:13,120
图书馆正在为您服务。

221
00:14:13,670 --> 00:14:14,490
好。

222
00:14:14,720 --> 00:14:16,820
现在我们准备进行拆分。

223
00:14:16,930 --> 00:14:20,900
我们准备将数据集分为训练集和测试集。

224
00:14:20,930 --> 00:14:25,550
因此，像往常一样，我们只需要更改测试大小即可。

225
00:14:25,790 --> 00:14:26,590
让我们来看一下。

226
00:14:26,600 --> 00:14:30,320
我们的数据集包含50个观察值。

227
00:14:30,320 --> 00:14:32,180
那么，这里的测试尺寸是多少？

228
00:14:32,330 --> 00:14:39,660
好50个观测值将10个观测值放入集合中并将40个观测值放在火车中怎么样

229
00:14:39,970 --> 00:14:40,370
事情。

230
00:14:40,390 --> 00:14:42,330
我认为这会很好地解决。

231
00:14:42,380 --> 00:14:47,430
因此，实际上10观察或50观察是20％。

232
00:14:47,540 --> 00:14:48,130
所以。

233
00:14:48,260 --> 00:14:48,920
好的。

234
00:14:48,920 --> 00:14:51,000
这里已经是20％0.2。

235
00:14:51,110 --> 00:14:52,860
因此，我们无需更改任何内容。

236
00:14:53,000 --> 00:14:54,200
太完美了。

237
00:14:54,230 --> 00:15:00,450
我们只需要选择此新闻指挥官控制中心即可执行。

238
00:15:00,890 --> 00:15:01,750
现在我们开始。

239
00:15:01,750 --> 00:15:03,930
完美执行。

240
00:15:04,040 --> 00:15:06,450
现在让我们看一下X射线。

241
00:15:06,650 --> 00:15:07,430
好的，完美。

242
00:15:07,430 --> 00:15:08,990
一切似乎都很好。

243
00:15:08,990 --> 00:15:11,840
它包含40个观察值。

244
00:15:11,860 --> 00:15:12,720
好吧。

245
00:15:12,860 --> 00:15:14,830
同样为什么火车。

246
00:15:14,840 --> 00:15:15,960
40个观察。

247
00:15:15,980 --> 00:15:22,280
那就是因变量矢量的40个观测值与的相同40个观测值相关联

248
00:15:22,280 --> 00:15:23,060
X列车

249
00:15:26,150 --> 00:15:29,180
现在x检验包含10个观察值。

250
00:15:29,420 --> 00:15:33,470
对于测试10个观察结果完美的原因也是如此。

251
00:15:33,770 --> 00:15:40,040
然后我们准备好了，因为我们不需要在回归中对多个要素应用滑冰功能

252
00:15:40,310 --> 00:15:42,750
因为图书馆会为我们照顾。

253
00:15:42,770 --> 00:15:44,470
因此，我们不必手动执行此操作。

254
00:15:44,690 --> 00:15:47,170
因此，我们已经准备好了。

255
00:15:47,390 --> 00:15:48,110
完善。

256
00:15:48,110 --> 00:15:53,690
现在，我们在数据处理阶段一切都很好，因此我们可以继续进行下一个教程

257
00:15:53,710 --> 00:15:53,880
。

258
00:15:54,020 --> 00:15:55,360
谢谢您的收看。

259
00:15:55,430 --> 00:15:57,470
在那之前享受机器学习

