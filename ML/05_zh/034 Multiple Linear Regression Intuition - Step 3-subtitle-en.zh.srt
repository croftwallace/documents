1
00:00:01,440 --> 00:00:03,540
今天，我们谈论的是虚拟变量。

2
00:00:03,930 --> 00:00:10,050
因此，基本上，我们所拥有的信息是每个公司或每个创业公司的利润，然后

3
00:00:10,050 --> 00:00:16,470
研发支出管理员支出营销支出所以这三笔是公司的支出

4
00:00:16,530 --> 00:00:20,580
然后在约克或加利福尼亚州开展业务。

5
00:00:20,910 --> 00:00:26,490
我们面临的挑战是，风险投资家基金希望了解是否存在

6
00:00:26,490 --> 00:00:34,530
利润与花费在不同费用上的研发经理之间的相关性

7
00:00:34,530 --> 00:00:39,520
市场营销以及公司在哪个阶段开展业务。

8
00:00:39,600 --> 00:00:46,410
利润与所有这些变量之间是否存在关联，以及如何创建一个

9
00:00:46,650 --> 00:00:53,940
模型以了解了解R＆D如何花费管理和营销并保持预测利润的方式，因此

10
00:00:54,060 --> 00:00:59,760
利润是我们的因变量，其余的蓝色都是自变量。

11
00:00:59,880 --> 00:01:03,650
我们需要做的是建立线性回归。

12
00:01:03,840 --> 00:01:10,680
因此，让我们继续前进，就像发生多次内在攻击一样，首先要说

13
00:01:10,710 --> 00:01:13,760
是利润的Y等于什么。

14
00:01:13,770 --> 00:01:14,510
那等于什么。

15
00:01:14,520 --> 00:01:20,250
首先，在这种情况下，有一个常数为0，我将其放在利润列下

16
00:01:20,250 --> 00:01:22,470
只是因为我需要在某个地方安装它。

17
00:01:22,740 --> 00:01:26,490
然后，我们将开始将这些变量添加到方程式中。

18
00:01:26,490 --> 00:01:32,370
因此，在这种情况下，我们得到了一个较大的系数乘以X1变量，即研发支出，

19
00:01:32,370 --> 00:01:37,750
X-1实际上是您在“ R＆D”列中看到的美元金额。

20
00:01:38,160 --> 00:01:43,280
然后，您获得了x 2的Azmin变量。

21
00:01:43,290 --> 00:01:47,790
再次得到BE2的承认，或者在这种情况下X-2将是美元金额

22
00:01:47,850 --> 00:01:49,110
您会在“管理”列中看到。

23
00:01:49,290 --> 00:01:54,670
然后，您将获得额外的营销支出，这将是您在“营销”列中看到的美元金额。

24
00:01:54,670 --> 00:01:54,900
。

25
00:01:54,990 --> 00:02:02,790
然后您有了状态变量，在这里，当我们到达此处时，我们在问应该放置什么

26
00:02:03,000 --> 00:02:08,340
在状态列的等式中，因为我们实际上没有数字，我们没有美元

27
00:02:08,340 --> 00:02:14,340
值或要添加到方程式中的任何其他类型的数字，或者我们可以在方程式中添加一个单词

28
00:02:14,360 --> 00:02:14,570
。

29
00:02:14,790 --> 00:02:21,120
这里的事情是，状态实际上是一个类别变量，因此我们讨论了

30
00:02:21,120 --> 00:02:26,810
之前的变量，我们知道存在分类变量和数值变量

31
00:02:26,830 --> 00:02:27,000
。

32
00:02:27,150 --> 00:02:32,460
那么在这种情况下，状态是一个分类变量，因此我们可以将其添加到方程式中。

33
00:02:32,460 --> 00:02:39,240
我们需要对这种情况和面对绝对情况时需要采取的方法做一些事情

34
00:02:39,240 --> 00:02:43,190
回归模型中的变量是您需要创建虚拟变量。

35
00:02:43,230 --> 00:02:45,620
让我们看看我们如何做到这一点。

36
00:02:45,690 --> 00:02:50,060
首先，您需要遍历您的专栏并找到您拥有的所有不同类别。

37
00:02:50,160 --> 00:02:52,180
因此，在这种情况下，我们有两个类别。

38
00:02:52,470 --> 00:02:56,930
因此，对于您关注的每个类别，您都需要为纽约创建一个新列

39
00:02:56,970 --> 00:03:01,290
创建一个名为“纽约客”（New-Yorker）的专栏，为移民提供色彩，营造平静的加州，所以我们有点

40
00:03:01,290 --> 00:03:06,180
扩展数据集并向其中添加一些其他列。

41
00:03:06,180 --> 00:03:07,440
以及如何填充列。

42
00:03:07,440 --> 00:03:10,340
因此，这是填充这些列的有趣部分。

43
00:03:10,410 --> 00:03:11,560
纽约客的开始。

44
00:03:11,870 --> 00:03:17,700
您会找到州实际说纽约的所有行，并且需要

45
00:03:17,700 --> 00:03:23,870
在您的列中输入一个，然后在加利福尼亚州显示所有加利福尼亚的行。

46
00:03:23,970 --> 00:03:29,670
基本上，对于所有不说新的行或他们说的其他任何行，您只需输入0，然后输入

47
00:03:29,730 --> 00:03:32,740
加州专栏加州你也做同样的事情。

48
00:03:32,790 --> 00:03:40,530
如果A在“州”列中说“加利福尼亚”的任何地方，则在“加利福尼亚”列中放置1，对于任何其他列

49
00:03:40,530 --> 00:03:44,630
您在“州”列中将零放置在“状态”列中。

50
00:03:44,850 --> 00:03:52,140
因此，您最终得到了这样的数据集，这两个新列称为伪变量和

51
00:03:52,140 --> 00:03:55,040
从这里建立回归模型非常简单。

52
00:03:55,050 --> 00:04:00,870
您所要做的就是使用“纽约”列，而您将要使用它而不是状态

53
00:04:00,860 --> 00:04:02,840
知道你将要使用状态了。

54
00:04:02,940 --> 00:04:09,000
基本上，您添加一个在时间D1和D1之前的变量。

55
00:04:09,000 --> 00:04:15,710
在这种情况下，您的纽约虚拟变量就是您，也不使用“加利福尼亚”列。

56
00:04:16,200 --> 00:04:21,660
因此，您可以在这里看到我们数据中的所有信息都被保留。

57
00:04:21,750 --> 00:04:27,450
如果我们只坚持一个纽约专栏，因为您可以马上说出一个是否为一，那么它就是

58
00:04:27,450 --> 00:04:29,600
在纽约运作且运作的公司。

59
00:04:29,670 --> 00:04:32,340
如果一个为零，则为在加利福尼亚州运营的公司。

60
00:04:32,340 --> 00:04:37,270
因此，我们仅通过纽约电话会议就不会丢失任何信息。

61
00:04:37,380 --> 00:04:43,350
我们实际上将更多地讨论为什么不应该包含所有虚拟变量列的原因

62
00:04:43,680 --> 00:04:45,120
在您的回归模型中。

63
00:04:45,120 --> 00:04:51,830
在下一个教程中，当我们讨论虚拟变量陷阱时，我们将进一步讨论这一点。

64
00:04:51,960 --> 00:04:59,340
但是现在我想讨论两件事，所以首先是纽约专栏或所有虚拟人物。

65
00:04:59,340 --> 00:05:01,500
它们充当开关的变量。

66
00:05:01,500 --> 00:05:05,770
在这种情况下，让我们看一下回归中包括的“纽约”专栏。

67
00:05:05,790 --> 00:05:12,900
它像电灯开关一样工作，因此，如果它是一个开关，那么您就会知道该公司在纽约。

68
00:05:12,900 --> 00:05:19,080
如果在这种情况下，在图片中为零Sol off，则您知道该公司没有

69
00:05:19,080 --> 00:05:23,520
在纽约选项中工作，因此虚拟变量的工作方式类似于电灯开关。

70
00:05:23,550 --> 00:05:27,630
这就是为什么它们是1和0，而它们中不需要任何其他值的原因。

71
00:05:27,720 --> 00:05:31,380
第二件事是，当您研究这种方法时，可能会产生偏差。

72
00:05:31,380 --> 00:05:36,480
因此，我们为纽约包括了一个变量，并且对于纽约有一个系数，所以我们基本上有

73
00:05:36,480 --> 00:05:43,410
在方程式中对纽约拥有一个系数的好处是早于加利福尼亚

74
00:05:43,440 --> 00:05:48,990
没有系数，因为当D-1为零时，方程的整个损耗部分变为零，

75
00:05:49,380 --> 00:05:55,170
对于加利福尼亚，我们的方程式中没有系数的好处，乍一看似乎有偏见，但

76
00:05:55,500 --> 00:06:01,140
实际上并非如此，因为回归模型的工作方式是默认情况下将采用

77
00:06:01,710 --> 00:06:09,210
该状态或该变量（您尚未包括的虚拟变量）将成为默认情况

78
00:06:09,210 --> 00:06:11,250
对于此回归模型。

79
00:06:11,250 --> 00:06:19,170
所以基本上这意味着加利福尼亚的系数将包含在常数中

80
00:06:19,190 --> 00:06:20,350
并为零。

81
00:06:20,640 --> 00:06:28,440
默认情况下，当D1等于零时，整个方程将变为您可以认为的方程

82
00:06:28,440 --> 00:06:30,580
它会变成加利福尼亚的方程式。

83
00:06:30,720 --> 00:06:38,910
但是，当Diwan成为您要添加的对象之前，这又是一个非常基本的解释

84
00:06:38,940 --> 00:06:43,520
但是您要添加一个系数，该系数是纽约和加利福尼亚之间的差值。

85
00:06:43,530 --> 00:06:44,000
所以。

86
00:06:44,100 --> 00:06:49,740
因此，基本上，您可以通过关闭此电灯开关（如果它处于关闭状态）来从加利福尼亚更改为纽约

87
00:06:49,770 --> 00:06:54,110
然后是默认状态，整个方程式对加利福尼亚有效。

88
00:06:54,150 --> 00:07:01,350
如果打开，则在您从默认加利福尼亚州更改方程式之前添加

89
00:07:01,380 --> 00:07:02,230
到纽约。

90
00:07:02,370 --> 00:07:08,180
因此，这是一种考虑虚拟变量的直观方法，因此我们

91
00:07:08,180 --> 00:07:15,360
在下一个教程中只包含一次，然后再讨论一次。

92
00:07:15,720 --> 00:07:17,480
包括两个虚拟变量。

93
00:07:17,720 --> 00:07:20,940
我将期待他们的风景，直到随后愉快地分析。

