1
00:00:00,390 --> 00:00:05,610
您好，欢迎来到以下Python教程中心，我们将通过以下教程来实现

2
00:00:05,610 --> 00:00:11,220
先验算法，正如您所知，我们将制作此机器学习模型来创建一些

3
00:00:11,220 --> 00:00:13,320
在某些特定业务中的价值。

4
00:00:13,350 --> 00:00:18,660
在这一部分中，此业务问题将与优化杂货店的销售有关

5
00:00:18,920 --> 00:00:24,360
或法国南部的杂货店，您将完全了解先验算法

6
00:00:24,360 --> 00:00:31,740
在优化销售方面将做得很完美，因为最近有很多商店

7
00:00:31,770 --> 00:00:38,040
通过使用机器创造了一些特别有价值的东西，特别是在关联规则学习中

8
00:00:38,040 --> 00:00:40,460
以优化其产品的销售。

9
00:00:40,500 --> 00:00:41,760
以及他们是如何做到的。

10
00:00:41,910 --> 00:00:48,660
好吧，他们只是使用协会规则学习来确切了解产品在商店中的放置位置

11
00:00:48,670 --> 00:00:48,810
。

12
00:00:48,990 --> 00:00:51,890
您知道例如，我会给您一个非常简单的例子。

13
00:00:52,230 --> 00:00:57,680
如果某人购买一些谷物，那么同一个人也很可能也购买一些牛奶。

14
00:00:57,870 --> 00:01:03,600
因此，通过将谷物放在靠近牛奶的位置，商店很可能会将这两种产品放入

15
00:01:03,600 --> 00:01:09,750
即使买家原本打算只购买谷物也可以使用同一篮子，或者我可以给您更笼统的内容

16
00:01:09,750 --> 00:01:13,410
例如，假设某人想要购买特定产品。

17
00:01:13,410 --> 00:01:14,920
我们称它为产品A。

18
00:01:15,210 --> 00:01:20,730
这个产品A可以很好地与另一个产品B和想要购买的人相关联

19
00:01:20,730 --> 00:01:21,240
产品。

20
00:01:21,270 --> 00:01:22,390
未成年人。

21
00:01:22,390 --> 00:01:26,790
想一想产品与产品B之间的这种良好关联。

22
00:01:26,970 --> 00:01:30,630
好吧，如果您将产品放在产品中并排放置。

23
00:01:30,750 --> 00:01:36,360
好吧，这个关联会突然在买家的脑海中浮现，让您知道买家可以告诉您

24
00:01:36,360 --> 00:01:37,970
这实际上是一个很好的组合。

25
00:01:37,980 --> 00:01:41,130
为什么不为下一次午餐或其他时间尝试这两点呢？

26
00:01:41,130 --> 00:01:45,770
即使买家原本只打算购买产品，也要如此。

27
00:01:45,990 --> 00:01:51,030
Judy好吧，由于产品和产品的位置，这种联想突然出现

28
00:01:51,050 --> 00:01:52,220
彼此靠近。

29
00:01:52,380 --> 00:01:55,850
好了，买方最终购买了两个完美的A和价格。

30
00:01:56,250 --> 00:02:01,500
这就是我们如何为零售店或杂货店创造附加值的想法。

31
00:02:01,500 --> 00:02:06,990
因此，我们将来在Teutul所做的优化销售的方法也可以应用于其他任何方法

32
00:02:06,990 --> 00:02:09,360
卖一些不同产品的商店。

33
00:02:09,420 --> 00:02:11,130
您可以想到一个在线商店。

34
00:02:11,220 --> 00:02:14,900
您知道这些建议的购买者也对此感兴趣。

35
00:02:15,000 --> 00:02:18,360
这些建议也基于关联规则。

36
00:02:18,360 --> 00:02:24,230
但是，这不仅可能是协作过滤或记帐之类的推荐系统的结果

37
00:02:24,270 --> 00:02:26,620
基于项目的协作过滤。

38
00:02:26,710 --> 00:02:29,850
那就是联想学习可以发挥作用。

39
00:02:29,850 --> 00:02:35,640
因此，现在让我们制作第一个关联规则和一个算法，该算法是针对此特定模型的先验模型

40
00:02:35,640 --> 00:02:37,150
商店在法国南部。

41
00:02:37,470 --> 00:02:38,470
因此，让我们开始吧。

42
00:02:38,670 --> 00:02:41,220
和往常一样，我们将设置工作目录。

43
00:02:41,220 --> 00:02:42,970
因此，让我们在这里查找探索。

44
00:02:43,200 --> 00:02:51,600
然后让我们早点进入机械AZ文件夹和第5部分关联规则，现在我们进入了

45
00:02:51,600 --> 00:02:55,560
外围部分包含不寻常的东西。

46
00:02:55,560 --> 00:03:01,140
这是用于在Python中实现的改进模型的特定文件夹，此处是先验Python

47
00:03:01,140 --> 00:03:01,240
。

48
00:03:01,260 --> 00:03:02,880
因此，让我们打开该文件夹。

49
00:03:02,880 --> 00:03:06,890
这实际上是我们要设置为工作目录的父亲，这是为什么。

50
00:03:07,080 --> 00:03:13,620
这是因为在先验模型的此实现中，我们将不直接获取任何包

51
00:03:13,620 --> 00:03:14,180
在代码中。

52
00:03:14,190 --> 00:03:20,340
我们将不使用某些导入来导入某些特定的程序包，就像通常的方式一样

53
00:03:20,340 --> 00:03:26,910
实际上要做的是使用该二进制文件P为什么文件是apriori模型的实现

54
00:03:27,150 --> 00:03:29,490
取自Python软件基金会。

55
00:03:29,610 --> 00:03:36,930
基本上，此文件包含的是一些类，我们将使用这些类来构建针对特定对象的规则

56
00:03:36,930 --> 00:03:38,010
业务问题。

57
00:03:38,010 --> 00:03:43,680
因此，我们将不得不打开它或任何您可以查看的内容，只要您知道可以使用的文本编辑器

58
00:03:43,680 --> 00:03:45,800
看一下类和不同的功能。

59
00:03:45,810 --> 00:03:49,930
它实际上很直观，但是我们不需要打开它。

60
00:03:49,950 --> 00:03:52,730
但是，我们确实需要将其放在此文件夹中。

61
00:03:52,890 --> 00:04:00,030
当您在此处执行代码时，将在其中预读您的原因文件，以免混淆任何内容

62
00:04:00,030 --> 00:04:00,260
。

63
00:04:00,330 --> 00:04:06,560
这是一个二进制文件，就好像它是我们按照常规方式导入的库一样。

64
00:04:06,720 --> 00:04:12,600
这就是我们先验的错，为什么我们现在要编码以建立规则的文件。

65
00:04:12,720 --> 00:04:14,480
这当然是数据集。

66
00:04:14,670 --> 00:04:22,320
因此，最重要的是，您必须在此处拥有这三个文件，才能正确运行Priory算法

67
00:04:22,590 --> 00:04:24,150
对于我们的业务问题。

68
00:04:24,350 --> 00:04:24,810
好。

69
00:04:24,900 --> 00:04:26,790
所以我们都准备好了。

70
00:04:26,790 --> 00:04:31,940
我们可以在这里单击此小按钮以设置文件夹的工作目录，现在我们一切都很好了。

71
00:04:31,950 --> 00:04:36,340
我们已准备好开始构建我们批准的模型并构建规则。

72
00:04:36,630 --> 00:04:37,290
好。

73
00:04:37,440 --> 00:04:40,320
因此，通常的第一件事就是导入库。

74
00:04:40,380 --> 00:04:41,640
因此，让我们这样做。

75
00:04:41,640 --> 00:04:47,850
我们将转到数据预处理模板，并将所有内容从这里移到这里，因为

76
00:04:47,970 --> 00:04:53,220
先验模型是一种特殊类型的机器学习模型，因此我们无需进行任何拆分

77
00:04:53,220 --> 00:04:55,730
将数据集分为训练集和测试集。

78
00:04:55,890 --> 00:04:56,870
没必要那样做。

79
00:04:56,910 --> 00:05:00,010
我们只需要在数据集上运行算法即可。

80
00:05:00,060 --> 00:05:05,850
因此，我们将其复制并粘贴到我们的Priori python文件中。

81
00:05:05,880 --> 00:05:06,720
开始了。

82
00:05:06,900 --> 00:05:12,510
因此，让我们立即使用该库，以免忘记这一点。

83
00:05:12,510 --> 00:05:13,650
开始了。

84
00:05:13,680 --> 00:05:15,210
图书馆很好的进口。

85
00:05:15,430 --> 00:05:19,190
好的，现在让我们导入数据集，当然是我们的数据集名称。

86
00:05:19,190 --> 00:05:27,100
这不是数据点csv，而是我们要进行的购物篮优化。

87
00:05:27,120 --> 00:05:33,780
现在，我们实际上可以选择这一行，并执行正确的数据集一点。

88
00:05:33,810 --> 00:05:34,600
我们来看一下。

89
00:05:34,740 --> 00:05:36,390
让我们转到变量资源管理器。

90
00:05:36,540 --> 00:05:39,010
这是数据集。

91
00:05:39,090 --> 00:05:40,580
好的，所以这个数据集。

92
00:05:40,590 --> 00:05:41,850
到底是什么

93
00:05:41,850 --> 00:05:48,230
首先，我们可以看到的是，此行包含不同产品的一些不同名称

94
00:05:48,560 --> 00:05:49,940
这家杂货店。

95
00:05:49,980 --> 00:05:55,130
因此，您当然知道这行应该是包含各列标题的行。

96
00:05:55,230 --> 00:06:00,540
当然，您已经可以看到这里的这些名称不是列的实际名称。

97
00:06:00,540 --> 00:06:07,070
嗯，因为这些名称只是注册的第一笔交易中产品的名称

98
00:06:07,310 --> 00:06:09,120
由这家商店的这位经理负责。

99
00:06:09,120 --> 00:06:15,690
所以问题出在这里，Piven认为数据集的第一行包含

100
00:06:15,690 --> 00:06:16,430
列。

101
00:06:16,560 --> 00:06:22,260
实际上并非如此，因此我们只需要在此处做一些事情来指定Python

102
00:06:22,250 --> 00:06:24,690
数据集中没有标题。

103
00:06:24,840 --> 00:06:31,440
为了指定此参数，我们需要在此处添加此标头参数，并且必须将其设置为等于

104
00:06:31,860 --> 00:06:32,770
没有。

105
00:06:33,260 --> 00:06:33,880
好吧。

106
00:06:34,000 --> 00:06:40,860
现在，您将看到，如果我们再次选择此行并执行得当，数据集将重新导入

107
00:06:41,000 --> 00:06:42,630
这次没有标题。

108
00:06:42,810 --> 00:06:45,380
现在您可以看到我们看一下数据集。

109
00:06:45,540 --> 00:06:48,630
好吧，我的确要扩大这个范围。

110
00:06:49,010 --> 00:06:49,560
现在我们开始。

111
00:06:49,590 --> 00:06:55,050
我们没有专栏的标题，但您知道这第一个观察不再被视​​为

112
00:06:55,050 --> 00:06:58,270
列的标题，但这是真正的观察结果。

113
00:06:58,310 --> 00:07:02,000
好的，现在更好，让我们描述数据集。

114
00:07:02,000 --> 00:07:08,150
因此，正如我告诉您的那样，我们正在为法国南部的一家商店建立先验模型。

115
00:07:08,280 --> 00:07:13,650
因此，我们想找出这次旅行的不同产品的关联规则，以了解

116
00:07:13,640 --> 00:07:19,700
该商店的经理可以优化其不同产品的放置，以优化销售。

117
00:07:19,740 --> 00:07:19,990
好。

118
00:07:20,000 --> 00:07:25,710
因此，现在首先要说的是，这家商店位于该市最受欢迎的地方之一

119
00:07:25,710 --> 00:07:26,570
法国南部。

120
00:07:26,610 --> 00:07:32,570
所以很多人进入商店，所以你知道这个地方是一个非常欢乐的地方，非常友好

121
00:07:32,580 --> 00:07:36,510
人们喜欢闲逛的地方，彼此放松交谈。

122
00:07:36,500 --> 00:07:42,450
因此，这些人经常来此旅游，因为即使不是出于某种原因，这也是一个地方

123
00:07:42,450 --> 00:07:43,610
认识他们的朋友。

124
00:07:44,040 --> 00:07:49,200
因此，商店的经理注意到并计算出，平均每个客户

125
00:07:49,200 --> 00:07:51,860
每周一次去商店买东西。

126
00:07:51,870 --> 00:07:58,740
因此，这里的数据集包含所有不同客户的七千五百笔交易

127
00:07:58,740 --> 00:08:02,250
整整一周购买了一篮子产品。

128
00:08:02,250 --> 00:08:07,090
确实，经理将其作为分析的基础，因为既然每个客户都在平均

129
00:08:07,110 --> 00:08:13,320
每周一次到商店，那么一周内注册的交易就可以代表什么

130
00:08:13,320 --> 00:08:14,900
客户要购买。

131
00:08:14,900 --> 00:08:22,940
因此，基于所有这7500笔交易，我们的机械模型和先验模型将学习

132
00:08:22,940 --> 00:08:27,220
可以理解实际规则的各种不同关联。

133
00:08:27,330 --> 00:08:33,080
例如，如果客户购买了该产品，那么他们很可能会购买另一套产品。

134
00:08:33,090 --> 00:08:37,970
这就是我们要弄清楚的，这就是我们的高级模式将告诉我们的。

135
00:08:38,120 --> 00:08:38,800
好。

136
00:08:39,060 --> 00:08:45,720
因此，这里的每条观察线都对应于购买特定篮子产品的特定客户

137
00:08:45,740 --> 00:08:45,880
。

138
00:08:45,990 --> 00:08:52,270
因此，例如，如果您查看的是对应于一位购买汉堡肉的客户的行，

139
00:08:52,320 --> 00:08:55,780
肉丸和鸡蛋在本周的特定时间。

140
00:08:55,910 --> 00:09:00,200
对于与其他客户相对应的所有其他观察结果，也是如此。

141
00:09:00,240 --> 00:09:05,000
或者，也许是第二天或另一天又去商店的同一位客户。

142
00:09:05,040 --> 00:09:06,870
这就是该数据集的目的。

143
00:09:06,870 --> 00:09:11,440
既然我们已经了解了问题和挑战，那么我们就可以实际创建模型了。

144
00:09:11,490 --> 00:09:15,610
因此，我将在此处单击“确定”，然后我们开始。

145
00:09:15,960 --> 00:09:21,950
因此，当我们使用Priory的主要实现方法时，首先要了解的重要一点

146
00:09:21,960 --> 00:09:27,090
模型是我们需要以特定方式导入数据集。

147
00:09:27,540 --> 00:09:34,290
如您所见，数据集只是一个数据框，其中每一行代表不同的交易

148
00:09:34,470 --> 00:09:36,770
商店中的顾客数量。

149
00:09:37,950 --> 00:09:38,970
所以

150
00:09:38,990 --> 00:09:46,510
。

151
00:09:50,120 --> 00:09:51,640
这样就可以弹出了。

152
00:09:51,720 --> 00:09:54,520
所以可能是这样。

153
00:09:54,890 --> 00:09:57,600
所以可能是然后放了。

154
00:09:57,650 --> 00:10:02,290
因此，这可能是我们稍后将要使用的主要功能的输入。

155
00:10:02,510 --> 00:10:11,040
但实际上并非如此，Priory期望什么，因为输入实际上是列表列表。

156
00:10:11,180 --> 00:10:16,560
那是一个包含不同事务的列表，每个事务都放在一个列表中。

157
00:10:16,740 --> 00:10:23,090
因此，您将知道这个大清单包含所有不同的交易

158
00:10:23,100 --> 00:10:26,150
交易本身就是一个清单。

159
00:10:26,150 --> 00:10:31,410
所以这不是现在数据集的结构，因为它只是一个包含所有内容的数据框

160
00:10:31,400 --> 00:10:37,280
每个交易的不同交易和行首先不是列表，整个集合是

161
00:10:37,290 --> 00:10:38,570
不是列表本身。

162
00:10:38,580 --> 00:10:45,260
因此，这就是我们现在要做的，我们将正确地准备输入以实现先验功能

163
00:10:45,260 --> 00:10:50,150
那就是我们将在以后使用并正确准备它，我们将在此处建立此列表

164
00:10:50,150 --> 00:10:50,950
列表。

165
00:10:51,140 --> 00:10:51,440
好。

166
00:10:51,450 --> 00:10:52,670
因此，让我们这样做。

167
00:10:52,710 --> 00:10:59,780
这将需要两个FOR循环，因为我们将遍历数据中的所有事务

168
00:10:59,780 --> 00:11:00,420
组。

169
00:11:00,450 --> 00:11:01,440
那是第一个循环。

170
00:11:01,640 --> 00:11:08,020
第二个循环将遍历每个事务中的所有产品。

171
00:11:08,100 --> 00:11:09,800
因此，这将非常简单。

172
00:11:10,040 --> 00:11:12,980
一旦循环准备好，它将完全有意义。

173
00:11:13,200 --> 00:11:18,840
好的，所以首先像往常一样，当我们进行循环时，我们必须初始化要使用的变量

174
00:11:18,840 --> 00:11:20,340
在循环中使用。

175
00:11:20,340 --> 00:11:23,870
因此，此变量当然是事务列表。

176
00:11:24,000 --> 00:11:27,200
因此，我们将其称为可变交易。

177
00:11:27,480 --> 00:11:28,320
好吧。

178
00:11:28,590 --> 00:11:34,030
并初始化列表和5，然后我们只需要在此处放置一些方括号即可。

179
00:11:34,280 --> 00:11:37,870
然后创建一个空列表，一个空向量。

180
00:11:37,880 --> 00:11:38,070
好。

181
00:11:38,100 --> 00:11:40,140
因此，这是第一步简单的步骤。

182
00:11:40,140 --> 00:11:42,570
现在让我们开始循环吧。

183
00:11:42,570 --> 00:11:48,570
因此，正如我告诉您的那样，我们将进行2个for循环，第一个用于进行所有事务

184
00:11:48,570 --> 00:11:48,930
。

185
00:11:48,990 --> 00:11:54,870
为此，我们将首先输入4，然后为索引指定一个名称，

186
00:11:54,870 --> 00:12:00,000
将是我，我将取交易的所有索引的值。

187
00:12:00,050 --> 00:12:06,570
正如您在此处看到的，交易使索引从零上升到七千五百

188
00:12:06,580 --> 00:12:07,590
还有一个。

189
00:12:07,590 --> 00:12:16,140
因此，我们需要在此处输入以下范围的值：

190
00:12:16,380 --> 00:12:21,250
零到七千零一十一。

191
00:12:21,260 --> 00:12:21,560
好吧。

192
00:12:21,570 --> 00:12:28,040
因此请记住，在此范围函数中，此处包含了下限零，但包含了上限七

193
00:12:28,030 --> 00:12:30,920
这里不包括501。

194
00:12:30,920 --> 00:12:37,360
所以基本上这意味着我要把值从零增加到七千五百

195
00:12:37,370 --> 00:12:37,690
。

196
00:12:37,860 --> 00:12:43,850
这正是我们想要的，因为所有不同的事务都将索引从零开始

197
00:12:43,860 --> 00:12:46,780
到七千五百

198
00:12:46,790 --> 00:12:49,250
因此，我们需要在此处添加一列。

199
00:12:49,350 --> 00:12:52,790
那只是许可证和税收，然后输入。

200
00:12:52,820 --> 00:12:56,810
现在，我们处于第一个循环中，处理所有不同的事务。

201
00:12:56,820 --> 00:13:02,340
因此，现在基本上，我们要做的事情是针对与每个索引相对应的每个事务。

202
00:13:02,360 --> 00:13:07,450
听说我们要创建此交易的不同产品的列表。

203
00:13:07,560 --> 00:13:14,550
因此，我们要做的只是简单地将初始化为空的交易清单

204
00:13:14,540 --> 00:13:18,060
在此处列出，其中包含所有不同的交易。

205
00:13:18,200 --> 00:13:25,710
然后，我们将使用append函数，它将向其中添加每个不同的事务

206
00:13:25,700 --> 00:13:27,610
整个交易清单。

207
00:13:27,620 --> 00:13:29,990
这就是整个交易清单。

208
00:13:30,120 --> 00:13:34,640
而且我们将附加到不同客户的不同交易中。

209
00:13:34,860 --> 00:13:35,130
好。

210
00:13:35,120 --> 00:13:39,330
因此，根据您的需要，我们需要在此附加函数中输入什么。

211
00:13:39,480 --> 00:13:43,830
好吧，我们需要在列表中输入交易本身。

212
00:13:43,860 --> 00:13:45,330
所以现在我们处于循环中。

213
00:13:45,410 --> 00:13:50,370
因此，固定的ice值对应于特定交易。

214
00:13:50,380 --> 00:13:56,010
因此，现在此波段函数的事情我们正在添加对应的特定交易

215
00:13:56,000 --> 00:14:02,010
将此索引i纳入所有不同交易的整个交易清单中。

216
00:14:02,000 --> 00:14:07,610
所以基本上现在很简单，我们在这个附加函数中添加了特定的事务

217
00:14:07,760 --> 00:14:09,240
索引。

218
00:14:09,480 --> 00:14:12,040
因此，现在我们如何添加此特定交易。

219
00:14:12,170 --> 00:14:17,240
好吧，我们可以简单地通过添加此事务的所有不同产品来做到这一点。

220
00:14:17,250 --> 00:14:18,700
这些是什么产品。

221
00:14:18,890 --> 00:14:23,420
好吧，我们可以通过获取数据集的正确值来获取它们。

222
00:14:23,630 --> 00:14:25,900
那么这些正确的价值观是什么。

223
00:14:26,030 --> 00:14:33,040
好吧，这些正确的值对应于通过眼睛索引的交易数据集中的产品

224
00:14:33,080 --> 00:14:33,170
。

225
00:14:33,240 --> 00:14:35,920
然后我们需要获取此交易的所有产品。

226
00:14:35,930 --> 00:14:41,870
因此，在此交易中，我们需要将所有Jay都放在此处，并按眼睛索引，

227
00:14:41,880 --> 00:14:50,490
我们在其中使用所有的for循环，并使用其他后续步骤，我们在这里结束了范围内的J

228
00:14:50,850 --> 00:14:57,010
然后我们需要获取数据集的所有列，就像今天看到的20列一样

229
00:14:57,060 --> 00:14:57,610
组。

230
00:14:57,840 --> 00:15:05,190
因此，由于Python中的索引从零开始，所以我们需要将J的值从零变为20

231
00:15:05,200 --> 00:15:05,410
。

232
00:15:05,600 --> 00:15:06,120
好的。

233
00:15:06,190 --> 00:15:07,020
现在要小心。

234
00:15:07,010 --> 00:15:08,680
我们只需要再做一件事。

235
00:15:08,730 --> 00:15:15,340
我们不能以这种方式获取数据集的值，我们需要在此处添加记住的点值，谢谢

236
00:15:15,340 --> 00:15:21,150
为此，我们将能够获取数据集的值，现在我们只需要添加两件事即可。

237
00:15:21,200 --> 00:15:26,460
您知道吗，我们希望每个交易都成为一个列表，我们希望每个交易都包含

238
00:15:26,550 --> 00:15:29,340
列表中的所有不同产品。

239
00:15:29,420 --> 00:15:35,540
因此，做到这一点非常简单，我们只需要在此处和此处添加一些括号即可。

240
00:15:35,580 --> 00:15:39,180
所以您现在知道所有这些由J索引的产品。

241
00:15:39,260 --> 00:15:45,350
由于这些括号，我认为这个特定交易包含在列表中

242
00:15:45,360 --> 00:15:52,020
此时此刻，我们要做的最后一件事是使整个交易清单准备好成为

243
00:15:52,010 --> 00:15:58,730
先验功能的输入实际上是将交易中的所有产品设置为字符串

244
00:15:59,000 --> 00:16:02,050
这完全是由于构建函数方法的方式。

245
00:16:02,210 --> 00:16:07,090
它期望将不同的产品和不同的交易作为字符串。

246
00:16:07,350 --> 00:16:15,500
还有两个所说的示威者，我们只需要使用S T R函数来设置所有数据集点值

247
00:16:15,850 --> 00:16:15,970
。

248
00:16:16,350 --> 00:16:21,910
这对应于由I索引为字符串的交易中的不同产品。

249
00:16:22,080 --> 00:16:27,420
因此，它将做的是您知道我们是否不能很好地使用交易功能

250
00:16:27,410 --> 00:16:31,360
就像我们在数据集中一样，将仅具有不同产品的名称。

251
00:16:31,430 --> 00:16:36,110
但是，如果我们像现在一样将用作您的功能，那么不同的交易将

252
00:16:36,120 --> 00:16:42,060
用引号包含产品名称，这正是他对初级产品未来的期望

253
00:16:42,060 --> 00:16:45,630
我们将在下一个教程中使用该函数来构建规则。

254
00:16:45,880 --> 00:16:46,300
好的。

255
00:16:46,320 --> 00:16:47,500
现在准备就绪。

256
00:16:47,730 --> 00:16:55,420
我们完成了2个for循环，并准备了每个交易的整个交易清单

257
00:16:55,430 --> 00:16:59,720
是下一步的预购产品列表。

258
00:16:59,730 --> 00:17:04,550
因此，当然，现在我们将执行此操作，并看看我们刚刚做了什么。

259
00:17:04,700 --> 00:17:05,640
因此，让我们开始吧。

260
00:17:05,630 --> 00:17:10,220
按Commander Control按Enter执行，然后开始。

261
00:17:10,220 --> 00:17:11,870
交易准备就绪。

262
00:17:11,880 --> 00:17:18,570
所以，您首先看到的是，现在交易不再是数据框架，而是它的列表

263
00:17:18,570 --> 00:17:22,590
包含751个元素的列表。

264
00:17:22,590 --> 00:17:23,700
因此，让我们打开它。

265
00:17:23,720 --> 00:17:29,220
好的，现在我们可以清楚地看到该事务是我们刚刚构建的变量列表

266
00:17:29,210 --> 00:17:33,990
751个元素，每个元素本身都是一个列表。

267
00:17:34,080 --> 00:17:39,810
它是客户根据特定交易追逐的不同产品的列表

268
00:17:39,830 --> 00:17:40,150
。

269
00:17:40,430 --> 00:17:40,730
好。

270
00:17:40,740 --> 00:17:44,660
因此，让我们结束这一步，我们完成了第一步。

271
00:17:44,690 --> 00:17:51,470
实际上，我们已经准备好在数据集上训练预重构，以了解规则，这就是

272
00:17:51,470 --> 00:17:53,300
在下一个教程中我们将要做的是。

273
00:17:53,340 --> 00:17:58,200
因此，我期待着在那里见到您，并开始与您建立规则，直到那时，Jeremy应该

274
00:17:58,190 --> 00:17:58,640
学习

