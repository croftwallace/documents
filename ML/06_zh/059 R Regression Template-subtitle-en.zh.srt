1
00:00:00,210 --> 00:00:05,420
您好，欢迎来到Tauriel这门艺术，所以我们辛苦工作不会提任何提法或任何模型

2
00:00:05,430 --> 00:00:10,130
我们将要制作一个模板，这将是我们的回归模板。

3
00:00:10,140 --> 00:00:14,560
因此，该模板对于接下来的非线性回归道德将非常有用。

4
00:00:14,550 --> 00:00:19,590
我们将像建模决策树回归模型和随机模型一样进行建模

5
00:00:19,590 --> 00:00:20,770
回归模型。

6
00:00:20,790 --> 00:00:24,760
因此，我们将使用此模板来构建这三个下一个模型以及我们的模型。

7
00:00:24,900 --> 00:00:31,110
而且您还可以使用此模板为您的特定问题创建回归模型，因为

8
00:00:31,110 --> 00:00:36,090
您会看到您只需要更改几件事，就可以非常轻松地建立机械模型

9
00:00:36,090 --> 00:00:37,100
有效率的。

10
00:00:37,500 --> 00:00:43,530
因此，让我们对此进行一些说明，并使其与多项式回归中所做的一样

11
00:00:43,650 --> 00:00:45,300
并概括整个事情。

12
00:00:45,420 --> 00:00:52,920
因此，我将从这里开始到最终副本的所有内容，并将其粘贴到模板中

13
00:00:52,920 --> 00:00:53,100
。

14
00:00:53,100 --> 00:00:55,750
现在让我们制作这个模板。

15
00:00:56,200 --> 00:00:58,710
好的，首先让我们从头开始。

16
00:00:58,830 --> 00:01:01,480
因此，开始是关于数据预处理。

17
00:01:01,530 --> 00:01:03,420
因此，实际上这里没有任何更改。

18
00:01:03,420 --> 00:01:08,220
我们当然会保留这两行，因为在提交和

19
00:01:08,220 --> 00:01:10,550
在其上建立非线性回归模型。

20
00:01:10,650 --> 00:01:15,450
出于与之前相同的原因，我们希望将数据集拆分为训练集，其原因是

21
00:01:15,450 --> 00:01:19,830
这是一个很小的数据集，我们将在此处保留功能扫描作为注释。

22
00:01:19,860 --> 00:01:24,900
由于大多数库不需要我们手动应用功能。

23
00:01:25,260 --> 00:01:31,760
因此，对于预处理阶段而言，这都是一件好事，这将是我们回归模板的第一部分。

24
00:01:31,770 --> 00:01:32,040
大。

25
00:01:32,040 --> 00:01:33,650
现在，让我们继续下一部分。

26
00:01:33,840 --> 00:01:39,970
因此，下一部分是关于创建模型，创建模型并将其拟合到数据集。

27
00:01:40,050 --> 00:01:45,690
因此，首先在之前的Statoil中，我们建立了两个回归模型：线性回归模型和

28
00:01:45,690 --> 00:01:50,520
多项式回归模型，那只是比较两个结果并向您展示

29
00:01:50,560 --> 00:01:56,310
多项式回归更适合我们的问题，因为它不是线性回归

30
00:01:56,310 --> 00:02:00,470
与线性回归模型相对的线性回归模型相反。

31
00:02:00,540 --> 00:02:06,750
因此，我们这样做只是为了使您可以非常清楚地了解线性模型与

32
00:02:06,750 --> 00:02:07,950
非线性模型。

33
00:02:08,070 --> 00:02:12,810
但是现在我们已经很清楚了，我们将在这里删除有关本节的内容。

34
00:02:12,810 --> 00:02:19,320
线性回归，因为现在我们有了主意，我们将只关注新的非线性回归

35
00:02:19,320 --> 00:02:24,540
自己建模而不将其与线性回归模型进行比较，但保留图形结果

36
00:02:24,540 --> 00:02:26,410
考虑线性回归模型。

37
00:02:26,460 --> 00:02:29,520
请记住，这是一条直线，不太适合。

38
00:02:29,520 --> 00:02:35,610
数据已设置，因此不适用于非线性数据的数据集

39
00:02:35,620 --> 00:02:36,710
分散式。

40
00:02:37,060 --> 00:02:41,130
好的，所以我们将摆脱此问题。

41
00:02:41,310 --> 00:02:46,330
现在，我们这里只有这个代码部分，它自己创建了非线性回归模式。

42
00:02:46,380 --> 00:02:52,310
因此，我们将摆脱这一点，因为这与多项式回归相对应并进行了概括

43
00:02:52,320 --> 00:03:02,820
我们将只在此处添加一个来指定必须在此处创建进度的位置或就在此处

44
00:03:02,840 --> 00:03:03,250
。

45
00:03:03,600 --> 00:03:04,490
好。

46
00:03:04,500 --> 00:03:12,450
在这里，我们也可以用回归模型代替多项式回归，我们都擅长

47
00:03:12,450 --> 00:03:13,380
这个部分。

48
00:03:13,650 --> 00:03:13,910
好。

49
00:03:13,920 --> 00:03:18,260
现在，让我们继续下一个，下一个是关于可视化结果。

50
00:03:18,270 --> 00:03:24,720
因此，出于与本节所述相同的原因，以使回归适合数据集，我们将

51
00:03:24,720 --> 00:03:30,750
摆脱线性回归模型的图形结果，因为我们铭记在心，而且我们只

52
00:03:30,750 --> 00:03:34,470
希望专注于我们未来的非线性回归模型。

53
00:03:34,470 --> 00:03:36,350
因此，让我们摆脱它。

54
00:03:36,510 --> 00:03:41,780
现在，我们只有未来的非线性回归模型的图形结果。

55
00:03:42,030 --> 00:03:42,690
好的。

56
00:03:42,690 --> 00:03:47,190
这个模板的妙处在于，在本节中，我们将需要使用

57
00:03:47,280 --> 00:03:56,040
几乎所有的东西，因为我们要用回归模型代替多项式回归，并且我们要

58
00:03:56,040 --> 00:03:57,110
改变这个。

59
00:03:57,120 --> 00:04:03,480
保罗，您认为回归者在这里是回归回归者，因为您在我们将其称为Polly rag之前就已经知道

60
00:04:03,480 --> 00:04:06,470
因为我们也有我们的Linnea我们的侵略者Lin Ray。

61
00:04:06,630 --> 00:04:08,520
因此，我们需要加以区分。

62
00:04:08,610 --> 00:04:14,430
但是现在，由于我们摆脱了线性回归模型，我们将其称为未来的非线性回归

63
00:04:14,430 --> 00:04:19,540
在这里建立回归模型，这就是为什么我们在这里建立回归模型和谓词功能的原因。

64
00:04:19,770 --> 00:04:25,200
因此，基本上，当我们到达本节时，我们将构建未来的非线性回归模型

65
00:04:25,200 --> 00:04:29,370
我们将需要更改的内容实际上是此处的标题。

66
00:04:29,370 --> 00:04:34,650
基本上，我们在这里没有什么可更改的，这对这个模板来说是很棒的事情。

67
00:04:34,680 --> 00:04:39,630
但是，当然，如果您在数据集上使用此模板，那么唯一的问题就是问题

68
00:04:39,630 --> 00:04:45,240
您需要更改的是自变量的名称，以及

69
00:04:45,240 --> 00:04:50,080
因变量，您必须将薪水替换为因变量的名称

70
00:04:50,090 --> 00:04:50,280
。

71
00:04:50,490 --> 00:04:51,210
但是，仅此而已。

72
00:04:51,330 --> 00:04:57,660
好的，我们最终到达此代码模板的最后一部分，该部分有关预测

73
00:04:57,660 --> 00:05:00,850
最终结果以获得我们的最终裁决。

74
00:05:01,080 --> 00:05:06,720
好吧，与之前相同的原因，我们将为此放弃线性回归部分。

75
00:05:06,720 --> 00:05:07,770
所以我们开始。

76
00:05:07,810 --> 00:05:08,530
再见。

77
00:05:08,730 --> 00:05:12,810
现在，我们只剩下多项式回归预测了。

78
00:05:13,080 --> 00:05:14,310
好，太棒了。

79
00:05:14,310 --> 00:05:16,590
所以现在我们只需要在这里进行一些更改。

80
00:05:16,590 --> 00:05:22,730
首先，它是攻击者的名称，因为对于我们拉他们的名称，您的回归回归器

81
00:05:22,790 --> 00:05:24,410
被称为POLLI抹布。

82
00:05:24,580 --> 00:05:29,350
现在，由于我们不会在线性回归模型和被提名人之间进行区分

83
00:05:29,350 --> 00:05:32,780
模型那么我们的侵略者将被称为回归者。

84
00:05:33,160 --> 00:05:34,700
所以在这里，我们是侵略者。

85
00:05:34,960 --> 00:05:41,650
在这里，您知道对于多项式回归，我们需要输入数据框的多项式特征

86
00:05:41,740 --> 00:05:43,640
我们在数据框中创建的

87
00:05:43,780 --> 00:05:50,620
好吧，我们将不需要为下一个非线性模型执行此操作，因为这严格针对于

88
00:05:50,620 --> 00:05:54,780
多项式回归模型，您需要在其中添加这些多项式特征。

89
00:05:55,060 --> 00:05:59,510
因此，我们将摆脱这一点，并获得一些非常简单的东西。

90
00:05:59,590 --> 00:06:08,500
实际上，这条线可以完美预测6.5级职位的薪水，因为在

91
00:06:08,500 --> 00:06:13,790
我们未来的非线性回归模型将不会在数据集中包含那些多项式特征

92
00:06:13,900 --> 00:06:21,640
这里只需要原始的自变量，尤其是该自变量的6.5值

93
00:06:21,660 --> 00:06:21,870
。

94
00:06:22,060 --> 00:06:25,670
这就是为什么我们用这条简单的线就能满足所有需求。

95
00:06:25,870 --> 00:06:26,760
好，太棒了。

96
00:06:26,920 --> 00:06:34,330
现在，我要做的最后一件事可能是削减此代码段，而实际上

97
00:06:34,330 --> 00:06:40,960
将其放置在模型的创建和可视化之间，因为我喜欢保持

98
00:06:40,960 --> 00:06:47,380
最好的结果，对我来说最好的部分，最令人兴奋的部分是我们可视化我们的部分

99
00:06:47,470 --> 00:06:48,230
结果。

100
00:06:48,280 --> 00:06:54,190
第二个原因是我们知道我们的问题不在他们的问题中，因此

101
00:06:54,190 --> 00:06:55,990
我们需要一个非线性或侵略者。

102
00:06:55,990 --> 00:06:58,010
我们已经对此深信不疑。

103
00:06:58,030 --> 00:07:03,730
这就是为什么我们不需要在此代码段之前执行此代码段即可说服自己我们

104
00:07:03,730 --> 00:07:06,560
确实需要，而不是在回归模型中。

105
00:07:06,610 --> 00:07:12,130
因此，对于下一个回归模型，将在可视化结果之前进行预测

106
00:07:12,130 --> 00:07:12,490
。

107
00:07:12,490 --> 00:07:14,580
这就是为什么我首先将其放在这里。

108
00:07:14,860 --> 00:07:15,210
好。

109
00:07:15,220 --> 00:07:17,310
所以我认为模板已经准备就绪。

110
00:07:17,380 --> 00:07:24,070
好吧，也许我们需要在这里更改多项式以尽可能地泛化模板。

111
00:07:24,090 --> 00:07:26,250
因此这里将用多项式代替。

112
00:07:26,410 --> 00:07:29,670
好吧，实际上，我们只是对结果进行预测。

113
00:07:29,770 --> 00:07:30,490
好吧。

114
00:07:30,490 --> 00:07:36,460
在这里，我们可以用回归模型代替多项式回归。

115
00:07:36,520 --> 00:07:41,500
好吧，现在只对那些也有兴趣获得的人完成一盘

116
00:07:41,590 --> 00:07:44,320
更平滑的曲线，您的回归模型就会出现。

117
00:07:44,410 --> 00:07:49,190
好吧，这是我们可以提高分辨率的技巧，我们现在就要做

118
00:07:49,190 --> 00:07:49,210
。

119
00:07:49,210 --> 00:07:52,770
因此，这只是我在此模板中添加的可选代码部分。

120
00:07:52,810 --> 00:07:56,770
我将复制此内容，因为我们仅需更改一些内容。

121
00:07:57,010 --> 00:08:01,900
当您看到回归模型可视化时，您真正想要的是一条非常平滑的曲线

122
00:08:01,920 --> 00:08:04,810
结果很好，您可以使用以下代码。

123
00:08:04,810 --> 00:08:09,550
因此，诀窍是实际创建新的关卡序列。

124
00:08:09,550 --> 00:08:14,530
这意味着当我们仅预测10个级别的10个薪水时，我们将要做的是

125
00:08:14,530 --> 00:08:20,320
现在在本节中，我们将要预测的不是预测10个级别的10个薪水

126
00:08:20,320 --> 00:08:27,010
远远超过10个级别，为此，我们将建立一个虚拟级别的向量，

127
00:08:27,010 --> 00:08:30,960
从1到10的等级增加0.1。

128
00:08:31,060 --> 00:08:40,330
因此，这意味着我将考虑1级1.1 1.2 1.3至9.6 9:27九点八和九点

129
00:08:40,330 --> 00:08:40,860
九。

130
00:08:41,050 --> 00:08:46,660
这就是我们将在序列中创建的内容，因此这里不是预测仅10个薪水的

131
00:08:46,990 --> 00:08:51,250
我们将预测90个级别的90个薪水。

132
00:08:51,250 --> 00:08:52,270
这就是诀窍。

133
00:08:52,300 --> 00:08:58,690
建立这个序列实际上非常简单，我们将把序列x网格称为

134
00:08:58,990 --> 00:09:05,560
因为X网格将替换此处的数据集美元级别和此处的数据集，并且该X网格将替换为

135
00:09:05,560 --> 00:09:10,540
被定义为SEC，它是构建序列的功能。

136
00:09:10,870 --> 00:09:14,360
因此，在此功能中，我们需要输入三个参数。

137
00:09:14,470 --> 00:09:16,190
您序列的下限。

138
00:09:16,190 --> 00:09:23,560
这实际上是男性数据集级别，因为这样做会占用所有级别中的最小值

139
00:09:23,560 --> 00:09:25,390
在原始数据集中。

140
00:09:25,400 --> 00:09:31,240
好吧，下一个参数是级别10的上限。

141
00:09:31,450 --> 00:09:36,840
因此，我们对此处的最大数据集美元水平的最大值执行相同的操作。

142
00:09:36,870 --> 00:09:37,570
好吧。

143
00:09:37,720 --> 00:09:39,580
第三个参数是步骤。

144
00:09:39,580 --> 00:09:44,830
这就是我们提高分辨率并使拟合曲线更平滑的地方，因为我们要

145
00:09:44,830 --> 00:09:52,000
采取0.1的步长，因此将在这里创建90个级别（从1到10，以0.1递增）。

146
00:09:52,000 --> 00:09:52,350
好吧。

147
00:09:52,360 --> 00:09:57,760
这项工作实际上已经完成，现在我们需要在此处替换最初采用了

148
00:09:57,760 --> 00:09:59,380
我们数据集的10个级别。

149
00:09:59,410 --> 00:10:08,530
因此，我们将其替换为X网格，这里同样需要用新数据框替换此处的数据集

150
00:10:08,530 --> 00:10:13,290
因为您知道这里的这个新数据参数在这里期待一个数据帧。

151
00:10:13,300 --> 00:10:18,400
所以我们不能在这里直接用秘密取代它，因为X网格不是数据帧，而是一个序列

152
00:10:18,490 --> 00:10:19,920
那是一个向量。

153
00:10:20,080 --> 00:10:23,110
因此，我们在这里要做的是再次使用此小技巧。

154
00:10:23,290 --> 00:10:31,000
在这里使用此数据框数据非常简单Daut框注释实际上将创建一个数据

155
00:10:31,000 --> 00:10:37,080
框架，并在括号中指定要创建新级别的数据框架。

156
00:10:37,150 --> 00:10:43,420
因此，我在这里将无效级别设为等于，这就是您将前秘密放在哪里的原因，因为您

157
00:10:43,420 --> 00:10:50,860
知道通过执行此数据帧级别等于x网格，我们正在创建一个新的级别列，其中包含

158
00:10:50,920 --> 00:10:55,600
该序列x中的所有级别都在此处执行级别，仅此而已。

159
00:10:55,660 --> 00:11:01,240
这个新的代码部分准备好以更高的分辨率绘制回归模型结果，并且实际上

160
00:11:01,240 --> 00:11:09,220
我们将在此处指定用于更高的分辨率和平滑的曲线。

161
00:11:09,220 --> 00:11:09,610
好吧。

162
00:11:09,640 --> 00:11:14,080
实际上已经准备好了，因此您可以尝试一下，只要您知道要使用回归模型

163
00:11:14,080 --> 00:11:19,090
我们在本节中所做的，或者您可以将其用于未来的非线性回归模型中

164
00:11:19,090 --> 00:11:23,600
即将建立，您将看到两者之间的区别。

165
00:11:23,630 --> 00:11:28,450
然后，如果您要使用更简单的代码，则可以使用此代码；例如，如果您的数据集包含

166
00:11:28,450 --> 00:11:33,890
百个观察值加一，那么这就是您需要执行的代码，因为那样您就不会

167
00:11:33,890 --> 00:11:37,940
一步需要一个数字来建立拟合曲线的不同点。

168
00:11:38,230 --> 00:11:40,180
好的，现在模板已准备就绪。

169
00:11:40,230 --> 00:11:45,870
我们实际上已经准备好将其用于我们将要构建的下一个非线性回归模型。

170
00:11:46,030 --> 00:11:50,980
我们将在下一部分中进行介绍，您将看到如何高效地构建它们

171
00:11:50,980 --> 00:11:51,040
。

172
00:11:51,040 --> 00:11:53,350
因此，我期待与您一起创建这个模型。

173
00:11:53,410 --> 00:11:58,650
这将非常有趣，我们将以最有效的方式及早地制造它们。

