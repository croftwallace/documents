1
00:00:00,570 --> 00:00:02,720
您好，欢迎来到本Python教程。

2
00:00:02,970 --> 00:00:08,260
今天，我们迈出了一步，因为我们将要实施一种稍先进的机械

3
00:00:08,340 --> 00:00:13,680
多项式回归模型，并介绍多项式回归，我认为最好的方法

4
00:00:13,680 --> 00:00:18,750
在本部分的其余部分之前所做的事情和我们将要做的事情之间进行过渡

5
00:00:18,840 --> 00:00:20,230
关于回归。

6
00:00:20,280 --> 00:00:25,550
因此，我们之前所做的是足够简单的回归和多次回归。

7
00:00:25,800 --> 00:00:32,820
顾名思义，这些是线性回归函数，从现在开始，我们向前迈进了一步

8
00:00:32,820 --> 00:00:38,480
从某种意义上说，我们将建立不再是线性的新回归器。

9
00:00:38,700 --> 00:00:42,230
因此，多项式回归不是线性攻击者。

10
00:00:42,510 --> 00:00:47,000
然后我们将建立回归模型，它也不是线性回归器。

11
00:00:47,130 --> 00:00:52,350
然后我们将建立决策树回归模型，然后为我们随机建立回归模型

12
00:00:52,350 --> 00:00:55,070
也不是线性或回归。

13
00:00:55,320 --> 00:01:01,350
这就是为什么从今天起我们要制造一些新型的回归器

14
00:01:01,350 --> 00:01:07,620
回归模型，特别是对于我们而言，还是对我们而言是随机的

15
00:01:07,620 --> 00:01:14,010
与简单回归和多元回归相比，现在建立起来并没有那么先进

16
00:01:14,010 --> 00:01:20,060
我们将在回归方程的倍数中添加一个多项式项，您知道这不

17
00:01:20,160 --> 00:01:26,760
但是接下来的现状以及我们的回归将基于更复杂的理论

18
00:01:26,760 --> 00:01:27,140
。

19
00:01:27,210 --> 00:01:32,230
说到理论，我认为我们背后的理论实际上令人着迷。

20
00:01:32,610 --> 00:01:35,220
但是今天我们将执行多项式回归。

21
00:01:35,220 --> 00:01:37,810
因此，让我们立即开始在Python上进行操作。

22
00:01:38,170 --> 00:01:38,450
好。

23
00:01:38,460 --> 00:01:44,280
因此，像往常一样，我们将转到文件资源管理器以设置合法的逮捕工作目录，以便我们转到

24
00:01:44,580 --> 00:01:46,260
我们的机器或任何文件夹。

25
00:01:46,360 --> 00:01:49,320
第2部分回归多项式回归。

26
00:01:49,340 --> 00:01:50,660
那就是Reifler。

27
00:01:50,850 --> 00:01:54,870
当我们在您的文件夹中提交文件时，请确保您拥有职位oleracea。

28
00:01:54,870 --> 00:01:59,940
如果是这种情况，您可以单击此处的小按钮将此文件夹设置为工作目录

29
00:01:59,970 --> 00:02:00,280
。

30
00:02:00,950 --> 00:02:01,690
好。

31
00:02:01,950 --> 00:02:03,940
现在我们准备开始。

32
00:02:03,960 --> 00:02:10,030
因此，为了提高效率，我们将采用在第1部分中制作的数据和模板。

33
00:02:10,050 --> 00:02:12,290
因此，让我们在这里选择所有内容。

34
00:02:12,990 --> 00:02:18,910
将其复制并粘贴到我们的多项式回归模型中。

35
00:02:19,270 --> 00:02:23,630
所以现在我们只需要改变很少的事情。

36
00:02:23,640 --> 00:02:27,340
因此，我们需要更改的第一件事是数据集的名称。

37
00:02:27,390 --> 00:02:36,180
所以这里当然不是数据，而是职位和核心薪水。

38
00:02:36,300 --> 00:02:37,410
好吧。

39
00:02:37,410 --> 00:02:42,990
现在让我们看看是否需要为自变量x和x的矩阵更改一些索引。

40
00:02:43,230 --> 00:02:45,410
因变量向量y。

41
00:02:45,480 --> 00:02:51,050
因此，做到这一点的最佳方法是实际导入库，以供我们查看数据集。

42
00:02:51,060 --> 00:02:54,960
因此按命令控制我们并执行好很重要。

43
00:02:54,960 --> 00:02:55,640
完善。

44
00:02:55,680 --> 00:03:01,260
现在我们可以看一下我们的数据集，因为我们导入了bandas，我们在这里使用了bandas来导入

45
00:03:01,260 --> 00:03:02,380
CAC文件。

46
00:03:02,590 --> 00:03:03,190
好的。

47
00:03:03,390 --> 00:03:06,740
因此，我将执行导入好的该数据集。

48
00:03:06,840 --> 00:03:07,860
我们来看一下。

49
00:03:08,070 --> 00:03:14,190
我要去找一个可行的专家，这里是数据集，我们双击它，现在让我们

50
00:03:14,190 --> 00:03:15,620
看看任务是什么。

51
00:03:15,990 --> 00:03:21,480
因此，我们是为一家大公司工作的人力资源团队，我们即将在

52
00:03:21,480 --> 00:03:22,620
这家公司。

53
00:03:22,620 --> 00:03:28,290
因此，这名新员工似乎非常适合这份工作，我们将为此提供职位

54
00:03:28,290 --> 00:03:29,750
潜在的新员工。

55
00:03:30,150 --> 00:03:35,880
现在是时候就这名新员工的未来薪水进行谈判了

56
00:03:35,880 --> 00:03:36,900
在公司里。

57
00:03:37,290 --> 00:03:42,480
因此，在谈判开始时，这位新员工告诉他已有20多年的历史

58
00:03:42,480 --> 00:03:47,870
经验，最终在其先前的公司中获得16万的年薪。

59
00:03:47,910 --> 00:03:52,140
因此，该员工的要求至少为160 k。

60
00:03:52,200 --> 00:03:57,510
但是，HRT中有些人像是控制狂，总是幻想着被

61
00:03:57,510 --> 00:04:02,150
一个侦探突然决定打电话给前雇主检查该信息。

62
00:04:02,190 --> 00:04:08,330
您知道有关此未来潜在新员工以前的16万年薪的信息。

63
00:04:08,460 --> 00:04:15,180
但不幸的是，此人设法获得的所有信息都在这里，这是符号

64
00:04:15,180 --> 00:04:19,700
上一家公司10个不同职位的薪水表。

65
00:04:19,770 --> 00:04:26,070
因此，只有团队中的一位教会成员在Excel或Google表格上进行简单的分析，并实际上观察到

66
00:04:26,070 --> 00:04:32,010
这些医生的水平与其相关的工资之间没有关系

67
00:04:32,010 --> 00:04:33,000
。

68
00:04:33,000 --> 00:04:37,860
但是，此人力资源人员可能会获得另一个非常相关的信息。

69
00:04:37,870 --> 00:04:43,920
其他相关信息是，这名新员工现在已经担任地区经理两年了，通常

70
00:04:43,950 --> 00:04:49,320
从成为区域经理到成为合伙人，平均需要四年的时间。

71
00:04:49,470 --> 00:04:54,950
因此，该员工介于6级和7级之间，因此可以说他是9级

72
00:04:54,980 --> 00:04:56,180
6.5。

73
00:04:56,550 --> 00:05:02,070
所以现在这个H.R.家伙感到非常兴奋，因为他向团队出售了可以制造虚张声势的东西

74
00:05:02,070 --> 00:05:08,080
检测器使用回归模型并预测此新员工是否虚报其薪水。

75
00:05:08,490 --> 00:05:13,290
因此，一开始团队就发现它有点怪异，但好奇地想知道会发生什么

76
00:05:13,290 --> 00:05:16,470
发生，因此这是任务。

77
00:05:16,470 --> 00:05:23,340
这位新员工告诉我们，年薪是16万，让我们预测一下这是事实还是虚张声势

78
00:05:23,670 --> 00:05:28,380
通过使用多项式回归构建虚张声势检测器。

79
00:05:28,690 --> 00:05:29,070
好吧。

80
00:05:29,080 --> 00:05:31,870
现在，让我们看看我们需要更改哪些索引。

81
00:05:31,880 --> 00:05:37,210
因此，当我们在此处查看此表时，我们希望根据

82
00:05:37,210 --> 00:05:42,360
我们有，然后在这里预测6.5级的薪水。

83
00:05:42,380 --> 00:05:44,800
因此，基本上，我们在这里只需要这两列。

84
00:05:44,870 --> 00:05:51,250
我们不需要此列，因为它与您实际上知道的该列严格等效

85
00:05:51,250 --> 00:05:58,930
我们已经在这里知道了位置列的编码，您可以通过将每个级别关联到一个位置

86
00:05:58,940 --> 00:06:04,690
该表已经在此处进行编码，因此我们只需要这两列即可构建机械模型

87
00:06:04,820 --> 00:06:05,030
。

88
00:06:05,140 --> 00:06:10,570
记住，机器要引入整个回归，而这台机器将要学习相关性

89
00:06:10,570 --> 00:06:16,220
在级别和薪水之间进行调整，以预测员工是否虚张声势。

90
00:06:16,250 --> 00:06:21,420
因此，我们不会将此列包含在功能X的矩阵中，因此我们只会采用

91
00:06:21,440 --> 00:06:22,310
普通水平在这里。

92
00:06:22,330 --> 00:06:28,630
因此，简而言之，我们的特征X矩阵仅由一个独立变量组成，

93
00:06:28,630 --> 00:06:35,630
这里将是级别列，这里我们的因变量x或y将是这里薪水列

94
00:06:35,830 --> 00:06:39,250
包含10个不同职位的所有薪水。

95
00:06:39,670 --> 00:06:42,610
好的，那么这对索引意味着什么。

96
00:06:42,700 --> 00:06:45,950
这个数据框包含三列。

97
00:06:46,030 --> 00:06:51,190
Python中的位置列，级别列和薪水列索引开始为零。

98
00:06:51,190 --> 00:06:53,530
因此，这意味着此列具有退出行。

99
00:06:53,530 --> 00:06:56,560
此列下一个，此列旁边。

100
00:06:56,870 --> 00:07:04,690
好吧，在斧头这里，我们将指定我们想要索引1并为我们的因变量矢量y

101
00:07:04,700 --> 00:07:07,950
在这里，我们将指定我们要索引。

102
00:07:07,960 --> 00:07:13,610
但是，我们可以在此处进行一些改进，因为您知道我是否在此处执行这两行以

103
00:07:13,610 --> 00:07:20,710
就像我刚刚看到的那样，创建特征矩阵和因变量矢量。

104
00:07:20,830 --> 00:07:26,930
好吧，为什么这里有一个向量，我们可以看到这个用逗号表示的东西，之后什么也没看到，但是我们可以看到

105
00:07:27,010 --> 00:07:32,460
X也被视为向量，因为我们仅在此处指定下一个。

106
00:07:32,710 --> 00:07:38,570
但是您知道当我们建立机器学习模型时，尤其是在这里，我们想要的回归模型

107
00:07:38,650 --> 00:07:44,280
我们的特征矩阵一直被视为矩阵，而不是矢量。

108
00:07:44,290 --> 00:07:48,460
因此，仅指定X是矩阵而不是矢量。

109
00:07:48,580 --> 00:07:51,850
我们也将在此处添加冒号。

110
00:07:51,940 --> 00:07:57,740
并且不要担心，在这里我不包括第二个索引，因为您知道a的上限

111
00:07:57,740 --> 00:08:00,390
Python中的范围不在此列。

112
00:08:00,580 --> 00:08:07,270
但是您将看到，通过这样做，x将被视为矩阵，因为您现在可以看到

113
00:08:07,270 --> 00:08:09,190
我将执行此行。

114
00:08:09,700 --> 00:08:15,640
现在您可以看到，您知道在我们有10个来之前，什么都没有，现在我们有10个来了1个，

115
00:08:15,640 --> 00:08:20,880
表示现在x可以看作是10行和1列的矩阵。

116
00:08:20,890 --> 00:08:27,130
因此，最好总是确保X是矩阵，y是向量，

117
00:08:27,130 --> 00:08:30,980
永远不会收到任何警告，甚至无法获得警告。

118
00:08:31,000 --> 00:08:32,380
就是这样。

119
00:08:32,380 --> 00:08:38,290
我们在这里选择了正确的索引，因此我们现在可以实际查看x和y。

120
00:08:38,570 --> 00:08:41,560
好，这里是X这里是y。

121
00:08:41,600 --> 00:08:43,630
因此，这里有10个职位级别。

122
00:08:43,660 --> 00:08:49,120
在这里，我们必须将10个薪水与这10个职位级别相关联。

123
00:08:49,120 --> 00:08:55,200
我们的目标是通过建立一个机器学习模型来预测该员工是否虚张声势

124
00:08:55,210 --> 00:09:03,650
一个多项式模型，它将在此处预测此6.5级的薪水

125
00:09:03,940 --> 00:09:08,240
为该新员工确定的人力资源团队成员。

126
00:09:08,480 --> 00:09:09,240
好。

127
00:09:09,520 --> 00:09:16,450
因此，我们执行此操作，然后继续进行第一个预处理步骤的下一个步骤和下一个

128
00:09:16,450 --> 00:09:20,040
步骤步骤是将数据集分为训练集和集合。

129
00:09:20,170 --> 00:09:24,210
实际上，好消息是我们将需要在此处进行操作。

130
00:09:24,250 --> 00:09:29,090
出于两个原因，这是因为当我们查看数据集时，可以看到我们有10个观测值

131
00:09:29,620 --> 00:09:35,260
当我们只有很少的观测值时，将

132
00:09:35,260 --> 00:09:41,260
将数据集放入测试集中的训练集中，因为我们根本没有足够的信息来训练

133
00:09:41,290 --> 00:09:44,610
一个模型上的一个模型，并在另一个模型上测试其性能。

134
00:09:44,620 --> 00:09:47,780
这没有多大意义，这有点荒谬。

135
00:09:47,890 --> 00:09:54,110
第二个原因是您知道我们要做出非常准确的预测，因为您知道

136
00:09:54,640 --> 00:09:56,320
我们在这里谈论的是真实的东西。

137
00:09:56,330 --> 00:10:01,900
我们正在尝试预测我们正在进行的谈判的核心要素

138
00:10:01,900 --> 00:10:07,390
这个新员工，所以我们不必错过这里的目标，因此我们需要做一个非常准确的

139
00:10:07,390 --> 00:10:08,260
预测。

140
00:10:08,330 --> 00:10:10,880
否则，谈判可能会变得很糟糕。

141
00:10:11,090 --> 00:10:17,170
为了做出最准确的预测，我们实际上需要获得尽可能多的信息

142
00:10:17,500 --> 00:10:21,360
因此模型可以完美地获取该数据集的相关性。

143
00:10:21,380 --> 00:10:27,030
这就是为什么只有这次我们才能允许自己使用整个数据集来训练我们的机器

144
00:10:27,040 --> 00:10:27,860
模型。

145
00:10:27,940 --> 00:10:33,770
所以这就是我们要做的，因此我们将把所有这部分放在注释中

146
00:10:33,760 --> 00:10:38,270
这里有三个引号，还有一个Dnt。

147
00:10:38,410 --> 00:10:39,280
开始了。

148
00:10:39,430 --> 00:10:44,810
现在这部分内容全部在注释中，因此将不会创建训练集和测试集

149
00:10:44,830 --> 00:10:45,240
。

150
00:10:45,590 --> 00:10:46,090
好的。

151
00:10:46,100 --> 00:10:52,100
最后是预处理阶段的最后一步，对特征进行缩放，因此我们需要应用特征

152
00:10:52,120 --> 00:10:53,650
在这里获取数据集。

153
00:10:53,870 --> 00:11:00,070
答案是否定的，因为您知道多项式回归实际上只是添加一些多项式

154
00:11:00,080 --> 00:11:06,520
项进入多元回归方程，因此我们将使用相同的线性回归库

155
00:11:06,730 --> 00:11:12,610
我们在多元回归中建立简单回归时使用的那个

156
00:11:12,620 --> 00:11:14,730
上一节中的模型。

157
00:11:14,920 --> 00:11:20,740
因此，我们都很好，不需要将来进行扫描，也不需要将数据集拆分为训练集

158
00:11:20,750 --> 00:11:23,480
并且测试集索引正确。

159
00:11:23,530 --> 00:11:25,120
我们知道我们要做的。

160
00:11:25,250 --> 00:11:27,010
一切都很好。

161
00:11:27,010 --> 00:11:29,580
我们准备继续进行下一步。

162
00:11:29,890 --> 00:11:34,970
因此，我期待在下一个教程中见到您，因为我们将开始构建轮询

163
00:11:34,960 --> 00:11:36,720
在回归模型中。

164
00:11:37,030 --> 00:11:38,970
在此之前，请享受机器学习。

