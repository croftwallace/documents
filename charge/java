

# Java是按引用传递还是按值传递
. 请记住，“引用”一词的含义与内存地址相同
. Java通过值传递所有信息 ，而不是通过引用传递所有信息-确保您记住这一点。当我们说所有内容时，我们指的是一切–对象，数 组（在Java中是对象），原始类型（例如int和floats）等–这些都在Java中按值传递。按值传递和按引用传递之间有什么区别？当将一个参数（甚至多个参数）传递给一个方法时，Java将在原始变量内创建一个或多个值的副本，并将其作为参数传递给该方法–这就是为什么将其称为按值传递。传递值的关键在于该方法将不会接收正在传递的实际变量，而只会接收存储在变量内部的值的副本


# 线程/工作内存/主内存 三者的关系
. 每个线程都有一个独立的工作内存，用于存储线程私有的数据
. Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问
. 线程对变量的操作(读取赋值等)必须在工作内存中进行。（线程安全问题的根本原因）


# 主内存和工作内存
. 主内存是在运行期间所有变量的存放区域，当工作内存是运行期间中某一线程独立私有的内存存放区域
. 线程间无法访问对方的工作内存空间，都是通过主内存交换来实现
. 主内存的变量在工作内存中的值是复制过去的副本，读写完成后刷新主内存，这意味着主内存如果发生了改变，工作内存并无法获得最新的结果
. 多个线程对一个共享变量进行修改时，都是对自己工作内存的副本进行操作，相互不可见。主内存最后得到的结果是不可预知的

# volatile 修饰
. 变量的修改对所有线程可见
. 禁止指令重排
. volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值


# Synchronized
. synchronized在运行时，会清空工作内存数据，并从主内存拷贝对象副本到工作内存再执行相应代码
. 可以保证方法或代码块在运行时，同一时刻只有一个线程可以进入到临界区（互斥性），同时它还保证了共享变量的内存可见性。
. 同步代码块使用了 monitorenter 和 monitorexit 指令实现
. 同步方法中依靠方法修饰符上的 ACC_SYNCHRONIZED 实现
. 在并发量不是很大，并且出现并发情况导致的异常用户和系统都很难以接受的情况下，会选择悲观锁进行

    
# synchronized (new object())同步时各种不同类别的监视器以及其引起的问题(常量池的影响)
. 整数和字符串都有一部分属于常量池，这只jvm自有的优化，在使用这两种对象作为同步监视器，则会出现不同步的现象


# 为什么说 Synchronized是非公平锁
 非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等
 待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，
 这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿现象
 
 
# 乐观锁
 乐观锁的核心算法是CAS（CompareandSwap，比较并交换），它涉及到三个操作数：内存值、预期值、新值。
 当且仅当预期值和内存值相等时才将内存值修改为新值。
 这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样，
 如不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，
 否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存
 一般乐观锁只用在高并发、多读少写的场景


# 对象锁和类锁区别
. 静态变量,静态方法和类信息一样也是存在方法区的并且整个JVM 只有一份,synchronized加在静态变量,静态方法上就是类锁
. 类锁是加载类上的而类信息是存在JVM方法区的，并且整个JVM只有一份，方法区又是所有线程共享的，所以类锁是所有线程共享的
. synchronized加在 实体里的非静态变量,this 对象,非静态方法，就是对象锁
. new 出来很多的实例对象, 在实例上加的锁和其他的实例就没有关系，互不影响了
. 普通对象锁，不同对象，可同时访问。相同对象，不同加锁代码，不可同时访问


# 创建线程的有哪些方式
. 继承 Thread 类创建线程类
. 通过 Runnable 接口创建线程类
. 通过 Callable 和 Future 创建线程
. 通过线程池创建

# ThreadLocal
. ThreadLocal 为每一个线程提供一个独立的副本，比如 static变量没有用 ThreadLocal修饰，多个线程访问是同一份资源，
  加上ThreadLocal修饰，不会被共享，而是每一个线程提供一个独立副本，每个线程号作为key，取自己对应value


# JVM 对 Java 的 原 生 锁 做 了 哪 些 优 化
. 一种优化是使用自旋锁，即在把线程进行阻塞操作之前先让线程自旋等
  待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程
  执行阻塞操作，避免了用户态到内核态的切换

# 线程上下文切换和进程上下文切换

1.线程上下文切换指啥？
  线程上下文切换指一个线程被暂停剥夺对CPU的使用权，另外一个线程被选中开始或者继续在CPU中运行的过程。
2.上下文切换的性能开销花费在哪里啦？
   操作系统保存和恢复上下文；
   调度器进行线程调度；
   处理器高速缓存重新加载；
   上下文切换也可能导致整个高速缓存区被冲刷，从而带来时间开销。
3.上下文切换的分类？
  上下文切换分为进程上下文切换和线程上下文切换，这是站在操作系统的层面来讲的，
  站在CPU的角度，它不知道什么进程、线程之类的东西，他只需要知道怎么取指令怎么执行就行啦！
4.上下文切换的发送场景？
  上下文切换分为两种，一是自发上下文切换，另一个是非自己上下文切换。
5.啥是自发上下文切换？怎么触发？
  自发性上下文切换指线程由Java 程序调用导致切出，在多线程编程中，执行调用以下方法或关键字，就会引发自发性上下文切换。
  sleep()
  wait()
  yield()
  join()
  park()
  synchronized
  lock
6.啥是非自发上下文切换？怎么触发？
  指线程由于调度器的原因被迫切出。常见的有：线程被分配的时间片用完，虚拟机垃圾回收导致或执行优先级的问题导致。
7.在多线程中使用 Synchronized 会发生进程间的上下文切换
  . 当Synchronized锁资源竞争激烈，线程将会被阻塞，阻塞的线程将会从用户态调用内核态，尝试获取mutex，
    这个过程是Synchronized锁产生的进程上下文切换
  . 进程间的上下文切换因为是用户态和内核态之间的切换，需要消耗更多的资源，例如，寄存器中的内容切换出，缓存的刷新等，
    而线程间的上下文切换是用户态的线程切换，由于是同一个虚拟内存，消耗资源相对较少
    
. 暂时先不要将线程状态和线程上下文切换和进程上下文切换联系起来，目前没有梳理清楚

# JAVA多线程实现-获取线程执行结果
  https://www.cnblogs.com/dennyzhangdd/p/7010972.html
. 实现Callable接口
 

# Java Spring中的Singleton(单例) 和Prototype(原型) Bean范围
. 如果作用域是单例，则每个Spring IoC容器将只实例化该bean的一个实例，并且为每个请求共享同一实例。那就是当一个bean的作用域被声明为singleton时，然后每当对该bean发出新请求时，spring IOC容器都会首先检查该bean的实例是否已经创建。如果已经创建，则IOC容器返回相同的实例，否则仅在第一个请求时才创建该bean的新实例

. 如果将范围声明为prototype，则每次对特定bean发出请求时，spring IOC容器都会创建该bean的新实例



# Spring中的Bean的五个作用域
. Singleton：将为每个Spring IoC容器的单个bean定义创建一个实例，并且对该对象的每个请求将共享同一对象
. Prototype：每次对该bean发出请求时，都会为单个bean定义创建一个新实例
. Request：每次对该bean发出HTTP请求时，都会为单个bean定义创建一个新实例。但是仅在可感知网络的Spring  ApplicationContext上下文中有效
. Session：将单个bean定义的作用域限定为HTTP会话的生命周期。但是仅在可感知网络的Spring ApplicationContext上下文中有效
. Global-Session：将单个bean定义的作用域限定为全局HTTP会话的生命周期。它也仅在可感知网络的Spring ApplicationContext上下文中有效


# 反射


# IOC容器的概念
. IOC容器就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中new相关的对象，应用程序由IOC容器进行组装。在Spring中BeanFactory是IOC容器的实际代表者

. Spring IOC容器如何知道哪些是它管理的对象呢？这就需要配置文件，Spring IOC容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。一般使用基于xml配置文件进行配置元数据，而且Spring与配置文件完全解耦的，可以使用其他任何可能的方式进行配置元数据，比如注解、基于java文件的、基于属性文件的配置都可以。
那Spring IOC容器管理的对象叫什么呢

# Bean的概念
. 由IOC容器管理的那些组成你应用程序的对象我们就叫它Bean， Bean就是由Spring容器初始化、装配及管理的对象，除此之外，bean就与应用程序中的其他对象没有什么区别了


# AOP简介与作用
- AOP简介
  . AOP 只是模式而已，实现方案大概就是运行时和编译时，具体方案那就更多
  . AOP技术是建立在JAVA语言的反射机制与动态代理机制之上的
  . AOP实际是GoF设计模式的延续，设计模式孜孜不倦追求的是调用者和被调用者之间的解耦,提高代码的灵活性和可扩展性，AOP可以说也是这种目标的一种实现
  . 应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持

- AOP主要功能及意图
  . 日志记录，性能统计，安全控制，事务处理，异常处理等等
  . 将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码


# String类
. String类创建了不可变的字符序列, 如果需要对字符串做很多修改，那么应该选择使用StringBuffer和StringBuilder类
. String s=new String("ABC") 将创建一个内容为"abc"的String对象，并且s指向这个对象
. 一旦s=s+"abc";这样的操作，那么将创建一个新的String对象来存放新的内容，原先的对象依旧在内存中，但是s不在指向它，那么这个对象就会成为垃圾内存，在某一个特定的时刻有Java虚拟机回收

# StringBuilder类和StringBuffer类
. StringBuilder的功能与StringBuffer类非常相似，因为它们都通过创建可变的字符序列来提供String类的替代方法
. StringBuilder实例不能安全地用于多个线程, StringBuffer则可以
. 单个线程中使用StringBuilder大多数实现中它会更快
. StringBuffer中的方法大都采用了synchronized 关键字进行修饰，因此是线程安全的，而StringBuilder没有这个修饰，可以被认为是线程不安全的

# HashMap和Hashtable
. Hashtable同步，线程安全，HashMap则不是
. Hashtable类的初始默认容量为11，而loadFactor为0.75
. HashMap建初始容量为16且负载因子为0.75
. HashMap都允许存储null键，但是应该只有一个null键, Hashtable则不允许
. 基于哈希表的Map接口的实现


# 线程分配内存大小
. 1.5以后默认1M了，之前默认是256K
. jvm中可以通过-xss设置


# 同步与异步
  https://www.zhihu.com/question/19732473
. 同步和异步关注的是消息通信机制 
. 所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
换句话说，就是由*调用者*主动等待这个*调用*的结果
. 异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用


# 阻塞与非阻塞
. 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态
. 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回
. 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程


# I/O多路复用技术（multiplexing）是什么
  https://www.zhihu.com/question/28594409
. 多路复用基于事件驱动来实现，事件驱动是多路复用的核心机制
. 首先要理解的是，操作系统为你提供了一个功能，当你的某个socket可读或者可写的时 候，它可以给你一个通知。这样当配合非阻塞的socket使用时，只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据而不做纯返回-1和EAGAIN的无用功。写操作类似。操作系统的这个功能通过select/poll/epoll/kqueue之类的系统调用函数来使用，这些函数都可以同时监视多个描述符的读写就绪状况，这样，多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，这就叫I/O多路复用，这里的“复用”指的是复用同一个线程


# IO多路复用
. select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作
. select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间


# IO多路复用中select、poll、epoll之间的区别
  https://blog.csdn.net/weixin_45727359/article/details/107373818
. select==>时间复杂度O(n)
  它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长

. poll==>时间复杂度O(n)
  poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的

. epoll==>时间复杂度O(1)
  epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）


# java 8种基本类型
. byte 1字节  boolen 至少一个字节
. char、short 2字节
. int、 float 4字节
. long、double 8字节


# JVM原理
  https://zhuanlan.zhihu.com/p/91274291
. jre:也就是Java平台。所有的Java 程序都要在JRE下才能运行
. jdk:编译、调试java程序用的开发工具包
. jvm:是JRE的一部分, 可以在上面执行java的字节码程序,就是 .class文件

- JVM栈
  . JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部 8种基本类型的变量
  . 非基本类型的对象在JVM栈上仅存放一个指向堆上的地址
  
- 堆（Heap）
  . 它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收
  . 堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的
  . Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配
  
- 方法区域（Method Area）
  . 方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息
  
- 运行时常量池（Runtime Constant Pool）
  . 存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配


- 判定对象是否存活
  . 引用计数算法：给对象中添加一个引用计数器，每当一个地方应用了对象，计数器加1；当引用失效，计数器减1；当计数器为0表示该对象已死、可回收。但是它很难解决两个对象之间相互循环引用的情况
  . 可达性分析算法：通过一系列称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（即对象到GC Roots不可达），则证明此对象已死、可回收
  . 主流的商用程序语言（如我们的Java）的主流实现中，都是通过可达性分析算法来判定对象是否存活的
  
  
- JVM垃圾回收
  . GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停
  . 对新生代的对象的收集称为minor GC；新生代内存不够用时候发生 MGC 也叫 YGC
  . 对旧生代的对象的收集称为Full GC； JVM 内存不够的时候发生 FGC
  . 程序中主动调用System.gc()强制执行的GC为Full GC
  
  - 不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型
  . 强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）
  . 弱引用：在GC时一定会被GC回收， Java常通过使用弱引用来避免内存泄漏，例如在JDK中有一种内存变量ThreadLocal
  . 软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）
  . 虚引用：由于虚引用只是用来得知对象是否被GC
. 详细回收查看 JVM文档
  
  
# 几种常用的内存调试工具：
. jstack 可以看当前栈的情况，jmap 查看内存，jhat 进行 dump 堆的信息
  
 
## springboot启动加载及快速搭建web框架


. Spring Boot父级依赖的概念, 用来提供相关的Maven默认依赖，使用它之后，常用的包依赖可以省去version标签
. Spring Boot提供了很多”开箱即用“的依赖模块,起步依赖 spring-boot-starter-xx的概念,封装好了你想要实现的功能的依赖
. 应用入口类的作用


# SpringBoot启动类
. http://tengj.top/2017/02/26/springboot1/
. 为了演示简单，我们不再新建控制类，而是直接在这个入口类中编写，添加@RestController以及index方法

@RestController
@SpringBootApplication
public class Chapter1Application {

	@RequestMapping("/")
	public String index(){
		return "Hello Spring Boot";
	}
	public static void main(String[] args) {
		SpringApplication.run(Chapter1Application.class, args);
	}
}
. @SpringBootApplication是Sprnig Boot项目的核心注解，主要目的是开启自动配置
. main方法这是一个标准的Java应用的main的方法，主要作用是作为项目启动的入口
. run()：负责springboot整个启动过程，包括加载创建环境、打印banner、配置文件、配置应用上下文，加载bean等等spingboot
         整个生命周期几乎都在run方法中
. @RestController注解等价于@Controller+@ResponseBody的结合，使用这个注解的类里面的方法都以json格式输出


  
# 微服务分布式事物
  https://zhuanlan.zhihu.com/p/36153160
  https://www.infoq.cn/article/thmgmfvqvpwp9yrrxpmw
. 解决方案，包括强一致性的两阶段提交协议，三阶段提交协议，以及最终一致性的可靠事件模式、补偿模式，阿里的 TCC 模式 
. XA 协议通过二阶段提交协议保证强一致性,第一阶段准备，第二阶段提交。这里，事务管理者（协调者）主要负责控制所有节点
  的操作结果，包括准备流程和提交流程
  
. TCC模式: 将一个任务拆分三个操作：Try、Confirm、Cance 。主业务服务）会向事务管理器注册并启动事务。其实，事务管理器是一个概念上的全局事务管理机制，可以是一个内嵌于主业务服务的业务逻辑，或者抽离出的一个 TCC 框架。当全部从业务服务都成功时，由事务管理器通过 TCC 事务上下文切面执行 Confirm 操作，将其状态设置成“成功”状态，否则执行 Cancel 操作将其状态设置成“预提交”状态，然后进行重试

. 可靠事件模式:  RocketMQ 事务消息的设计流程
  https://segmentfault.com/a/1190000021822374
	事务发起方首先发送 prepare 消息到 MQ。
	在发送 prepare 消息成功后执行本地事务。
	根据本地事务执行结果返回 commit 或者是 rollback。
	如果消息是rollback，MQ 将删除该 prepare 消息不进行下发，如果是commit 消息MQ将会把这个消息发送给consumer端。
	如果执行本地事务过程中，执行端挂掉，或者超时，MQ 将会不停的询问其同组的其他 producer 来获取状态。
	Consumer 端的消费成功机制有 MQ 保证
  
  
# 异常
. 无论是内部还是外部的微服务，在服务端我们都应该设计一个全局异常处理类，用来统一封装系统在抛出异常时面向调用方的返回信息。而实现这样一个机制，我们可以利用Spring提供的注解@ControllerAdvice来实现异常的全局拦截和统一处理功能
. @ControllerAdvice和@ExceptionHandler会捕获所有Controller层的异常并封装成我们定义的HttpResult的结果集返回，但是：处理不了拦截器里的异常


# Redis与Mysql双写一致性方案
  https://zhuanlan.zhihu.com/p/59167071
1. 先更新数据库，再更新缓存
2. 先删除缓存，再更新数据库
3. 先更新数据库，再删除缓存

1. 先更新数据库，再更新缓存
这套方案，大家是普遍反对的。为什么呢？有如下两点原因。

原因一（线程安全角度） 同时有请求A和请求B进行更新操作，那么会出现

（1）线程A更新了数据库
（2）线程B更新了数据库
（3）线程B更新了缓存
（4）线程A更新了缓存
这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑


3. 先更新数据库，再删除缓存
（1）更新数据库数据
（2）数据库会将操作信息写入binlog日志当中
（3）订阅程序提取出所需要的数据以及key
（4）另起一段非业务代码，获得该信息
（5）尝试删除缓存操作，发现删除失败
（6）将这些信息发送至消息队列
（7）重新从消息队列中获得该数据，重试操作


# 幂等性
  https://www.jianshu.com/p/475589f5cd7b
. 幂等有两个维度：
  一是空间维度上的幂等，即幂等对象的范围，是个人还是机构，是某一次交易还是某种类型的交易
  二是时间维度上的幂等，即幂等的保证时间，是几秒、几分钟还是永久性的
. 幂等的常用思路：
  MVCC
  去重表
  TOKEN机制
. 幂等性适用领域：
  在电商平台上支付后，因为网络原因导致系统提示你支付失败，于是你又重新付款了一次，等完成后检查网银发现被系统扣了两次款,
  幂等性是解决这类问题的方案之一，所以在电商，银行，互联网金融等对数据准确性要求很高的领域中，这一特性具有十分重要的地位


# mybatis常用对象SqlSessionFactory和SqlSession介绍和运用
  https://blog.csdn.net/u013412772/article/details/73648537
  -- mybatis框架主要是围绕着SqlSessionFactory进行的，创建过程大概如下
    . 定义一个Configuration对象，其中包含数据源、事务、mapper文件资源以及影响数据库行为属性设置settings
    . 通过配置对象，则可以创建一个SqlSessionFactoryBuilder对象
    . 通过 SqlSessionFactoryBuilder 获得SqlSessionFactory 的实例。
    . SqlSessionFactory 的实例可以获得操作数据的SqlSession实例，通过这个实例对数据库进行操作
    
. SqlSession对象完全包含以数据库为背景的所有执行SQL操作的方法,它的底层封装了JDBC连接,可以用SqlSession实例来直接执行被映射的SQL语句.每个线程都应该有它自己的SqlSession实例.SqlSession的实例不能被共享,同时SqlSession也是线程不安全的,绝对不能讲SqlSeesion实例的引用放在一个类的静态字段甚至是实例字段中.也绝不能将SqlSession实例的引用放在任何类型的管理范围中,比如Servlet当中的HttpSession对象中.使用完SqlSeesion之后关闭Session很重要,应该确保使用finally块来关闭它.


# MyBatis一级缓存详解
  https://mp.weixin.qq.com/s/4Puee_pPCNArkgnFaYlIjg
. 在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis 提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能
. 在两次相同查询语句中使用插入，会对一级缓存进行刷新，会导致一级缓存失效
. MyBatis 一级缓存其实就是 SqlSession 级别的缓存
. MyBatis 一级缓存最大的共享范围就是一个SqlSession内部，那么如果多个 SqlSession 需要共享缓存，则需要开启二级缓存


# MyBatis 一、二级缓存全详解
. 二级缓存默认是不开启的，需要手动开启二级缓存，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的
. 开启二级缓存的条件也是比较简单，通过直接在 MyBatis 配置文件中通过
  <settings>
	<setting name = "cacheEnabled" value = "true" />
  </settings>
. SqlSession 在未提交的时候，SQL 语句产生的查询结果还没有放入二级缓存中，这个时候 SqlSession2 在查询的时候是感受不到二级缓存的存在的
. insert,update,delete操作会清空所在namespace下的全部缓存
. 最后还是建议，放弃二级缓存，在业务层使用可控制的缓存代替更好

# mybatis 分页
. mybatis自带分页RowBounds:   //逻辑分页， 查询所有数据在内存中进行分页
.  mybatis自写sql或者通过分页插件PageHelper:   //物理分页, sql分页都属于物理分页
. 分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql
. 逻辑分页 内存开销比较大,在数据量比较小效率比物理分页高;在数据量很大的情况下,内存开销过大,容易内存溢出,不建议使用
. 物理分页 内存开销比较小,在数据量比较小的情况下效率比逻辑分页还是低,在数据量很大的情况下,建议使用物理分页

# sql事物
. 原子性：保证任务中的所有操作都执行完毕；否则，事务会在出现错误时终止，并回滚之前所有操作到原始状态。
. 一致性：如果事务成功执行，则数据库的状态得到了进行了正确的转变。
. 隔离性：保证不同的事务相互独立、透明地执行。
. 持久性：即使出现系统故障，之前成功执行的事务的结果也会持久存在。

. COMMIT：提交更改, 将自上次 COMMIT 命令或者 ROLLBACK 命令执行以来所有的事务都保存到数据库中
. ROLLBACK：回滚更改, 只能撤销自上次 COMMIT 命令或者 ROLLBACK 命令执行以来的事务
. SAVEPOINT：在事务内部创建一系列可以 ROLLBACK 的还原点, ROLLBACK TO SAVEPOINT_NAME;
. SET TRANSACTION：命名事务；

. @Transactional可以作用于接口、接口方法、类以及类方法上


# 常见的数据库优化方法
. 选取最适用的字段属性,数据库中的表越小，在它上面执行的查询也就会越快; 在可能的情况下，应该尽量把字段设置为NOTNULL
. 索引一般建在where 后跟的条件查询字段上
. 使用连接（JOIN）来代替子查询(Sub-Queries)
. 事务, 用到一系列的语句来完成某种工作，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来,
  事物以BEGIN关键字开始，COMMIT关键字结束; 在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到
  该事务结束
. 锁定表, 通过锁定表的方法来获得更好的性能,避免事物独占数据库
. 优化的查询语句 
  SELECT * FROM books WHERE name like "MySQL%"
  换用下面的查询，返回的结果一样，但速度就要快上很多
  SELECT * FROM books WHERE name >= "MySQL" and name < "MySQM"


# 消息队列（mq）是什么
  https://www.zhihu.com/question/54152397
. 比较主流的消息队列中间件主要有，Kafka、ActiveMQ、RabbitMQ、RocketMQ 等这几种
. 可以简单理解为 把要传输的数据放在队列中；把数据放到消息队列叫做生产者，从消息队列里边取数据叫做消费者
  - 为什么要用消息队列，也就是在问：用了消息队列有什么好处,
    . 解耦
    . 异步
    . 削峰/限流
. 高可用: 我们使用消息队列来做解耦、异步还是削峰，消息队列肯定不能是单机的,我们项目中使用消息队列，都是得集群/分布式 的。要做集群/分布式就必然希望该消息队列能够提供现成的支持，而不是自己写代码手动去实现
. 数据丢失问题: Redis可以将数据持久化磁盘上，万一Redis挂了，还能从磁盘从将数据恢复过来。同样地，消息队列中的数据也需要存在别的地方，这样才尽可能减少数据的丢失; RabbitMQ 会把信息保存在磁盘上
. 分布式事务：把下单，优惠券，积分。。。都放在一个事务里面一样，要成功一起成功，要失败一起失败


# RabbitMQ
. RabbitMQ 作用：异步，解耦，缓冲，消息分发。
. RabbitMQ 主要分为3个部分，生产者，交换机和队列，消费者。
. 需要注意消息持久化，目的为了防止 RabbitMQ 宕机；考虑 ACK 机制，目的为了如果消费者对消息的处理失败了，那么后续要如何处理。


# SpringBoot底层实现原理
. SpringBoot是一个快速开发框架，快速的将一些常用的第三方依赖整合（原理：通过Maven子父工程的方式），简化XML配置，全部采用注解形式，内置Http服务器（Jetty和Tomcat），最终以java应用程序进行执行
- SpringBoot核心原理: 
  . 基于SpringMVC无配置文件（纯Java）完全注解化+内置tomcat-embed-core实现SpringBoot框架，Main函数启动  
  . SpringBoot核心快速整合第三方框架原理:Maven继承依赖关系
- SpringBoot重点:
  . 快速整合第三方依赖：maven子父依赖关系
  . springboot 通过引用spring-boot-starter-web依赖，整合SpingMVC框架。只需要引用一个jar包，就可以通过Maven继承的方式引用到Spring-aop,Spring-beans,Spring-core,Spring-web等相关依赖
  
- springboot没有配置文件，如何进行初始化
  . 在没有web.xml配置文件的情况，通过java代码操作整个SpringMVC的初始化过程，java代码最终会生成class文件,内置Tomcat就会加载这些class文件，当所有程序加载完成后，项目就可以访问了
  
. springBoot框架流程：先创建Tomcat容器，然后加载class文件，加载过程中如果发现有java代码编写的SpringMVC初始化，就会创建SpringMVC容器。所有程序执行完毕后，项目就可以访问了


# springmvc执行流程及工作原理
. 用户发送请求至前端控制器DispatcherServlet
. DispatcherServlet收到请求调用处理器映射器HandlerMapping。
. 处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。
. DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作
. 执行处理器Handler(Controller，也叫页面控制器)。
. Handler执行完成返回ModelAndView
. HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet
. DispatcherServlet将ModelAndView传给ViewReslover视图解析器
. ViewReslover解析后返回具体View
. DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。
. DispatcherServlet响应用户



# redis缓存穿透、缓存击穿、缓存雪崩解决方案
. 缓存穿透: 指查询一个一定不存在的数据，从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 
            DB去查询，可能导致 DB 挂掉。 1.把这个空结果进行缓存； 2.可能存在的数据哈希到一个足够大的 bitmap 中，
            一个一定不存在的数据会被这个 bitmap 拦截掉
. 缓存击穿: 单个key过期时，出现大量请求，由于过期而查询数据库导致崩溃。1.设置永不过期，逻辑处理过期；2.使用互斥锁，
            先加载db中数据，写回缓存 
. 缓存雪崩: 雪崩是很多 key，击穿是某一个key 缓存。 1.将缓存失效时间分散开


# 序列化
- 系列化是干什么的
   序列化简单来说就保存对象在内存中的状态也可以说是实例化变量。这是Java提供的用来保存 Object state，
   一种保存对象状态的机制。只有实现了serializable接口的类的对象才能被实例化
- 什么情况下会用到序列化  
   . 当你想把内存中的对象写入到硬盘时
   . 当你想用套接字在网络上传输对象时
   . 当你想通过RMI调用对象时
       （RMI是什么东西？）：RMI总结来说就是远程调用对象，在一个jvm上调用另一个jvm的对象
- 序列化需要注意的事项
  . 序列化只保存对象的状态，而不管对象的方法。
  . 当一个父类实现了序列化，它的子类也自动实现序列化，不用显示进行实现了。
  . 当一个实例对象引用其他对象，当序列化该对象时也把引用的对象进行了实例化。


# 分布式基础组件
  https://www.cnblogs.com/burningmyself/p/12941807.html
. Spring Cloud Config：配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，
  目前支持本地存储、Git 以及 Subversion。
. Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 
  联合实现热部署。
. Eureka：云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。
. Hystrix：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。
. Zuul：Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站
  后端所有请求的前门。
. Archaius：配置管理 API，包含一系列配置管理 API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。
. Consul：封装了 Consul 操作，Consul 是一个服务发现与配置工具，与 Docker 容器可以无缝集成。
. Spring Cloud for Cloud Foundry：通过 Oauth2 协议绑定服务到 CloudFoundry，CloudFoundry 是 VMware 推出的开源 PaaS 云平台。
. Spring Cloud Sleuth：日志收集工具包，封装了 Dapper 和 log-based 追踪以及 Zipkin 和 HTrace 操作，为 Spring Cloud 应用实现了一种分布式追踪解决方案。
. Spring Cloud Data Flow：大数据操作工具，作为 Spring XD 的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。
. Ribbon：提供云端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。
. Turbine：Turbine 是聚合服务器发送事件流数据的一个工具，用来监控集群下 Hystrix 的 Metrics 情况。
. Feign：Feign 是一种声明式、模板化的 HTTP 客户端。

# 使用分布式注意事项
虽然现在分布式技术已经十分成熟，但是里面的坑不是一点两点，比如：==如何保证分布式事务的一致性、如何保证服务调用的幂等性、如何保证消息的幂等性、如何设置熔断（服务的降级），如何保证服务的健壮性等等，==这些都是一直需要关注的问题，只有解决了这些问题，你的分布式架构才能真正的立于不败之地










