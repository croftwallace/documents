

# Java是按引用传递还是按值传递
. 请记住，“引用”一词的含义与内存地址相同
. Java通过值传递所有信息 ，而不是通过引用传递所有信息-确保您记住这一点。当我们说所有内容时，我们指的是一切–对象，数 组（在Java中是对象），原始类型（例如int和floats）等–这些都在Java中按值传递。按值传递和按引用传递之间有什么区别？当将一个参数（甚至多个参数）传递给一个方法时，Java将在原始变量内创建一个或多个值的副本，并将其作为参数传递给该方法–这就是为什么将其称为按值传递。传递值的关键在于该方法将不会接收正在传递的实际变量，而只会接收存储在变量内部的值的副本


# volatile 修饰
. 变量的修改对所有线程可见
. 禁止指令重排
. volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值


# Synchronized
. synchronized在运行时，会清空工作内存数据，并从主内存拷贝对象副本到工作内存再执行相应代码
. 可以保证方法或代码块在运行时，同一时刻只有一个线程可以进入到临界区（互斥性），同时它还保证了共享变量的内存可见性。

. 同步代码块使用了 monitorenter 和 monitorexit 指令实现
. 同步方法中依靠方法修饰符上的 ACC_SYNCHRONIZED 实现

    
# synchronized (new object())同步时各种不同类别的监视器以及其引起的问题(常量池的影响)
. 整数和字符串都有一部分属于常量池，这只jvm自有的优化，在使用这两种对象作为同步监视器，则会出现不同步的现象


# 为什么说 Synchronized是非公平锁
 非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等
 待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，
 这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿现象
 
 
# 乐观锁
 乐观锁的核心算法是CAS（CompareandSwap，比较并交换），它涉及到三个操作数：内存值、预期值、新值。
 当且仅当预期值和内存值相等时才将内存值修改为新值。
 这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样，
 如不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，
 否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存


# 线程/工作内存/主内存 三者的关系
. 每个线程都有一个独立的工作内存，用于存储线程私有的数据
. Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问
. 线程对变量的操作(读取赋值等)必须在工作内存中进行。（线程安全问题的根本原因）


# 主内存和工作内存
. 主内存是在运行期间所有变量的存放区域，当工作内存是运行期间中某一线程独立私有的内存存放区域
. 线程间无法访问对方的工作内存空间，都是通过主内存交换来实现
. 主内存的变量在工作内存中的值是复制过去的副本，读写完成后刷新主内存，这意味着主内存如果发生了改变，工作内存并无法获得最新的结果
. 多个线程对一个共享变量进行修改时，都是对自己工作内存的副本进行操作，相互不可见。主内存最后得到的结果是不可预知的



# 创建线程的有哪些方式
. 继承 Thread 类创建线程类
. 通过 Runnable 接口创建线程类
. 通过 Callable 和 Future 创建线程
. 通过线程池创建


# JVM 对 Java 的 原 生 锁 做 了 哪 些 优 化
. 一种优化是使用自旋锁，即在把线程进行阻塞操作之前先让线程自旋等
  待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程
  执行阻塞操作，避免了用户态到内核态的切换


# Java Spring中的Singleton(单例) 和Prototype(原型) Bean范围
. 如果作用域是单例，则每个Spring IoC容器将只实例化该bean的一个实例，并且为每个请求共享同一实例。那就是当一个bean的作用域被声明为singleton时，然后每当对该bean发出新请求时，spring IOC容器都会首先检查该bean的实例是否已经创建。如果已经创建，则IOC容器返回相同的实例，否则仅在第一个请求时才创建该bean的新实例

. 如果将范围声明为prototype，则每次对特定bean发出请求时，spring IOC容器都会创建该bean的新实例



# Spring中的Bean的五个作用域
. Singleton：将为每个Spring IoC容器的单个bean定义创建一个实例，并且对该对象的每个请求将共享同一对象
. Prototype：每次对该bean发出请求时，都会为单个bean定义创建一个新实例
. Request：每次对该bean发出HTTP请求时，都会为单个bean定义创建一个新实例。但是仅在可感知网络的Spring  ApplicationContext上下文中有效
. Session：将单个bean定义的作用域限定为HTTP会话的生命周期。但是仅在可感知网络的Spring ApplicationContext上下文中有效
. Global-Session：将单个bean定义的作用域限定为全局HTTP会话的生命周期。它也仅在可感知网络的Spring ApplicationContext上下文中有效


# 反射


# IOC容器的概念
. IOC容器就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中new相关的对象，应用程序由IOC容器进行组装。在Spring中BeanFactory是IOC容器的实际代表者

. Spring IOC容器如何知道哪些是它管理的对象呢？这就需要配置文件，Spring IOC容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。一般使用基于xml配置文件进行配置元数据，而且Spring与配置文件完全解耦的，可以使用其他任何可能的方式进行配置元数据，比如注解、基于java文件的、基于属性文件的配置都可以。
那Spring IOC容器管理的对象叫什么呢

# Bean的概念
. 由IOC容器管理的那些组成你应用程序的对象我们就叫它Bean， Bean就是由Spring容器初始化、装配及管理的对象，除此之外，bean就与应用程序中的其他对象没有什么区别了


# AOP简介与作用
- AOP简
  . AOP技术是建立在JAVA语言的反射机制与动态代理机制之上的
  . AOP实际是GoF设计模式的延续，设计模式孜孜不倦追求的是调用者和被调用者之间的解耦,提高代码的灵活性和可扩展性，AOP可以说也是这种目标的一种实现
  . 应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持

- AOP主要功能及意图
  . 日志记录，性能统计，安全控制，事务处理，异常处理等等
  . 将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码







